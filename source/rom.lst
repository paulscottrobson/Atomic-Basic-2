
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q --m4510 -D TARGET=1 -b -L rom.lst -o rom.bin basic.asm
; Sun Jul 28 16:12:44 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					TARGET=1

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	4d eb						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_mega65.asm

=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$2000					EXTLowMemory = $2000 						; Workspace RAM starts here
=$8000					EXTHighMemory = $8000 						; Workspace RAM ends here
=$1000					EXTScreen = $1000							; 2k screen RAM here
=$800					EXTCharSet = $800							; 2k character set (0-7F) here
>0000	00 00					.word 	0 								; forces it to be a 64k ROM (at least)
.a000					EXTCBMFont:
>a000	3c 66 6e 6e 60 62 3c 00			.binary "c64-chargen.rom"
>a008	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>a018	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>a028	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>a038	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>a048	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>a058	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>a068	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>a078	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>a088	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>a098	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>a0a8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>a0b8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>a0c8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>a0d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a0e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a0f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a108	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a118	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a128	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a138	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a148	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a158	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a168	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a178	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a188	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a198	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a1a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a1b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a1c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a1d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a1e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a1f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>a208	08 1c 3e 7f 7f 1c 3e 00 18 18 18 18 18 18 18 18
>a218	00 00 00 ff ff 00 00 00 00 00 ff ff 00 00 00 00
>a228	00 ff ff 00 00 00 00 00 00 00 00 00 ff ff 00 00
>a238	30 30 30 30 30 30 30 30 0c 0c 0c 0c 0c 0c 0c 0c
>a248	00 00 00 e0 f0 38 18 18 18 18 1c 0f 07 00 00 00
>a258	18 18 38 f0 e0 00 00 00 c0 c0 c0 c0 c0 c0 ff ff
>a268	c0 e0 70 38 1c 0e 07 03 03 07 0e 1c 38 70 e0 c0
>a278	ff ff c0 c0 c0 c0 c0 c0 ff ff 03 03 03 03 03 03
>a288	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 ff ff 00
>a298	36 7f 7f 7f 3e 1c 08 00 60 60 60 60 60 60 60 60
>a2a8	00 00 00 07 0f 1c 18 18 c3 e7 7e 3c 3c 7e e7 c3
>a2b8	00 3c 7e 66 66 7e 3c 00 18 18 66 66 18 18 3c 00
>a2c8	06 06 06 06 06 06 06 06 08 1c 3e 7f 3e 1c 08 00
>a2d8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>a2e8	18 18 18 18 18 18 18 18 00 00 03 3e 76 36 36 00
>a2f8	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a308	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a318	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a328	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>a338	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>a348	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a358	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>a368	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>a378	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>a388	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>a398	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>a3a8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a3b8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a3c8	00 00 00 00 00 ff ff ff 03 03 03 03 03 03 ff ff
>a3d8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a3e8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a3f8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>a408	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>a418	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>a428	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>a438	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>a448	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>a458	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>a468	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>a478	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>a488	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>a498	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>a4a8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>a4b8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>a4c8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>a4d8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>a4e8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>a4f8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>a508	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>a518	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>a528	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>a538	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>a548	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>a558	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>a568	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>a578	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>a588	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>a598	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>a5a8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>a5b8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>a5c8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>a5d8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>a5e8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>a5f8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>a608	f7 e3 c1 80 80 e3 c1 ff e7 e7 e7 e7 e7 e7 e7 e7
>a618	ff ff ff 00 00 ff ff ff ff ff 00 00 ff ff ff ff
>a628	ff 00 00 ff ff ff ff ff ff ff ff ff 00 00 ff ff
>a638	cf cf cf cf cf cf cf cf f3 f3 f3 f3 f3 f3 f3 f3
>a648	ff ff ff 1f 0f c7 e7 e7 e7 e7 e3 f0 f8 ff ff ff
>a658	e7 e7 c7 0f 1f ff ff ff 3f 3f 3f 3f 3f 3f 00 00
>a668	3f 1f 8f c7 e3 f1 f8 fc fc f8 f1 e3 c7 8f 1f 3f
>a678	00 00 3f 3f 3f 3f 3f 3f 00 00 fc fc fc fc fc fc
>a688	ff c3 81 81 81 81 c3 ff ff ff ff ff ff 00 00 ff
>a698	c9 80 80 80 c1 e3 f7 ff 9f 9f 9f 9f 9f 9f 9f 9f
>a6a8	ff ff ff f8 f0 e3 e7 e7 3c 18 81 c3 c3 81 18 3c
>a6b8	ff c3 81 99 99 81 c3 ff e7 e7 99 99 e7 e7 c3 ff
>a6c8	f9 f9 f9 f9 f9 f9 f9 f9 f7 e3 c1 80 c1 e3 f7 ff
>a6d8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>a6e8	e7 e7 e7 e7 e7 e7 e7 e7 ff ff fc c1 89 c9 c9 ff
>a6f8	00 80 c0 e0 f0 f8 fc fe ff ff ff ff ff ff ff ff
>a708	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>a718	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>a728	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>a738	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>a748	00 01 03 07 0f 1f 3f 7f fc fc fc fc fc fc fc fc
>a758	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>a768	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>a778	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>a788	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>a798	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>a7a8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>a7b8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>a7c8	ff ff ff ff ff 00 00 00 fc fc fc fc fc fc 00 00
>a7d8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>a7e8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>a7f8	0f 0f 0f 0f f0 f0 f0 f0 3c 66 6e 6e 60 62 3c 00
>a808	00 00 3c 06 3e 66 3e 00 00 60 60 7c 66 66 7c 00
>a818	00 00 3c 60 60 60 3c 00 00 06 06 3e 66 66 3e 00
>a828	00 00 3c 66 7e 60 3c 00 00 0e 18 3e 18 18 18 00
>a838	00 00 3e 66 66 3e 06 7c 00 60 60 7c 66 66 66 00
>a848	00 18 00 38 18 18 3c 00 00 06 00 06 06 06 06 3c
>a858	00 60 60 6c 78 6c 66 00 00 38 18 18 18 18 3c 00
>a868	00 00 66 7f 7f 6b 63 00 00 00 7c 66 66 66 66 00
>a878	00 00 3c 66 66 66 3c 00 00 00 7c 66 66 7c 60 60
>a888	00 00 3e 66 66 3e 06 06 00 00 7c 66 60 60 60 00
>a898	00 00 3e 60 3c 06 7c 00 00 18 7e 18 18 18 0e 00
>a8a8	00 00 66 66 66 66 3e 00 00 00 66 66 66 3c 18 00
>a8b8	00 00 63 6b 7f 3e 36 00 00 00 66 3c 18 3c 66 00
>a8c8	00 00 66 66 66 3e 0c 78 00 00 7e 0c 18 30 7e 00
>a8d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a8e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a8f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a908	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a918	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a928	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a938	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a948	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a958	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a968	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a978	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a988	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a998	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a9a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a9b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a9c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a9d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a9e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a9f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>aa08	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>aa18	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>aa28	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>aa38	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>aa48	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>aa58	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>aa68	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>aa78	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>aa88	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>aa98	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>aaa8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>aab8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>aac8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>aad8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>aae8	18 18 18 18 18 18 18 18 33 33 cc cc 33 33 cc cc
>aaf8	33 99 cc 66 33 99 cc 66 00 00 00 00 00 00 00 00
>ab08	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>ab18	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>ab28	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>ab38	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>ab48	cc 99 33 66 cc 99 33 66 03 03 03 03 03 03 03 03
>ab58	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>ab68	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>ab78	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>ab88	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>ab98	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>aba8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>abb8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>abc8	00 00 00 00 00 ff ff ff 01 03 06 6c 78 70 60 00
>abd8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>abe8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>abf8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>ac08	ff ff c3 f9 c1 99 c1 ff ff 9f 9f 83 99 99 83 ff
>ac18	ff ff c3 9f 9f 9f c3 ff ff f9 f9 c1 99 99 c1 ff
>ac28	ff ff c3 99 81 9f c3 ff ff f1 e7 c1 e7 e7 e7 ff
>ac38	ff ff c1 99 99 c1 f9 83 ff 9f 9f 83 99 99 99 ff
>ac48	ff e7 ff c7 e7 e7 c3 ff ff f9 ff f9 f9 f9 f9 c3
>ac58	ff 9f 9f 93 87 93 99 ff ff c7 e7 e7 e7 e7 c3 ff
>ac68	ff ff 99 80 80 94 9c ff ff ff 83 99 99 99 99 ff
>ac78	ff ff c3 99 99 99 c3 ff ff ff 83 99 99 83 9f 9f
>ac88	ff ff c1 99 99 c1 f9 f9 ff ff 83 99 9f 9f 9f ff
>ac98	ff ff c1 9f c3 f9 83 ff ff e7 81 e7 e7 e7 f1 ff
>aca8	ff ff 99 99 99 99 c1 ff ff ff 99 99 99 c3 e7 ff
>acb8	ff ff 9c 94 80 c1 c9 ff ff ff 99 c3 e7 c3 99 ff
>acc8	ff ff 99 99 99 c1 f3 87 ff ff 81 f3 e7 cf 81 ff
>acd8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>ace8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>acf8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>ad08	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>ad18	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>ad28	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>ad38	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>ad48	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>ad58	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>ad68	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>ad78	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>ad88	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>ad98	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>ada8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>adb8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>adc8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>add8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>ade8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>adf8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>ae08	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>ae18	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>ae28	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>ae38	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>ae48	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>ae58	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>ae68	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>ae78	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>ae88	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>ae98	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>aea8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>aeb8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>aec8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>aed8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>aee8	e7 e7 e7 e7 e7 e7 e7 e7 cc cc 33 33 cc cc 33 33
>aef8	cc 66 33 99 cc 66 33 99 ff ff ff ff ff ff ff ff
>af08	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>af18	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>af28	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>af38	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>af48	33 66 cc 99 33 66 cc 99 fc fc fc fc fc fc fc fc
>af58	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>af68	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>af78	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>af88	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>af98	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>afa8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>afb8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>afc8	ff ff ff ff ff 00 00 00 fe fc f9 93 87 8f 9f ff
>afd8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>afe8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>aff8	0f 0f 0f 0f f0 f0 f0 f0
.b000					EXTStartPersonalise:
.b000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.b002	9a		txs			txs
.b003	20 b8 b0	jsr $b0b8		jsr 	EXTReset 						; reset video
.b006	20 68 b0	jsr $b068		jsr 	EXTClearScreen 					; clear screen
.b009	4c 4d eb	jmp $eb4d		jmp 	Start 							; start main application
.b00c					EXTReadKeyPort:
.b00c	db		phz			phz
.b00d	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress
.b010	ea		nop			nop 									; read keyboard
.b011	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b013	fb		plz			plz
.b014	c9 00		cmp #$00		cmp 	#0 								; set Z
.b016	60		rts			rts
.b017					EXTRemoveKeyPressed:
.b017	48		pha			pha
.b018	db		phz			phz
.b019	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress
.b01c	a9 00		lda #$00		lda 	#0
.b01e	ea		nop			nop 									; read keyboard
.b01f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b021	fb		plz			plz
.b022	68		pla			pla
.b023	60		rts			rts
.b024					EXTSetupKeyAddress:
.b024	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to read keyboard.
.b026	85 07		sta $07			sta 	EXTZPWork+3
.b028	a9 fd		lda #$fd		lda 	#$FD
.b02a	85 06		sta $06			sta 	EXTZPWork+2
.b02c	a9 36		lda #$36		lda 	#$36
.b02e	85 05		sta $05			sta 	EXTZPWork+1
.b030	a9 10		lda #$10		lda 	#$10
.b032	85 04		sta $04			sta 	EXTZPWork+0
.b034	a3 00		ldz #$00		ldz 	#0
.b036	60		rts			rts
.b037					EXTCheckBreak:
.b037	db		phz			phz
.b038	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress 				; point to keyboard
.b03b	e6 04		inc $04			inc 	EXTZPWork 						; point to modifiers.
.b03d	ea		nop			nop 									; read modifiers.
.b03e	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b040	fb		plz			plz 									; restore Z
.b041	29 05		and #$05		and 	#5								; break is LeftShift+Ctrl
.b043	c9 05		cmp #$05		cmp 	#5
.b045	f0 03		beq $b04a		beq 	_EXTCBYes
.b047	a9 00		lda #$00		lda 	#0
.b049	60		rts			rts
.b04a					_EXTCBYes:
.b04a	a9 01		lda #$01		lda 	#1
.b04c	60		rts			rts
.b04d					EXTReadScreen:
.b04d	5a		phy			phy 										; save Y
.b04e	8a		txa			txa 										; multiply XY by 2
.b04f	85 04		sta $04			sta 	EXTZPWork							; into EXTZPWork
.b051	98		tya			tya
.b052	09 10		ora #$10		ora 	#EXTScreen>>8 						; move into screen area
.b054	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.b056	a0 00		ldy #$00		ldy 	#0
.b058	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b05a	7a		ply			ply 										; restore Y and exit.
.b05b	60		rts			rts
.b05c					EXTWriteScreen:
.b05c	5a		phy			phy
.b05d	48		pha			pha
.b05e	20 4d b0	jsr $b04d		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.b061	a0 00		ldy #$00		ldy 	#0
.b063	68		pla			pla 										; restore and write.
.b064	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b066	7a		ply			ply
.b067	60		rts			rts
.b068					EXTClearScreen:
.b068	48		pha			pha 										; save registers
.b069	5a		phy			phy
.b06a	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set up pointer
.b06c	85 04		sta $04			sta 	EXTZPWork
.b06e	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b070	85 05		sta $05			sta 	EXTZPWork+1
.b072	a0 00		ldy #$00		ldy 	#0
.b074					_EXTCSLoop:
.b074	a9 20		lda #$20		lda 	#32
.b076	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b078	c8		iny			iny
.b079	d0 f9		bne $b074		bne 	_EXTCSLoop
.b07b	e6 05		inc $05			inc 	EXTZPWork+1 						; next screen page
.b07d	a5 05		lda $05			lda 	EXTZPWork+1
.b07f	c9 18		cmp #$18		cmp 	#(EXTScreen>>8)+8 					; done 2k ?
.b081	d0 f1		bne $b074		bne 	_EXTCSLoop
.b083	7a		ply			ply 										; restore
.b084	68		pla			pla
.b085	60		rts			rts
.b086					EXTScrollDisplay:
.b086	48		pha			pha 										; save registers
.b087	5a		phy			phy
.b088	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set pointer to screen
.b08a	85 04		sta $04			sta 	EXTZPWork+0
.b08c	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b08e	85 05		sta $05			sta 	EXTZPWork+1
.b090					_EXTScroll:
.b090	a0 28		ldy #$28		ldy 	#EXTWidth 							; x 2 because of two byte format.
.b092	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b094	a0 00		ldy #$00		ldy 	#0
.b096	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b098	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.b09a	d0 02		bne $b09e		bne 	_EXTNoCarry
.b09c	e6 05		inc $05			inc 	EXTZPWork+1
.b09e					_EXTNoCarry:
.b09e	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.b0a0	c9 c0		cmp #$c0		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) & $FF
.b0a2	d0 ec		bne $b090		bne 	_EXTScroll
.b0a4	a5 05		lda $05			lda 	EXTZPWork+1
.b0a6	c9 13		cmp #$13		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) >> 8
.b0a8	d0 e6		bne $b090		bne 	_EXTScroll
.b0aa	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.b0ac					_EXTLastLine:
.b0ac	a9 20		lda #$20		lda 	#32
.b0ae	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b0b0	c8		iny			iny
.b0b1	c0 28		cpy #$28		cpy 	#EXTWidth
.b0b3	d0 f7		bne $b0ac		bne 	_EXTLastLine
.b0b5	7a		ply			ply 										; restore and exit.
.b0b6	68		pla			pla
.b0b7	60		rts			rts
.b0b8					EXTReset:
.b0b8	48		pha			pha 									; save registers
.b0b9	da		phx			phx
.b0ba	5a		phy			phy
.b0bb	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to video system.
.b0bd	85 07		sta $07			sta 	EXTZPWork+3
.b0bf	a9 fd		lda #$fd		lda 	#$FD
.b0c1	85 06		sta $06			sta 	EXTZPWork+2
.b0c3	a9 30		lda #$30		lda 	#$30
.b0c5	85 05		sta $05			sta 	EXTZPWork+1
.b0c7	a9 00		lda #$00		lda 	#$00
.b0c9	85 04		sta $04			sta 	EXTZPWork+0
.b0cb	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0cd	a9 47		lda #$47		lda 	#$47
.b0cf	ea		nop			nop
.b0d0	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0d2	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0d4	a9 53		lda #$53		lda 	#$53
.b0d6	ea		nop			nop
.b0d7	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0d9	a3 30		ldz #$30		ldz 	#$30 							; address already set up
.b0db	a9 40		lda #$40		lda 	#$40
.b0dd	ea		nop			nop
.b0de	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0e0	a3 31		ldz #$31		ldz 	#$31 							; address already set up
.b0e2	a9 40		lda #$40		lda 	#$40
.b0e4	ea		nop			nop
.b0e5	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0e7	ad 31 d0	lda $d031		lda $d031	; VIC-III Control Register B
.b0ea	29 40		and #$40		and #$40	; bit-6 is 4mhz
.b0ec	8d 31 d0	sta $d031		sta $d031
.b0ef	a3 20		ldz #$20		ldz 	#$20 							; address already set up
.b0f1	a9 00		lda #$00		lda 	#0
.b0f3	ea		nop			nop
.b0f4	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0f6	a3 21		ldz #$21		ldz 	#$21 							; address already set up
.b0f8	a9 00		lda #$00		lda 	#0
.b0fa	ea		nop			nop
.b0fb	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0fd	a3 6f		ldz #$6f		ldz 	#$6F 							; address already set up
.b0ff	a9 80		lda #$80		lda 	#$80
.b101	ea		nop			nop
.b102	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b104	ad 66 d0	lda $d066		lda $d066
.b107	29 7f		and #$7f		and #$7F
.b109	8d 66 d0	sta $d066		sta $d066
.b10c	a3 6a		ldz #$6a		ldz 	#$6A 							; address already set up
.b10e	a9 00		lda #$00		lda 	#$00
.b110	ea		nop			nop
.b111	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b113	a3 6b		ldz #$6b		ldz 	#$6B 							; address already set up
.b115	a9 00		lda #$00		lda 	#$00
.b117	ea		nop			nop
.b118	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b11a	a3 78		ldz #$78		ldz 	#$78 							; address already set up
.b11c	a9 00		lda #$00		lda 	#$00
.b11e	ea		nop			nop
.b11f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b121	a3 5f		ldz #$5f		ldz 	#$5F 							; address already set up
.b123	a9 00		lda #$00		lda 	#$00
.b125	ea		nop			nop
.b126	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b128	a3 5a		ldz #$5a		ldz 	#$5A 							; address already set up
.b12a	a9 78		lda #$78		lda 	#$78
.b12c	ea		nop			nop
.b12d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b12f	a3 5d		ldz #$5d		ldz 	#$5D 							; address already set up
.b131	a9 c0		lda #$c0		lda 	#$C0
.b133	ea		nop			nop
.b134	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b136	a3 5c		ldz #$5c		ldz 	#$5C 							; address already set up
.b138	a9 50		lda #$50		lda 	#80
.b13a	ea		nop			nop
.b13b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b13d	a9 ff		lda #$ff		lda #$ff
.b13f	8d 01 dd	sta $dd01		sta $DD01
.b142	8d 00 dd	sta $dd00		sta $DD00
.b145	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b147	a9 14		lda #$14		lda 	#$14
.b149	ea		nop			nop
.b14a	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b14c	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b14e	a9 1b		lda #$1b		lda 	#$1B
.b150	ea		nop			nop
.b151	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b153	a3 16		ldz #$16		ldz 	#$16 							; address already set up
.b155	a9 c8		lda #$c8		lda 	#$C8
.b157	ea		nop			nop
.b158	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b15a	a3 c5		ldz #$c5		ldz 	#$C5 							; address already set up
.b15c	a9 54		lda #$54		lda 	#$54
.b15e	ea		nop			nop
.b15f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b161	a3 58		ldz #$58		ldz 	#$58 							; address already set up
.b163	a9 50		lda #$50		lda 	#80
.b165	ea		nop			nop
.b166	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b168	a3 59		ldz #$59		ldz 	#$59 							; address already set up
.b16a	a9 00		lda #$00		lda 	#0
.b16c	ea		nop			nop
.b16d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b16f	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b171	a9 42		lda #$42		lda 	#$42
.b173	ea		nop			nop
.b174	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b176	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b178	a9 1b		lda #$1b		lda 	#$1B
.b17a	ea		nop			nop
.b17b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b17d	a9 00		lda #$00		lda 	#$00							; colour RAM at $1F800-1FFFF (2kb)
.b17f	85 07		sta $07			sta 	EXTZPWork+3
.b181	a9 01		lda #$01		lda 	#$01
.b183	85 06		sta $06			sta 	EXTZPWork+2
.b185	a9 f8		lda #$f8		lda 	#$F8
.b187	85 05		sta $05			sta 	EXTZPWork+1
.b189	a9 00		lda #$00		lda 	#$00
.b18b	85 04		sta $04			sta 	EXTZPWork+0
.b18d	a3 00		ldz #$00		ldz 	#0
.b18f					_EXTClearColorRam:
.b18f	a9 08		lda #$08		lda 	#8 								; fill that with this colour.
.b191	ea		nop			nop
.b192	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b194	3b		dez			dez
.b195	d0 f8		bne $b18f		bne 	_EXTClearColorRam
.b197	e6 05		inc $05			inc 	EXTZPWork+1
.b199	d0 f4		bne $b18f		bne 	_EXTClearColorRam
.b19b	a2 00		ldx #$00		ldx 	#0 								; copy PET Font into memory.
.b19d					_EXTCopyCBMFont:
.b19d	bd 00 a0	lda $a000,x		lda 	EXTCBMFont,x
.b1a0	9d 00 08	sta $0800,x		sta 	EXTCharSet,x
.b1a3	bd 00 a1	lda $a100,x		lda 	EXTCBMFont+$100,x
.b1a6	9d 00 09	sta $0900,x		sta 	EXTCharSet+$100,x
.b1a9	bd 00 a2	lda $a200,x		lda 	EXTCBMFont+$200,x
.b1ac	9d 00 0a	sta $0a00,x		sta 	EXTCharSet+$200,x
.b1af	bd 00 a3	lda $a300,x		lda 	EXTCBMFont+$300,x
.b1b2	9d 00 0b	sta $0b00,x		sta 	EXTCharSet+$300,x
.b1b5	ca		dex			dex
.b1b6	d0 e5		bne $b19d		bne 	_EXTCopyCBMFont
.b1b8	7a		ply			ply 									; restore and exit.
.b1b9	fa		plx			plx
.b1ba	68		pla			pla
.b1bb	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	0b e6					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	64 eb					.word	SyntaxError                   ; """        ($0081)
>e004	64 eb					.word	SyntaxError                   ; "#"        ($0082)
>e006	00 e6					.word	BFUNC_String                  ; "$"        ($0083)
>e008	9f e7					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	12 e6					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	64 eb					.word	SyntaxError                   ; "'"        ($0086)
>e00e	64 eb					.word	SyntaxError                   ; "("        ($0087)
>e010	64 eb					.word	SyntaxError                   ; ")"        ($0088)
>e012	81 e6					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	b4 e5					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	da e5					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	d8 e6					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	64 eb					.word	SyntaxError                   ; ":"        ($008d)
>e01c	64 eb					.word	SyntaxError                   ; ";"        ($008e)
>e01e	1d e8					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	be e7					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	f8 e7					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	bb e7					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	fb e7					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	1a e8					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	04 e6					.word	BFUNC_ByteInd                 ; "?"        ($0095)
>e02c	5c e6					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	9a e9					.word	COMMAND_Assert                ; "assert"   ($0097)
>e030	d4 e8					.word	UNARY_Abs                     ; "abs"      ($0098)
>e032	db e9					.word	COMMAND_Clear                 ; "clear"    ($0099)
>e034	bf e8					.word	UNARY_Ch                      ; "ch"       ($009a)
>e036	64 eb					.word	SyntaxError                   ; "do"       ($009b)
>e038	96 e9					.word	COMMAND_End                   ; "end"      ($009c)
>e03a	64 eb					.word	SyntaxError                   ; "for"      ($009d)
>e03c	64 eb					.word	SyntaxError                   ; "gosub"    ($009e)
>e03e	64 eb					.word	SyntaxError                   ; "goto"     ($009f)
>e040	64 eb					.word	SyntaxError                   ; "input"    ($00a0)
>e042	64 eb					.word	SyntaxError                   ; "if"       ($00a1)
>e044	64 eb					.word	SyntaxError                   ; "list"     ($00a2)
>e046	64 eb					.word	SyntaxError                   ; "loop"     ($00a3)
>e048	64 eb					.word	SyntaxError                   ; "link"     ($00a4)
>e04a	45 ea					.word	COMMAND_Let                   ; "let"      ($00a5)
>e04c	7d e8					.word	UNARY_Len                     ; "len"      ($00a6)
>e04e	64 eb					.word	SyntaxError                   ; "next"     ($00a7)
>e050	c8 e9					.word	COMMAND_New                   ; "new"      ($00a8)
>e052	0f ea					.word	COMMAND_Old                   ; "old"      ($00a9)
>e054	64 eb					.word	SyntaxError                   ; "print"    ($00aa)
>e056	be e9					.word	COMMAND_Rem                   ; "rem"      ($00ab)
>e058	f1 e8					.word	UNARY_Rnd                     ; "rnd"      ($00ac)
>e05a	8e e9					.word	COMMAND_Stop                  ; "stop"     ($00ad)
>e05c	64 eb					.word	SyntaxError                   ; "step"     ($00ae)
>e05e	64 eb					.word	SyntaxError                   ; "then"     ($00af)
>e060	dc e8					.word	UNARY_Top                     ; "top"      ($00b0)
>e062	64 eb					.word	SyntaxError                   ; "to"       ($00b1)
>e064	37 e6					.word	BFUNC_Or                      ; "|"        ($00b2)
>e066	3c e8					.word	BFUNC_StringCompare           ; "~"        ($00b3)
.e068					TokenText:
>e068	a1					.byte $a1                             ; $0080 !
>e069	a2					.byte $a2                             ; $0081 "
>e06a	a3					.byte $a3                             ; $0082 #
>e06b	a4					.byte $a4                             ; $0083 $
>e06c	a5					.byte $a5                             ; $0084 %
>e06d	a6					.byte $a6                             ; $0085 &
>e06e	a7					.byte $a7                             ; $0086 '
>e06f	a8					.byte $a8                             ; $0087 (
>e070	a9					.byte $a9                             ; $0088 )
>e071	aa					.byte $aa                             ; $0089 *
>e072	ab					.byte $ab                             ; $008a +
>e073	ad					.byte $ad                             ; $008b -
>e074	af					.byte $af                             ; $008c /
>e075	ba					.byte $ba                             ; $008d :
>e076	bb					.byte $bb                             ; $008e ;
>e077	3c bd					.byte $3c,$bd                         ; $008f <=
>e079	3c be					.byte $3c,$be                         ; $0090 <>
>e07b	bc					.byte $bc                             ; $0091 <
>e07c	bd					.byte $bd                             ; $0092 =
>e07d	3e bd					.byte $3e,$bd                         ; $0093 >=
>e07f	be					.byte $be                             ; $0094 >
>e080	bf					.byte $bf                             ; $0095 ?
>e081	de					.byte $de                             ; $0096 ^
>e082	61 73 73 65 72 f4			.byte $61,$73,$73,$65,$72,$f4         ; $0097 assert
>e088	61 62 f3				.byte $61,$62,$f3                     ; $0098 abs
>e08b	63 6c 65 61 f2				.byte $63,$6c,$65,$61,$f2             ; $0099 clear
>e090	63 e8					.byte $63,$e8                         ; $009a ch
>e092	64 ef					.byte $64,$ef                         ; $009b do
>e094	65 6e e4				.byte $65,$6e,$e4                     ; $009c end
>e097	66 6f f2				.byte $66,$6f,$f2                     ; $009d for
>e09a	67 6f 73 75 e2				.byte $67,$6f,$73,$75,$e2             ; $009e gosub
>e09f	67 6f 74 ef				.byte $67,$6f,$74,$ef                 ; $009f goto
>e0a3	69 6e 70 75 f4				.byte $69,$6e,$70,$75,$f4             ; $00a0 input
>e0a8	69 e6					.byte $69,$e6                         ; $00a1 if
>e0aa	6c 69 73 f4				.byte $6c,$69,$73,$f4                 ; $00a2 list
>e0ae	6c 6f 6f f0				.byte $6c,$6f,$6f,$f0                 ; $00a3 loop
>e0b2	6c 69 6e eb				.byte $6c,$69,$6e,$eb                 ; $00a4 link
>e0b6	6c 65 f4				.byte $6c,$65,$f4                     ; $00a5 let
>e0b9	6c 65 ee				.byte $6c,$65,$ee                     ; $00a6 len
>e0bc	6e 65 78 f4				.byte $6e,$65,$78,$f4                 ; $00a7 next
>e0c0	6e 65 f7				.byte $6e,$65,$f7                     ; $00a8 new
>e0c3	6f 6c e4				.byte $6f,$6c,$e4                     ; $00a9 old
>e0c6	70 72 69 6e f4				.byte $70,$72,$69,$6e,$f4             ; $00aa print
>e0cb	72 65 ed				.byte $72,$65,$ed                     ; $00ab rem
>e0ce	72 6e e4				.byte $72,$6e,$e4                     ; $00ac rnd
>e0d1	73 74 6f f0				.byte $73,$74,$6f,$f0                 ; $00ad stop
>e0d5	73 74 65 f0				.byte $73,$74,$65,$f0                 ; $00ae step
>e0d9	74 68 65 ee				.byte $74,$68,$65,$ee                 ; $00af then
>e0dd	74 6f f0				.byte $74,$6f,$f0                     ; $00b0 top
>e0e0	74 ef					.byte $74,$ef                         ; $00b1 to
>e0e2	fc					.byte $fc                             ; $00b2 |
>e0e3	fe					.byte $fe                             ; $00b3 ~
>e0e4	00					.byte $00
.e0e5					TokenTypeInformation:
>e0e5	04					.byte $04                             ; $0080 !
>e0e6	0a					.byte $0a                             ; $0081 "
>e0e7	0a					.byte $0a                             ; $0082 #
>e0e8	04					.byte $04                             ; $0083 $
>e0e9	03					.byte $03                             ; $0084 %
>e0ea	00					.byte $00                             ; $0085 &
>e0eb	0a					.byte $0a                             ; $0086 '
>e0ec	0a					.byte $0a                             ; $0087 (
>e0ed	0a					.byte $0a                             ; $0088 )
>e0ee	03					.byte $03                             ; $0089 *
>e0ef	02					.byte $02                             ; $008a +
>e0f0	02					.byte $02                             ; $008b -
>e0f1	03					.byte $03                             ; $008c /
>e0f2	0a					.byte $0a                             ; $008d :
>e0f3	0a					.byte $0a                             ; $008e ;
>e0f4	01					.byte $01                             ; $008f <=
>e0f5	01					.byte $01                             ; $0090 <>
>e0f6	01					.byte $01                             ; $0091 <
>e0f7	01					.byte $01                             ; $0092 =
>e0f8	01					.byte $01                             ; $0093 >=
>e0f9	01					.byte $01                             ; $0094 >
>e0fa	04					.byte $04                             ; $0095 ?
>e0fb	00					.byte $00                             ; $0096 ^
>e0fc	04					.byte $04                             ; $0097 assert
>e0fd	09					.byte $09                             ; $0098 abs
>e0fe	04					.byte $04                             ; $0099 clear
>e0ff	09					.byte $09                             ; $009a ch
>e100	04					.byte $04                             ; $009b do
>e101	04					.byte $04                             ; $009c end
>e102	04					.byte $04                             ; $009d for
>e103	04					.byte $04                             ; $009e gosub
>e104	04					.byte $04                             ; $009f goto
>e105	04					.byte $04                             ; $00a0 input
>e106	04					.byte $04                             ; $00a1 if
>e107	04					.byte $04                             ; $00a2 list
>e108	04					.byte $04                             ; $00a3 loop
>e109	04					.byte $04                             ; $00a4 link
>e10a	04					.byte $04                             ; $00a5 let
>e10b	09					.byte $09                             ; $00a6 len
>e10c	04					.byte $04                             ; $00a7 next
>e10d	04					.byte $04                             ; $00a8 new
>e10e	04					.byte $04                             ; $00a9 old
>e10f	04					.byte $04                             ; $00aa print
>e110	04					.byte $04                             ; $00ab rem
>e111	09					.byte $09                             ; $00ac rnd
>e112	04					.byte $04                             ; $00ad stop
>e113	04					.byte $04                             ; $00ae step
>e114	04					.byte $04                             ; $00af then
>e115	09					.byte $09                             ; $00b0 top
>e116	04					.byte $04                             ; $00b1 to
>e117	00					.byte $00                             ; $00b2 |
>e118	01					.byte $01                             ; $00b3 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CH = $009a
=$009b					KW_DO = $009b
=$009c					KW_END = $009c
=$009d					KW_FOR = $009d
=$009e					KW_GOSUB = $009e
=$009f					KW_GOTO = $009f
=$00a0					KW_INPUT = $00a0
=$00a1					KW_IF = $00a1
=$00a2					KW_LIST = $00a2
=$00a3					KW_LOOP = $00a3
=$00a4					KW_LINK = $00a4
=$00a5					KW_LET = $00a5
=$00a6					KW_LEN = $00a6
=$00a7					KW_NEXT = $00a7
=$00a8					KW_NEW = $00a8
=$00a9					KW_OLD = $00a9
=$00aa					KW_PRINT = $00aa
=$00ab					KW_REM = $00ab
=$00ac					KW_RND = $00ac
=$00ad					KW_STOP = $00ad
=$00ae					KW_STEP = $00ae
=$00af					KW_THEN = $00af
=$00b0					KW_TOP = $00b0
=$00b1					KW_TO = $00b1
=$00b2					KW_BAR = $00b2
=$00b3					KW_TILDE = $00b3

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e119					CheckNextCharacter:
.e119	8d 97 20	sta $2097			sta 	Temp1 						; save character to check
.e11c					_CNCLoop:
.e11c	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e11e	f0 0b		beq $e12b			beq 	_CNCFail 					; end of line, so no character
.e120	c8		iny				iny
.e121	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e123	f0 f7		beq $e11c			beq 	_CNCLoop
.e125	cd 97 20	cmp $2097			cmp 	Temp1 						; fail if not what was wanted
.e128	d0 01		bne $e12b			bne 	_CNCFail
.e12a	60		rts				rts
.e12b					_CNCFail:
.e12b	20 69 eb	jsr $eb69			jsr 	ReportError
>e12e	4d 69 73 73 69 6e 67 20				.text 	"Missing token",$00
>e136	74 6f 6b 65 6e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e13c							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zBasicStack:	.word 	? 					; stack for BASIC.
>0024					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0026					zTemp1:			.word 	?					; temporary vars
>0028					zTemp2:			.word 	?
>002a					zTargetAddr: 	.dword 	? 					; address of LHS of assignment
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>2095					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>2097					Temp1:			.dword	?					; 4 byte temporary stores.
>209b					SignCount:		.byte 	? 					; count of signs in divide.
>209c					StringBufferPos:.byte 	? 					; next free slot in string buffer
>209d					RandomSeed 		.word 	? 					; Random Number
>209f					xCursor 		.byte 	? 					; cursor position
>20a0					yCursor 		.byte 	?
>20a1									.align	256
.2100					TokeniseBuffer:
.2100					StringBuffer:
>2100									.byte ?
>2101									.align	256
.2200					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e13c					EvaluateSNError:
.e13c	4c 64 eb	jmp $eb64			jmp 	SyntaxError
.e13f					EvaluateMissingQuote:
.e13f	20 69 eb	jsr $eb69			jsr 	ReportError
>e142	4d 69 73 73 69 6e 67 20				.text 	"Missing quote",$00
>e14a	71 75 6f 74 65 00
.e150					EvaluateStringFull:
.e150	20 69 eb	jsr $eb69			jsr 	ReportError
>e153	53 74 72 69 6e 67 20 42				.text 	"String Buffer full",$00
>e15b	75 66 66 65 72 20 66 75 6c 6c 00
.e166					EvaluateBadHex:
.e166	20 69 eb	jsr $eb69			jsr 	ReportError
>e169	42 61 64 20 48 65 78 00				.text 	"Bad Hex",$00
.e171					EvaluateAtomCurrentLevel:
.e171	a9 07		lda #$07			lda 	#7
.e173	80 04		bra $e179			bra 	EvaluateAtPrecedenceLevel
.e175					EvaluateBase:
.e175	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e177					EvaluateBaseCurrentLevel:
.e177	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e179					EvaluateAtPrecedenceLevel:
.e179	48		pha				pha 								; save precedence level
.e17a	a9 00		lda #$00			lda 	#0 							; zero the result.
.e17c	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e17f	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e182	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e185	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e188					_EVALSkipSpace1:
.e188	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e18a	f0 b0		beq $e13c			beq 	EvaluateSNError 			; end of line, without token.
.e18c	c8		iny				iny
.e18d	c9 20		cmp #$20			cmp 	#32
.e18f	f0 f7		beq $e188			beq 	_EVALSkipSpace1
.e191	88		dey				dey 								; points at the token.
.e192	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e194	f0 14		beq $e1aa			beq 	_EVALString  				; if so load in a constant string
.e196	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e198	f0 36		beq $e1d0			beq 	_EVALHexadecimal
.e19a	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e19c	90 04		bcc $e1a2			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e19e	c9 3a		cmp #$3a			cmp 	#'9'+1
.e1a0	90 03		bcc $e1a5			bcc 	_EVALDecimal
.e1a2					_EVALGoKeywordVariable:
.e1a2	4c 27 e2	jmp $e227			jmp 	_EVALKeywordVariable
.e1a5					_EVALDecimal:
.e1a5	20 84 e2	jsr $e284			jsr 	EVALGetDecConstant 			; get decimal constant
.e1a8	80 34		bra $e1de			bra 	_EVALGotAtom 				; got atom.
.e1aa					_EVALString:
.e1aa	da		phx				phx 								; save X on stack
.e1ab	a9 21		lda #$21			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e1ad	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1b0	ad 9c 20	lda $209c			lda 	StringBufferPos 			; X = Buffer Position.
.e1b3	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e1b6	aa		tax				tax 								; put in X to build the string.
.e1b7	c8		iny				iny 								; skip over opening quote character
.e1b8					_EVALStringCopy:
.e1b8	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e1ba	c8		iny				iny
.e1bb	f0 82		beq $e13f			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e1bd	9d 00 21	sta $2100,x			sta 	StringBuffer,x 				; copy into the buffer
.e1c0	e8		inx				inx 								; and bump that pointer.
.e1c1	f0 8d		beq $e150			beq 	EvaluateStringFull 			; buffer is full.
.e1c3	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e1c5	d0 f1		bne $e1b8			bne 	_EVALStringCopy
.e1c7	8e 9c 20	stx $209c			stx 	StringBufferPos 			; this is the new next free slot.
.e1ca	9d ff 20	sta $20ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e1cd	fa		plx				plx 								; restore X
.e1ce	80 0e		bra $e1de			bra 	_EVALGotAtom 				; got the atom.
.e1d0					_EVALHexaDecimal
.e1d0	c8		iny				iny 								; skip over the '#'
.e1d1	5a		phy				phy 								; save Y
.e1d2	20 f0 e2	jsr $e2f0			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e1d5	8c 97 20	sty $2097			sty 	Temp1 						; has Y changed ?
.e1d8	68		pla				pla
.e1d9	cd 97 20	cmp $2097			cmp 	Temp1
.e1dc	f0 88		beq $e166			beq 	EvaluateBadHex 				; if not, error.
.e1de					_EVALGotAtom:
.e1de					_EVALGetOperator:
.e1de	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e1e0	c8		iny				iny 								; this should be binary operator
.e1e1	c9 20		cmp #$20			cmp 	#$20
.e1e3	f0 f9		beq $e1de			beq 	_EVALGetOperator
.e1e5	88		dey				dey
.e1e6	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e1e8	10 3b		bpl $e225			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e1ea	da		phx				phx 								; save X
.e1eb	aa		tax				tax 								; token in X
.e1ec	bd 65 e0	lda $e065,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e1ef	8d 97 20	sta $2097			sta 	Temp1 						; save precedence in Temp1
.e1f2	fa		plx				plx 								; restore X
.e1f3	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e1f5	b0 2e		bcs $e225			bcs 	_EVALExitPullA
.e1f7	68		pla				pla 								; get and save precedence level.
.e1f8	48		pha				pha
.e1f9	cd 97 20	cmp $2097			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e1fc	f0 02		beq $e200			beq 	_EVALDoCalc					; equal, do it.
.e1fe	b0 25		bcs $e225			bcs 	_EVALExitPullA				; too high, then exit.
.e200					_EVALDoCalc:
.e200	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e202	c8		iny				iny
.e203	48		pha				pha
.e204	da		phx				phx
.e205	e8		inx				inx 								; work out right hand side.
.e206	e8		inx				inx
.e207	e8		inx				inx
.e208	e8		inx				inx
.e209	ad 97 20	lda $2097			lda 	Temp1 						; get current operator precedence level.
.e20c	1a		inc a				inc 	a 							; so work it out at the next level.
.e20d	20 79 e1	jsr $e179			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e210	fa		plx				plx 								; fix X back.
.e211	68		pla				pla 								; get keyword
.e212					_EVALExecuteA:
.e212	0a		asl a				asl 	a 							; shift left, drop bit 7
.e213	8d 98 20	sta $2098			sta 	Temp1+1						; save in Temp1.1
.e216	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e218	8d 99 20	sta $2099			sta 	Temp1+2 					; set at Temp1.2
.e21b	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e21d	8d 97 20	sta $2097			sta 	Temp1+0
.e220	20 97 20	jsr $2097			jsr 	Temp1 						; call that routine.
.e223	80 b9		bra $e1de			bra 	_EVALGotAtom 				; and loop back again.
.e225					_EVALExitPullA:
.e225	68		pla				pla 								; restore precedence.
.e226	60		rts				rts
.e227					_EVALKeywordVariable:
.e227	09 00		ora #$00			ora 	#0 							; check bit 7
.e229	10 0f		bpl $e23a			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e22b	da		phx				phx
.e22c	aa		tax				tax
.e22d	bd 65 e0	lda $e065,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e230	fa		plx				plx
.e231	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e233	d0 05		bne $e23a			bne 	_EVALNotUnaryFunction
.e235	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e237	c8		iny				iny 								; consume it
.e238	80 d8		bra $e212			bra 	_EVALExecuteA 				; execute TOS.
.e23a					_EVALNotUnaryFunction:
.e23a	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e23c	10 3d		bpl $e27b			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e23e	c9 8b		cmp #$8b			cmp 	#KW_MINUS 					; check negation
.e240	f0 0f		beq $e251			beq 	_EVALUnaryNegation
.e242	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e244	d0 14		bne $e25a			bne		_EVALCheckUnaryOperator
.e246	c8		iny				iny 								; skip left bracket.
.e247	20 77 e1	jsr $e177			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e24a	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e24c	20 19 e1	jsr $e119			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e24f	80 8d		bra $e1de			bra 	_EVALGotAtom
.e251					_EVALUnaryNegation:
.e251	c8		iny				iny 								; skip over the - sign.
.e252	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e255	20 7a e7	jsr $e77a			jsr 	BFUNC_NegateAlways 			; negate it.
.e258	80 84		bra $e1de			bra 	_EVALGotAtom
.e25a					_EVALCheckUnaryOperator:
.e25a	48		pha				pha 								; save indirection operator.
.e25b	c8		iny				iny 								; skip over the operator
.e25c	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e25f	68		pla				pla 								; restore the operator
.e260	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e262	f0 0e		beq $e272			beq 	_EVALGoGotAtom
.e264	c9 95		cmp #$95			cmp 	#KW_QUESTION				; byte indirection
.e266	f0 07		beq $e26f			beq 	_EVALByteRead
.e268	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e26a	f0 09		beq $e275			beq 	_EVALWordRead
.e26c	4c 64 eb	jmp $eb64			jmp 	SyntaxError 				; give up.
.e26f					_EVALByteRead:
.e26f	20 2f e3	jsr $e32f			jsr 	EVALReadByteIndirect
.e272					_EVALGoGotAtom:
.e272	4c de e1	jmp $e1de			jmp 	_EVALGotAtom
.e275					_EVALWordRead:
.e275	20 58 e3	jsr $e358			jsr 	EVALReadWordIndirect
.e278	4c de e1	jmp $e1de			jmp 	_EVALGotAtom
.e27b					_EVALCheckVariable:
.e27b	20 88 e3	jsr $e388			jsr 	VARReference 				; get variable reference to ZTemp1
.e27e	20 6c e3	jsr $e36c			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e281	4c de e1	jmp $e1de			jmp 	_EVALGotAtom 				; and go round.
.e284					EVALGetDecConstant:
.e284	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e286	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e288	90 04		bcc $e28e			bcc 	_EVGDExit
.e28a	c9 3a		cmp #$3a			cmp 	#'9'+1
.e28c	90 01		bcc $e28f			bcc 	_EVGDValue 					; if so has legal value
.e28e					_EVGDExit:
.e28e	60		rts				rts
.e28f					_EVGDValue:
.e28f	48		pha				pha 								; save value, Y on stack
.e290	5a		phy				phy
.e291	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e293	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e296	48		pha				pha
.e297	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e29a	48		pha				pha
.e29b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e29e	48		pha				pha
.e29f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e2a2	48		pha				pha
.e2a3					_EVGDLoop:
.e2a3	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e2a6	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e2a9	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e2ac	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e2af	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e2b1	d0 1d		bne $e2d0			bne 	_EVGDNoAdd
.e2b3	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e2b4	68		pla				pla
.e2b5	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e2b8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e2bb	68		pla				pla
.e2bc	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e2bf	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e2c2	68		pla				pla
.e2c3	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e2c6	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e2c9	68		pla				pla
.e2ca	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e2cd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e2d0					_EVGDNoAdd:
.e2d0	88		dey				dey
.e2d1	d0 d0		bne $e2a3			bne 	_EVGDLoop
.e2d3	7a		ply				ply 								; restore YA
.e2d4	68		pla				pla
.e2d5	c8		iny				iny 								; next character
.e2d6	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e2d8	18		clc				clc
.e2d9	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e2dc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e2df	90 a3		bcc $e284			bcc 	EVALGetDecConstant 			; propogate constant through
.e2e1	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e2e4	d0 9e		bne $e284			bne 	EVALGetDecConstant
.e2e6	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e2e9	d0 99		bne $e284			bne 	EVALGetDecConstant
.e2eb	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e2ee	80 94		bra $e284			bra 	EVALGetDecConstant 			; go back and try again.
.e2f0					EVALGetHexConstant:
.e2f0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e2f2	20 24 e3	jsr $e324			jsr 	EVALToUpper 				; make upper case
.e2f5	38		sec				sec
.e2f6	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e2f8	90 0a		bcc $e304			bcc 	_EVGHExit 					; exit if CC
.e2fa	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e2fc	90 07		bcc $e305			bcc 	_EVGHValue
.e2fe	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e300	c9 10		cmp #$10			cmp 	#15+1
.e302	90 01		bcc $e305			bcc 	_EVGHValue
.e304					_EVGHExit:
.e304	60		rts				rts
.e305					_EVGHValue:
.e305	5a		phy				phy 								; save Y and new digit.
.e306	48		pha				pha
.e307	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e309					_EVGHRotate:
.e309	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e30c	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e30f	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e312	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e315	88		dey				dey
.e316	d0 f1		bne $e309			bne 	_EVGHRotate
.e318	68		pla				pla 								; restore digit and X
.e319	7a		ply				ply
.e31a	c8		iny				iny 								; next character
.e31b	18		clc				clc
.e31c	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e31f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e322	80 cc		bra $e2f0			bra 	EVALGetHexConstant 			; go back and try again.
.e324					EVALToUpper:
.e324	c9 61		cmp #$61			cmp 	#'a'
.e326	90 06		bcc $e32e			bcc 	_EVTUExit
.e328	c9 7b		cmp #$7b			cmp 	#'z'+1
.e32a	b0 02		bcs $e32e			bcs 	_EVTUExit
.e32c	49 20		eor #$20			eor 	#32
.e32e					_EVTUExit:
.e32e	60		rts				rts
.e32f					EVALReadByteIndirect:
.e32f	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e332	85 26		sta $26				sta 	zTemp1
.e334	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e337	85 27		sta $27				sta 	zTemp1+1
.e339	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e33c	85 28		sta $28				sta 	zTemp1+2
.e33e	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e341	85 29		sta $29				sta 	zTemp1+3
.e343	5a		phy				phy
.e344	a0 00		ldy #$00			ldy 	#0 							; read byte
.e346	b1 26		lda ($26),y			lda 	(zTemp1),y
.e348	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e34b	7a		ply				ply
.e34c	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e34e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e351	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e354	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e357	60		rts				rts
.e358					EVALReadWordIndirect:
.e358	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e35b	85 26		sta $26				sta 	zTemp1
.e35d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e360	85 27		sta $27				sta 	zTemp1+1
.e362	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e365	85 28		sta $28				sta 	zTemp1+2
.e367	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e36a	85 29		sta $29				sta 	zTemp1+3
.e36c					EVALReadWordIndirectZTemp:
.e36c	5a		phy				phy
.e36d	a0 00		ldy #$00			ldy 	#0 							; read word
.e36f	b1 26		lda ($26),y			lda 	(zTemp1),y
.e371	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e374	c8		iny				iny
.e375	b1 26		lda ($26),y			lda 	(zTemp1),y
.e377	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e37a	c8		iny				iny
.e37b	b1 26		lda ($26),y			lda 	(zTemp1),y
.e37d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e380	c8		iny				iny
.e381	b1 26		lda ($26),y			lda 	(zTemp1),y
.e383	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e386	7a		ply				ply
.e387	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e388					VARReference:
.e388	38		sec				sec 								; check range @-Z there
.e389	c9 40		cmp #$40			cmp 	#'@'
.e38b	90 04		bcc $e391			bcc 	_VARRError
.e38d	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e38f	90 03		bcc $e394			bcc 	_VARROkay
.e391					_VARRError:
.e391	4c 64 eb	jmp $eb64			jmp		SyntaxError
.e394					_VARROkay:
.e394	c8		iny				iny 								; consume the variable.
.e395	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e397	f0 1b		beq $e3b4			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e399	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e39b	88		dey				dey 								; point back to the first character
.e39c	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e39e	f0 14		beq $e3b4			beq 	_VARArrayAccess
.e3a0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e3a2	c8		iny				iny
.e3a3	29 1f		and #$1f			and		#31 						; mask out
.e3a5	0a		asl a				asl 	a 							; x 4
.e3a6	0a		asl a				asl 	a
.e3a7	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e3a9	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e3ab	85 27		sta $27				sta 	zTemp1+1
.e3ad	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e3af	85 28		sta $28				sta 	zTemp1+2
.e3b1	85 29		sta $29				sta 	zTemp1+3 					; return with address set.
.e3b3	60		rts				rts
.e3b4					_VARArrayAccess:
.e3b4	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e3b6	c8		iny				iny
.e3b7	29 1f		and #$1f			and 	#31 						; mask it off
.e3b9	48		pha				pha 								; save on the stack.
.e3ba	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e3bd	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e3c0	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3c3	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3c6	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3c9	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e3cc	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3cf	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3d2	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3d5	68		pla				pla 								; put address in zTemp1
.e3d6	0a		asl a				asl 	a 							; x 4
.e3d7	0a		asl a				asl 	a
.e3d8	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e3da	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e3dc	85 27		sta $27				sta 	zTemp1+1
.e3de	5a		phy				phy
.e3df	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e3e1	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3e3	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e3e6	48		pha				pha 								; save first result as we need the indirection.
.e3e7	c8		iny				iny 								; 2nd byte
.e3e8	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3ea	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e3ed	85 27		sta $27				sta 	zTemp1+1
.e3ef	68		pla				pla 								; save the low byte.
.e3f0	85 26		sta $26				sta 	zTemp1+0
.e3f2	a9 00		lda #$00			lda 	#0
.e3f4	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e3f7	85 28		sta $28				sta 	zTemp1+2
.e3f9	a9 00		lda #$00			lda 	#0
.e3fb	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e3fe	85 29		sta $29				sta 	zTemp1+3
.e400	7a		ply				ply 								; restore Y, address setup
.e401	60		rts				rts
.e402	80 fe		bra $e402	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e404					SIOInitialise:
.e404	20 b8 b0	jsr $b0b8			jsr 	EXTReset 					; reset video
.e407					SIOClearScreen:
.e407	20 68 b0	jsr $b068			jsr 	EXTClearScreen 				; clear screen
.e40a					SIOHomeCursor:
.e40a	48		pha				pha 								; home cursor
.e40b	a9 00		lda #$00			lda 	#0
.e40d	8d 9f 20	sta $209f			sta 	xCursor
.e410	8d a0 20	sta $20a0			sta 	yCursor
.e413	68		pla				pla
.e414	60		rts				rts
.e415					SIOPrintString:
.e415	48		pha				pha 								; save registers
.e416	da		phx				phx
.e417	5a		phy				phy
.e418	86 26		stx $26				stx 	zTemp1 						; set up indirect pointer
.e41a	84 27		sty $27				sty 	zTemp1+1
.e41c	a0 00		ldy #$00			ldy 	#0
.e41e					_SIOPSLoop:
.e41e	b1 26		lda ($26),y			lda 	(zTemp1),y 					; read next, exit if 0
.e420	f0 06		beq $e428			beq 	_SIOPSExit
.e422	20 2c e4	jsr $e42c			jsr 	SIOPrintCharacter 			; print and bump
.e425	c8		iny				iny
.e426	80 f6		bra $e41e			bra 	_SIOPSLoop
.e428					_SIOPSExit:
.e428	7a		ply				ply 								; restore and exit.
.e429	fa		plx				plx
.e42a	68		pla				pla
.e42b	60		rts				rts
.e42c					SIOPrintCharacter:
.e42c	48		pha				pha 								; save AXY
.e42d	da		phx				phx
.e42e	5a		phy				phy
.e42f	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e431	f0 12		beq $e445			beq 	_SIOPReturn
.e433	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor 				; load cursor position in.
.e436	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e438	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen 				; write character out.
.e43b	ee 9f 20	inc $209f			inc 	xCursor 					; move right
.e43e	ad 9f 20	lda $209f			lda 	xCursor 					; reached the RHS
.e441	c9 28		cmp #$28			cmp 	#EXTWidth
.e443	90 15		bcc $e45a			bcc 	_SIOPExit
.e445					_SIOPReturn:
.e445	a9 00		lda #$00			lda 	#0 							; zero x
.e447	8d 9f 20	sta $209f			sta 	xCursor
.e44a	ee a0 20	inc $20a0			inc 	yCursor 					; go down
.e44d	ad a0 20	lda $20a0			lda 	yCursor
.e450	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e452	90 06		bcc $e45a			bcc 	_SIOPExit
.e454	20 86 b0	jsr $b086			jsr 	EXTScrollDisplay 			; scroll display up
.e457	ce a0 20	dec $20a0			dec 	yCursor 					; cursor on bottom line.
.e45a					_SIOPExit:
.e45a	7a		ply				ply 								; restore and exit.
.e45b	fa		plx				plx
.e45c	68		pla				pla
.e45d	60		rts				rts
.e45e					SIOGetKey:
.e45e	20 0c b0	jsr $b00c			jsr 	EXTReadKeyPort 				; wait for a key
.e461	f0 fb		beq $e45e			beq 	SIOGetKey
.e463	20 24 e3	jsr $e324			jsr 	EVALToUpper 				; capitalise it.
.e466	4c 17 b0	jmp $b017			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e469					SIOReadLine:
.e469	48		pha				pha 								; save registers
.e46a	da		phx				phx
.e46b	5a		phy				phy
.e46c					_SIORLoop:
.e46c	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor 				; cursor in XY
.e46f	20 4d b0	jsr $b04d			jsr 	EXTReadScreen 				; read the display.
.e472	48		pha				pha 								; save on stack.
.e473	a9 66		lda #$66			lda 	#102 						; write cursor out
.e475	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e478	20 5e e4	jsr $e45e			jsr 	SIOGetKey
.e47b	aa		tax				tax 								; save in X
.e47c	68		pla				pla 								; old character
.e47d	da		phx				phx 								; save key pressed
.e47e	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor 				; cursor in XY
.e481	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e484	68		pla				pla
.e485	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e487	f0 29		beq $e4b2			beq 	_SIOCursorLeft
.e489	c9 13		cmp #$13			cmp 	#"S"-64
.e48b	f0 49		beq $e4d6			beq 	_SIOCursorDown
.e48d	c9 04		cmp #$04			cmp 	#"D"-64
.e48f	f0 2d		beq $e4be			beq 	_SIOCursorRight
.e491	c9 17		cmp #$17			cmp 	#"W"-64
.e493	f0 35		beq $e4ca			beq 	_SIOCursorUp
.e495	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e497	f0 49		beq $e4e2			beq 	_SIOClearScreen
.e499	c9 08		cmp #$08			cmp 	#"H"-64
.e49b	f0 4a		beq $e4e7			beq 	_SIOBackspace
.e49d	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e49f	f0 0e		beq $e4af			beq 	_SIOGoReturn
.e4a1	c9 20		cmp #$20			cmp 	#32 						; any control
.e4a3	90 c7		bcc $e46c			bcc 	_SIORLoop
.e4a5	48		pha				pha
.e4a6	20 27 e5	jsr $e527			jsr 	_SIOInsert 					; insert a space for new character
.e4a9	68		pla				pla
.e4aa	20 2c e4	jsr $e42c			jsr 	SIOPrintCharacter 			; print character in A
.e4ad	80 bd		bra $e46c			bra 	_SIORLoop
.e4af					_SIOGoReturn:
.e4af	4c 52 e5	jmp $e552			jmp 	_SIOReturn
.e4b2					_SIOCursorLeft:
.e4b2	ce 9f 20	dec $209f			dec 	xCursor
.e4b5	10 b5		bpl $e46c			bpl 	_SIORLoop
.e4b7	a9 27		lda #$27			lda 	#EXTWidth-1
.e4b9					_SIOWXLoop:
.e4b9	8d 9f 20	sta $209f			sta 	xCursor
.e4bc	80 ae		bra $e46c			bra 	_SIORLoop
.e4be					_SIOCursorRight:
.e4be	ee 9f 20	inc $209f			inc 	xCursor
.e4c1	ad 9f 20	lda $209f			lda 	xCursor
.e4c4	49 28		eor #$28			eor 	#EXTWidth
.e4c6	d0 a4		bne $e46c			bne 	_SIORLoop
.e4c8	80 ef		bra $e4b9			bra 	_SIOWXLoop
.e4ca					_SIOCursorUp:
.e4ca	ce a0 20	dec $20a0			dec 	yCursor
.e4cd	10 9d		bpl $e46c			bpl 	_SIORLoop
.e4cf	a9 18		lda #$18			lda 	#EXTHeight-1
.e4d1					_SIOWYLoop:
.e4d1	8d a0 20	sta $20a0			sta 	yCursor
.e4d4	80 96		bra $e46c			bra 	_SIORLoop
.e4d6					_SIOCursorDown:
.e4d6	ee a0 20	inc $20a0			inc 	yCursor
.e4d9	ad a0 20	lda $20a0			lda 	yCursor
.e4dc	49 19		eor #$19			eor 	#EXTHeight
.e4de	d0 8c		bne $e46c			bne 	_SIORLoop
.e4e0	80 ef		bra $e4d1			bra 	_SIOWYLoop
.e4e2					_SIOClearScreen:
.e4e2	20 07 e4	jsr $e407			jsr 	SIOClearScreen
.e4e5	80 85		bra $e46c			bra 	_SIORLoop
.e4e7					_SIOBackspace:
.e4e7	ad 9f 20	lda $209f			lda 	xCursor 					; backspace possible ?
.e4ea	f0 80		beq $e46c			beq 	_SIORLoop 					; start of line, no.
.e4ec	48		pha				pha 								; save position.
.e4ed	c9 27		cmp #$27			cmp 	#EXTWidth-1 				; not required
.e4ef	f0 1c		beq $e50d			beq 	_SIONoShift
.e4f1					_SIOShift2:
.e4f1	ee 9f 20	inc $209f			inc 	xCursor 					; copy character backward
.e4f4	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e4f7	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e4fa	ce 9f 20	dec $209f			dec 	xCursor
.e4fd	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e500	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e503	ee 9f 20	inc $209f			inc 	xCursor
.e506	ad 9f 20	lda $209f			lda 	xCursor
.e509	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e50b	d0 e4		bne $e4f1			bne 	_SIOShift2
.e50d					_SIONoShift:
.e50d	a9 27		lda #$27			lda 	#EXTWidth-1 				; space on far end.
.e50f	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e512	a9 20		lda #$20			lda 	#32
.e514	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e517	68		pla				pla 								; restore cursor, back one.
.e518	3a		dec a				dec 	a
.e519	8d 9f 20	sta $209f			sta 	xCursor
.e51c	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor 				; overwrite
.e51f	a9 20		lda #$20			lda 	#32
.e521	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e524	4c 6c e4	jmp $e46c			jmp	 	_SIORLoop
.e527					_SIOInsert:
.e527	ad 9f 20	lda $209f			lda 	xCursor 					; at far right, nothing to do.
.e52a	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e52c	f0 23		beq $e551			beq 	_SIOIExit
.e52e	85 28		sta $28				sta 	zTemp2 						; save in temporary workspace.
.e530	a9 27		lda #$27			lda 	#EXTWidth-1 				; cursor at far right.
.e532	8d 9f 20	sta $209f			sta 	xCursor
.e535					_SIOShift:
.e535	ce 9f 20	dec $209f			dec 	xCursor 					; copy character forward
.e538	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e53b	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e53e	ee 9f 20	inc $209f			inc 	xCursor
.e541	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e544	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e547	ce 9f 20	dec $209f			dec 	xCursor
.e54a	ad 9f 20	lda $209f			lda 	xCursor						; until shifted line to this point.
.e54d	c5 28		cmp $28				cmp 	zTemp2
.e54f	d0 e4		bne $e535			bne 	_SIOShift
.e551					_SIOIExit:
.e551	60		rts				rts
.e552					_SIOReturn:
.e552	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e554	8d 9f 20	sta $209f			sta 	xCursor
.e557					_SIOCopy:
.e557	20 8c e5	jsr $e58c			jsr 	SIOLoadCursor
.e55a	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e55d	49 20		eor #$20			eor 	#$20
.e55f	18		clc				clc
.e560	69 20		adc #$20			adc 	#$20
.e562	ae 9f 20	ldx $209f			ldx 	xCursor
.e565	9d 6c 20	sta $206c,x			sta 	InputLine,x
.e568	ee 9f 20	inc $209f			inc 	xCursor
.e56b	ad 9f 20	lda $209f			lda 	xCursor
.e56e	c9 28		cmp #$28			cmp 	#EXTWidth
.e570	d0 e5		bne $e557			bne 	_SIOCopy
.e572	aa		tax				tax 								; X contains width
.e573					_SIOStrip:
.e573	ca		dex				dex									; back one
.e574	30 07		bmi $e57d			bmi		_SIOFound 					; if -ve gone too far
.e576	bd 6c 20	lda $206c,x			lda 	InputLine,x 				; is there a space here
.e579	c9 20		cmp #$20			cmp 	#' '
.e57b	f0 f6		beq $e573			beq 	_SIOStrip
.e57d					_SIOFound:
.e57d	e8		inx				inx
.e57e	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e580	9d 6c 20	sta $206c,x			sta 	InputLine,x
.e583	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e585	20 2c e4	jsr $e42c			jsr 	SIOPrintCharacter
.e588	7a		ply				ply
.e589	fa		plx				plx
.e58a	68		pla				pla
.e58b	60		rts				rts
.e58c					SIOLoadCursor:
.e58c	48		pha				pha
.e58d	ad a0 20	lda $20a0			lda 	yCursor  					; Y Position
.e590	0a		asl a				asl 	a 							; x 2 	(80)
.e591	0a		asl a				asl 	a 							; x 2 	(160)
.e592	6d a0 20	adc $20a0			adc 	yCursor 					; x 5 	(200) (CC)
.e595	85 26		sta $26				sta 	zTemp1
.e597	a9 00		lda #$00			lda 	#0
.e599	85 27		sta $27				sta 	zTemp1+1
.e59b	06 26		asl $26				asl 	zTemp1						; x 10
.e59d	26 27		rol $27				rol 	zTemp1+1
.e59f	06 26		asl $26				asl 	zTemp1						; x 20
.e5a1	26 27		rol $27				rol 	zTemp1+1
.e5a3	06 26		asl $26				asl 	zTemp1						; x 40
.e5a5	26 27		rol $27				rol 	zTemp1+1 					; (CC)
.e5a7	a5 26		lda $26				lda 	zTemp1 						; add X
.e5a9	6d 9f 20	adc $209f			adc 	xCursor
.e5ac	aa		tax				tax
.e5ad	a5 27		lda $27				lda 	zTemp1+1
.e5af	69 00		adc #$00			adc 	#0
.e5b1	a8		tay				tay
.e5b2	68		pla				pla 								; restore and exit
.e5b3	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e5b4					BFUNC_Add:
.e5b4	18		clc				clc
.e5b5	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e5b8	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e5bb	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e5be	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e5c1	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e5c4	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e5c7	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e5ca	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e5cd	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e5d0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e5d3	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e5d6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e5d9	60		rts				rts
.e5da					BFUNC_Subtract:
.e5da	38		sec				sec
.e5db	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e5de	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e5e1	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e5e4	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e5e7	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e5ea	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e5ed	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e5f0	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e5f3	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e5f6	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e5f9	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e5fc	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e5ff	60		rts				rts
.e600					BFUNC_String:
.e600	20 b4 e5	jsr $e5b4			jsr 	BFUNC_Add
.e603	60		rts				rts
.e604					BFUNC_ByteInd:
.e604	20 b4 e5	jsr $e5b4			jsr 	BFUNC_Add
.e607	20 2f e3	jsr $e32f			jsr 	EVALReadByteIndirect
.e60a	60		rts				rts
.e60b					BFUNC_WordInd:
.e60b	20 b4 e5	jsr $e5b4			jsr 	BFUNC_Add
.e60e	20 58 e3	jsr $e358			jsr 	EVALReadWordIndirect
.e611	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e612					BFUNC_And:
.e612	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e615	3d 04 04	and $0404,x			and 	evalStack+4,x
.e618	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e61b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e61e	3d 05 04	and $0405,x			and 	evalStack+5,x
.e621	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e624	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e627	3d 06 04	and $0406,x			and 	evalStack+6,x
.e62a	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e62d	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e630	3d 07 04	and $0407,x			and 	evalStack+7,x
.e633	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e636	60		rts				rts
.e637					BFUNC_Or:
.e637	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e63a	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e63d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e640	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e643	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e646	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e649	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e64c	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e64f	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e652	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e655	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e658	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e65b	60		rts				rts
.e65c					BFUNC_Xor:
.e65c	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e65f	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e662	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e665	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e668	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e66b	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e66e	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e671	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e674	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e677	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e67a	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e67d	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e680	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e681					BFUNC_Multiply:
.e681	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e684	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e687	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e68a	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e68d	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e690	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e693	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e696	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e699	a9 00		lda #$00			lda 	#0
.e69b	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e69e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e6a1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e6a4	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e6a7					_BFMMultiply:
.e6a7	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e6aa	29 01		and #$01			and 	#1
.e6ac	f0 03		beq $e6b1			beq 	_BFMNoAdd
.e6ae	20 b4 e5	jsr $e5b4			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e6b1					_BFMNoAdd:
.e6b1	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e6b4	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e6b7	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e6ba	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e6bd	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e6c0	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e6c3	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e6c6	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e6c9	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e6cc	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e6cf	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e6d2	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e6d5	d0 d0		bne $e6a7			bne 	_BFMMultiply
.e6d7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e6d8					BFUNC_Divide:
.e6d8	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e6db	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e6de	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e6e1	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e6e4	d0 13		bne $e6f9			bne 	_BFDOkay
.e6e6	20 69 eb	jsr $eb69			jsr 	ReportError
>e6e9	44 69 76 69 73 6f 6e 20				.text 	"Divison by Zero",$00
>e6f1	62 79 20 5a 65 72 6f 00
.e6f9					_BFDOkay:
.e6f9	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e6fb	8d 97 20	sta $2097			sta 	Temp1 						; Q/Dividend/Left in +0
.e6fe	8d 98 20	sta $2098			sta 	Temp1+1 					; M/Divisor/Right in +4
.e701	8d 99 20	sta $2099			sta 	Temp1+2
.e704	8d 9a 20	sta $209a			sta 	Temp1+3
.e707	8d 9b 20	sta $209b			sta 	SignCount 					; Count of signs.
.e70a	20 75 e7	jsr $e775			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e70d	da		phx				phx
.e70e	e8		inx				inx
.e70f	e8		inx				inx
.e710	e8		inx				inx
.e711	e8		inx				inx
.e712	20 75 e7	jsr $e775			jsr 	BFUNC_Negate
.e715	fa		plx				plx
.e716	5a		phy				phy 								; Y is the counter
.e717	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e719					_BFDLoop:
.e719	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e71c	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e71f	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e722	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e725	2e 97 20	rol $2097			rol 	Temp1
.e728	2e 98 20	rol $2098			rol 	Temp1+1
.e72b	2e 99 20	rol $2099			rol 	Temp1+2
.e72e	2e 9a 20	rol $209a			rol 	Temp1+3
.e731	38		sec				sec
.e732	ad 97 20	lda $2097			lda 	Temp1+0 					; Calculate A-M on stack.
.e735	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e738	48		pha				pha
.e739	ad 98 20	lda $2098			lda 	Temp1+1
.e73c	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e73f	48		pha				pha
.e740	ad 99 20	lda $2099			lda 	Temp1+2
.e743	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e746	48		pha				pha
.e747	ad 9a 20	lda $209a			lda 	Temp1+3
.e74a	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e74d	90 19		bcc $e768			bcc 	_BFDNoAdd
.e74f	8d 9a 20	sta $209a			sta 	Temp1+3 					; update A
.e752	68		pla				pla
.e753	8d 99 20	sta $2099			sta 	Temp1+2
.e756	68		pla				pla
.e757	8d 98 20	sta $2098			sta 	Temp1+1
.e75a	68		pla				pla
.e75b	8d 97 20	sta $2097			sta 	Temp1+0
.e75e	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.e761	09 01		ora #$01			ora 	#1
.e763	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e766	80 03		bra $e76b			bra 	_BFDNext
.e768					_BFDNoAdd:
.e768	68		pla				pla 								; Throw away the intermediate calculations
.e769	68		pla				pla
.e76a	68		pla				pla
.e76b					_BFDNext:
.e76b	88		dey				dey
.e76c	d0 ab		bne $e719			bne 	_BFDLoop
.e76e	7a		ply				ply 								; restore Y and exit
.e76f	4e 9b 20	lsr $209b			lsr 	SignCount 					; if sign count odd,
.e772	b0 06		bcs $e77a			bcs		BFUNC_NegateAlways 			; negate the result
.e774	60		rts				rts
.e775					BFUNC_Negate:
.e775	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e778	10 24		bpl $e79e			bpl 	BFNExit
.e77a					BFUNC_NegateAlways:
.e77a	38		sec				sec
.e77b	a9 00		lda #$00			lda 	#0
.e77d	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.e780	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e783	a9 00		lda #$00			lda 	#0
.e785	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.e788	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e78b	a9 00		lda #$00			lda 	#0
.e78d	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.e790	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e793	a9 00		lda #$00			lda 	#0
.e795	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.e798	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e79b	ee 9b 20	inc $209b			inc 	SignCount
.e79e					BFNExit:
.e79e	60		rts				rts
.e79f					BFUNC_Modulus:
.e79f	20 d8 e6	jsr $e6d8			jsr 	BFUNC_Divide 				; start with division.
.e7a2	ad 97 20	lda $2097			lda 	Temp1+0 					; copy remainder
.e7a5	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e7a8	ad 98 20	lda $2098			lda 	Temp1+1
.e7ab	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e7ae	ad 99 20	lda $2099			lda 	Temp1+2
.e7b1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e7b4	ad 9a 20	lda $209a			lda 	Temp1+3
.e7b7	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e7ba	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e7bb					BFUNC_Equals:
.e7bb	18		clc				clc
.e7bc	80 01		bra $e7bf			bra 	BFUNC_EqualCheck
.e7be					BFUNC_NotEquals:
.e7be	38		sec				sec
.e7bf					BFUNC_EqualCheck:
.e7bf	08		php				php									; save invert flag
.e7c0	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e7c3	cd 04 04	cmp $0404			cmp 	evalStack+4
.e7c6	d0 1c		bne $e7e4			bne 	COMP_Fail
.e7c8	ad 01 04	lda $0401			lda 	evalStack+1
.e7cb	cd 05 04	cmp $0405			cmp 	evalStack+5
.e7ce	d0 14		bne $e7e4			bne 	COMP_Fail
.e7d0	ad 02 04	lda $0402			lda 	evalStack+2
.e7d3	cd 06 04	cmp $0406			cmp 	evalStack+6
.e7d6	d0 0c		bne $e7e4			bne 	COMP_Fail
.e7d8	ad 03 04	lda $0403			lda 	evalStack+3
.e7db	cd 07 04	cmp $0407			cmp 	evalStack+7
.e7de	d0 04		bne $e7e4			bne 	COMP_Fail
.e7e0					COMP_Succeed:
.e7e0	a9 ff		lda #$ff			lda 	#$FF
.e7e2	80 02		bra $e7e6			bra 	COMP_SetResult
.e7e4					COMP_Fail:
.e7e4	a9 00		lda #$00			lda 	#0 							; here return 0
.e7e6					COMP_SetResult:
.e7e6	28		plp				plp 								; but if CS
.e7e7	90 02		bcc $e7eb			bcc 	COMP_Accept
.e7e9	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e7eb					COMP_Accept:
.e7eb	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e7ee	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e7f1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e7f4	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e7f7	60		rts				rts
.e7f8					BFUNC_Less:
.e7f8	18		clc				clc
.e7f9	80 01		bra $e7fc			bra 	BFUNC_LessCheck
.e7fb					BFUNC_GreaterEqual:
.e7fb	38		sec				sec
.e7fc					BFUNC_LessCheck:
.e7fc	08		php				php
.e7fd	38		sec				sec
.e7fe	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e801	ed 04 04	sbc $0404			sbc 	evalStack+4
.e804	ad 01 04	lda $0401			lda 	evalStack+1
.e807	ed 05 04	sbc $0405			sbc 	evalStack+5
.e80a	ad 02 04	lda $0402			lda 	evalStack+2
.e80d	ed 06 04	sbc $0406			sbc 	evalStack+6
.e810	ad 03 04	lda $0403			lda 	evalStack+3
.e813	ed 07 04	sbc $0407			sbc 	evalStack+7
.e816	30 c8		bmi $e7e0			bmi 	COMP_Succeed
.e818	80 ca		bra $e7e4			bra 	COMP_Fail
.e81a					BFUNC_Greater:
.e81a	18		clc				clc
.e81b	80 01		bra $e81e			bra 	BFUNC_GreaterCheck
.e81d					BFUNC_LessEqual:
.e81d	38		sec				sec
.e81e					BFUNC_GreaterCheck:
.e81e	08		php				php
.e81f	38		sec				sec
.e820	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.e823	ed 00 04	sbc $0400			sbc 	evalStack+0
.e826	ad 05 04	lda $0405			lda 	evalStack+5
.e829	ed 01 04	sbc $0401			sbc 	evalStack+1
.e82c	ad 06 04	lda $0406			lda 	evalStack+6
.e82f	ed 02 04	sbc $0402			sbc 	evalStack+2
.e832	ad 07 04	lda $0407			lda 	evalStack+7
.e835	ed 03 04	sbc $0403			sbc 	evalStack+3
.e838	30 a6		bmi $e7e0			bmi 	COMP_Succeed
.e83a	80 a8		bra $e7e4			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.e83c					BFUNC_StringCompare:
.e83c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.e83f	85 26		sta $26				sta 	zTemp1
.e841	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e844	85 27		sta $27				sta 	zTemp1+1
.e846	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.e849	85 28		sta $28				sta 	zTemp2
.e84b	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.e84e	85 29		sta $29				sta 	zTemp2+1
.e850	5a		phy				phy
.e851	a0 00		ldy #$00			ldy 	#0
.e853					_BFSCLoop:
.e853	b1 26		lda ($26),y			lda 	(zTemp1),y 					; comparison
.e855	38		sec				sec
.e856	d1 28		cmp ($28),y			cmp 	(zTemp2),y
.e858	d0 15		bne $e86f			bne		_BFSCDifferent 				; return different result.
.e85a	c8		iny				iny
.e85b	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.e85d	d0 f4		bne $e853			bne 	_BFSCLoop
.e85f	7a		ply				ply
.e860	a9 00		lda #$00			lda 	#0
.e862					_BFSCSetAll:
.e862	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e865	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e868	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e86b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e86e	60		rts				rts
.e86f					_BFSCDifferent:
.e86f	7a		ply				ply
.e870	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.e872	90 ee		bcc $e862			bcc 	_BFSCSetAll
.e874	a9 00		lda #$00			lda 	#0 							; set all zero
.e876	20 62 e8	jsr $e862			jsr 	_BFSCSetAll
.e879	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.e87c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.e87d					UNARY_Len:
.e87d	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e880	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.e883	85 26		sta $26				sta 	zTemp1
.e885	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e888	85 27		sta $27				sta 	zTemp1+1
.e88a	5a		phy				phy
.e88b	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.e88d					_ULGetLength:
.e88d	b1 26		lda ($26),y			lda 	(zTemp1),y 					; read character
.e88f	f0 1d		beq $e8ae			beq 	_ULFoundEOL 				; found end of line.
.e891	c8		iny				iny
.e892	d0 f9		bne $e88d			bne 	_ULGetLength 				; scan 256 only.
.e894	20 69 eb	jsr $eb69			jsr 	ReportError
>e897	43 61 6e 6e 6f 74 20 66				.text 	"Cannot find string end",$00
>e89f	69 6e 64 20 73 74 72 69 6e 67 20 65 6e 64 00
.e8ae					_ULFoundEOL:
.e8ae	98		tya				tya 								; length in A, restore Y
.e8af	7a		ply				ply
.e8b0					UNARY_ReturnByte:
.e8b0	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8b3	a9 00		lda #$00			lda 	#0 							; clear the rests
.e8b5	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8b8	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8bb	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8be	60		rts				rts
.e8bf					UNARY_Ch:
.e8bf	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e8c2	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.e8c5	85 26		sta $26				sta 	zTemp1
.e8c7	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8ca	85 27		sta $27				sta 	zTemp1+1
.e8cc	5a		phy				phy
.e8cd	a0 00		ldy #$00			ldy 	#0 							; now get first character
.e8cf	b1 26		lda ($26),y			lda 	(zTemp1),y
.e8d1	7a		ply				ply
.e8d2	80 dc		bra $e8b0			bra 	UNARY_ReturnByte 			; return that byte.
.e8d4					UNARY_Abs:
.e8d4	ea		nop				nop
.e8d5	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e8d8	20 75 e7	jsr $e775			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.e8db	60		rts				rts
.e8dc					UNARY_Top:
.e8dc	ad 95 20	lda $2095			lda 	highMemory
.e8df	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8e2	ad 96 20	lda $2096			lda 	highMemory+1
.e8e5	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8e8	a9 00		lda #$00			lda 	#0
.e8ea	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8ed	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8f0	60		rts				rts
.e8f1					UNARY_Rnd:
.e8f1	20 fc e8	jsr $e8fc			jsr 	Random16 					; call 16 bit RNG twice
.e8f4	e8		inx				inx
.e8f5	e8		inx				inx
.e8f6	20 fc e8	jsr $e8fc			jsr 	Random16
.e8f9	ca		dex				dex
.e8fa	ca		dex				dex
.e8fb	60		rts				rts
.e8fc					Random16:
.e8fc	ad 9d 20	lda $209d			lda 	RandomSeed 					; initialise if nonzero
.e8ff	0d 9e 20	ora $209e			ora 	RandomSeed+1
.e902	d0 0d		bne $e911			bne 	_R16_NoInit
.e904	ee 9d 20	inc $209d			inc 	RandomSeed 					; by setting low to 1
.e907	5a		phy				phy
.e908	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.e90a					_R16_Setup:
.e90a	20 fc e8	jsr $e8fc			jsr 	Random16
.e90d	88		dey				dey
.e90e	d0 fa		bne $e90a			bne 	_R16_Setup
.e910	7a		ply				ply
.e911					_R16_NoInit:
.e911	4e 9e 20	lsr $209e			lsr 	RandomSeed+1				; shift seed right
.e914	6e 9d 20	ror $209d			ror 	RandomSeed
.e917	90 08		bcc $e921			bcc 	_R16_NoXor
.e919	ad 9e 20	lda $209e			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.e91c	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.e91e	8d 9e 20	sta $209e			sta 	RandomSeed+1
.e921					_R16_NoXor:
.e921	ad 9d 20	lda $209d			lda 	RandomSeed					; copy result to evaluate stack.
.e924	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e927	ad 9e 20	lda $209e			lda 	RandomSeed+1
.e92a	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e92d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.e92e					COMMAND_Run:
.e92e	20 db e9	jsr $e9db			jsr 	COMMAND_Clear 				; clear everything for a new run.
.e931	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.e933	a0 22		ldy #$22			ldy 	#BasicProgram >> 8
.e935	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.e937	84 21		sty $21				sty 	zCurrentLine+1
.e939					CRUNNewLine:
.e939	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.e93b	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e93d	f0 57		beq $e996			beq 	COMMAND_End 				; if zero, off end of program so stop.
.e93f	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.e941					CRUNNextInstruction:
.e941	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.e943	8d 9c 20	sta $209c			sta 	StringBufferPos
.e946	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.e948	f0 0b		beq $e955			beq 	CRUNNextLine 				; if zero, then end of line.
.e94a					CRUNNotEndOfLine:
.e94a	c9 20		cmp #$20			cmp 	#' '
.e94c	f0 04		beq $e952			beq 	CRUNSkipLoop
.e94e	c9 8d		cmp #$8d			cmp 	#KW_Colon 					; check for a colon first.
.e950	d0 12		bne $e964			bne 	CRUNExecuteOne 				; if not that, execute the token.
.e952					CRUNSkipLoop:
.e952	c8		iny				iny		 							; if colon, skip it and loop round.
.e953	80 ec		bra $e941			bra 	CRUNNextInstruction
.e955					CRUNNextLine:
.e955	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.e957	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e959	18		clc				clc
.e95a	65 20		adc $20				adc 	zCurrentLine
.e95c	85 20		sta $20				sta 	zCurrentLine
.e95e	90 d9		bcc $e939			bcc 	CRUNNewLine
.e960	e6 21		inc $21				inc 	zCurrentLine+1
.e962	80 d5		bra $e939			bra 	CRUNNewLine
.e964					CRUNExecuteOne:
.e964	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.e966	10 21		bpl $e989			bpl		_CRUNX1TryLet
.e968	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.e96a	f0 1d		beq $e989			beq 	_CRUNX1TryLet
.e96c	c9 80		cmp #$80			cmp 	#KW_PLING
.e96e	f0 19		beq $e989			beq 	_CRUNX1TryLet
.e970	c9 95		cmp #$95			cmp 	#KW_QUESTION
.e972	f0 15		beq $e989			beq 	_CRUNX1TryLet
.e974	c8		iny				iny 								; skip over loaded token
.e975	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.e976	8d 98 20	sta $2098			sta 	Temp1+1 					; this is the low byte into the KVT
.e979	8a		txa				txa
.e97a	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e97c	8d 99 20	sta $2099			sta 	Temp1+2
.e97f	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.e981	8d 97 20	sta $2097			sta 	Temp1+0
.e984	20 97 20	jsr $2097			jsr 	Temp1 						; call instruction
.e987	80 b8		bra $e941			bra 	CRUNNextInstruction 		; do next instruction.
.e989					_CRUNX1TryLet:
.e989	20 45 ea	jsr $ea45			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.e98c	80 b3		bra $e941			bra 	CRUNNextInstruction
.e98e					COMMAND_Stop:
.e98e	20 69 eb	jsr $eb69			jsr 	ReportError
>e991	53 74 6f 70 00					.text 	"Stop",$00
.e996					COMMAND_End:
>e996	02						.byte 	2
.e997	4c 5e eb	jmp $eb5e			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.e99a					COMMAND_Assert:
.e99a	20 75 e1	jsr $e175			jsr 	EvaluateBase 				; evaluate the expression
.e99d	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.e9a0	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e9a3	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.e9a6	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e9a9	d0 12		bne $e9bd			bne 	_CMDAExit
.e9ab	ea		nop				nop
.e9ac	20 69 eb	jsr $eb69			jsr 	ReportError
>e9af	41 73 73 65 72 74 20 66				.text 	"Assert failed",$00
>e9b7	61 69 6c 65 64 00
.e9bd					_CMDAExit:
.e9bd	60		rts				rts
.e9be					COMMAND_Rem:
.e9be	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.e9c0	f0 05		beq $e9c7			beq 	_CREMExit 					; End of line, then exit.
.e9c2	c8		iny				iny 								; something to skip
.e9c3	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; if not a colon
.e9c5	d0 f7		bne $e9be			bne 	COMMAND_Rem 				; keep searching
.e9c7					_CREMExit:
.e9c7	60		rts				rts
.e9c8					COMMAND_New:
.e9c8	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.e9ca	8d 00 22	sta $2200			sta 	BasicProgram 				; by zeroing the initial offset.
.e9cd	20 db e9	jsr $e9db			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.e9d0	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.e9d2	8d 95 20	sta $2095			sta 	HighMemory
.e9d5	a9 80		lda #$80			lda 	#endMemory >> 8
.e9d7	8d 96 20	sta $2096			sta 	HighMemory+1
.e9da	60		rts				rts
.e9db					COMMAND_Clear:
.e9db	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.e9dd					_CCClearVar:
.e9dd	a9 00		lda #$00			lda 	#$00
.e9df	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.e9e2	e8		inx				inx
.e9e3	e0 6c		cpx #$6c			cpx 	#27*4
.e9e5	10 f6		bpl $e9dd			bpl 	_CCClearVar
.e9e7	a9 00		lda #$00			lda 	#basicStack & $FF 			; reset BASIC stack
.e9e9	85 22		sta $22				sta 	zBasicStack
.e9eb	a9 02		lda #$02			lda 	#basicStack >> 8
.e9ed	85 23		sta $23				sta 	zBasicStack+1
.e9ef	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.e9f1	85 24		sta $24				sta 	zLowMemory
.e9f3	a9 22		lda #$22			lda 	#BasicProgram >> 8
.e9f5	85 25		sta $25				sta 	zLowMemory+1
.e9f7					_CCFindEnd:
.e9f7	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.e9f9	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.e9fb	f0 0b		beq $ea08			beq 	_CCFoundEnd
.e9fd	18		clc				clc 								; go to next line.
.e9fe	65 24		adc $24				adc 	zLowMemory
.ea00	85 24		sta $24				sta 	zLowMemory
.ea02	90 f3		bcc $e9f7			bcc 	_CCFindEnd
.ea04	e6 25		inc $25				inc 	zLowMemory+1
.ea06	80 ef		bra $e9f7			bra 	_CCFindEnd
.ea08					_CCFoundEnd:
.ea08	e6 24		inc $24				inc 	zLowMemory 					; variables etc. start after end of program.
.ea0a	d0 02		bne $ea0e			bne 	_CCNoCarry 					; skip over zero end offset.
.ea0c	e6 25		inc $25				inc 	zLowMemory+1
.ea0e					_CCNoCarry:
.ea0e	60		rts				rts
.ea0f					COMMAND_Old:
.ea0f	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.ea11	85 24		sta $24				sta 	zLowMemory
.ea13	a9 22		lda #$22			lda 	#BasicProgram >> 8
.ea15	85 25		sta $25				sta 	zLowMemory+1
.ea17	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.ea19					_COScan:
.ea19	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; look at next byte pair
.ea1b	c8		iny				iny
.ea1c	f0 0d		beq $ea2b			beq 	_COFail 					; can't find marker, corrupted maybe ?
.ea1e	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.ea20	d0 f7		bne $ea19			bne 	_COScan
.ea22	98		tya				tya 								; Y is the new offset to the next instruction
.ea23	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.ea25	91 24		sta ($24),y			sta 	(zLowMemory),y
.ea27	20 db e9	jsr $e9db			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.ea2a	60		rts				rts
.ea2b					_COFail:
.ea2b	20 69 eb	jsr $eb69			jsr 	ReportError
>ea2e	43 61 6e 6e 6f 74 20 72				.text 	"Cannot recover program",$00
>ea36	65 63 6f 76 65 72 20 70 72 6f 67 72 61 6d 00

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ea45					COMMAND_Let:
.ea45	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ea47	f0 58		beq $eaa1			beq 	_CLESyntax
.ea49	c8		iny				iny
.ea4a	c9 20		cmp #$20			cmp 	#32
.ea4c	f0 f7		beq $ea45			beq 	COMMAND_Let
.ea4e	88		dey				dey
.ea4f	c9 95		cmp #$95			cmp 	#KW_QUESTION				; check for first being indirect.
.ea51	f0 51		beq $eaa4			beq 	_CLEIndirect 				; e.g. !x = 42
.ea53	c9 80		cmp #$80			cmp 	#KW_PLING
.ea55	f0 4d		beq $eaa4			beq 	_CLEIndirect
.ea57	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ea59	f0 49		beq $eaa4			beq 	_CLEIndirect
.ea5b	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ea5d	20 88 e3	jsr $e388			jsr 	VARReference 				; get a variable reference.
.ea60	a5 26		lda $26				lda 	zTemp1 						; copy into target addr
.ea62	85 2a		sta $2a				sta 	zTargetAddr
.ea64	a5 27		lda $27				lda 	zTemp1+1
.ea66	85 2b		sta $2b				sta 	zTargetAddr+1
.ea68	a5 28		lda $28				lda 	zTemp1+2
.ea6a	85 2c		sta $2c				sta 	zTargetAddr+2
.ea6c	a5 29		lda $29				lda 	zTemp1+3
.ea6e	85 2d		sta $2d				sta 	zTargetAddr+3
.ea70					_CLEGetBinLHSOp:
.ea70	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ea72	f0 2d		beq $eaa1			beq 	_CLESyntax
.ea74	c8		iny				iny
.ea75	c9 20		cmp #$20			cmp 	#' '
.ea77	f0 f7		beq $ea70			beq 	_CLEGetBinLHSOp
.ea79	88		dey				dey
.ea7a	c9 95		cmp #$95			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ea7c	f0 45		beq $eac3			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ea7e	c9 80		cmp #$80			cmp 	#KW_PLING
.ea80	f0 41		beq $eac3			beq 	_CLEBinaryLHTerm
.ea82	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ea84	f0 3d		beq $eac3			beq 	_CLEBinaryLHTerm
.ea86	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ea88					_CLEWriteToAddress:
.ea88	48		pha				pha 								; save write-type.
.ea89	a9 92		lda #$92			lda 	#KW_EQUAL 					; check for '=' sign.
.ea8b	20 19 e1	jsr $e119			jsr 	CheckNextCharacter
.ea8e	20 75 e1	jsr $e175			jsr 	EvaluateBase 				; evaluate the RHS.
.ea91	68		pla				pla
.ea92	c9 80		cmp #$80			cmp 	#KW_PLING
.ea94	f0 6e		beq $eb04			beq 	_CLEWordWrite
.ea96	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ea98	f0 60		beq $eafa			beq 	_CLEByteWrite
.ea9a	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ea9c					_ErrorInternal:
.ea9c	d0 fe		bne $ea9c			bne 	_ErrorInternal
.ea9e	4c 20 eb	jmp $eb20			jmp 	_CLEStringWrite
.eaa1					_CLESyntax:
.eaa1	4c 64 eb	jmp $eb64			jmp 	SyntaxError
.eaa4					_CLEIndirect:
.eaa4	48		pha				pha 								; save operator on stack
.eaa5	c8		iny				iny									; advance over cursor
.eaa6	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.eaa8	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel
.eaab	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.eaae	85 2a		sta $2a				sta 	zTargetAddr+0
.eab0	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eab3	85 2b		sta $2b				sta 	zTargetAddr+1
.eab5	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eab8	85 2c		sta $2c				sta 	zTargetAddr+2
.eaba	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eabd	85 2d		sta $2d				sta 	zTargetAddr+3
.eabf	68		pla				pla 								; restore operator.
.eac0	4c 88 ea	jmp $ea88			jmp 	_CLEWriteToAddress
.eac3					_CLEBinaryLHTerm:
.eac3	48		pha				pha 								; save operator on stack
.eac4	c8		iny				iny 								; skip over it.
.eac5	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.eac7	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel
.eaca	a5 2a		lda $2a				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.eacc	85 26		sta $26				sta 	zTemp1 						; a four byte address.....
.eace	a5 2b		lda $2b				lda 	zTargetAddr+1
.ead0	85 27		sta $27				sta 	zTemp1+1 					; we only worry about 4 byte value
.ead2	5a		phy				phy 								; save Y
.ead3	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.ead4	a0 00		ldy #$00			ldy 	#0
.ead6	b1 26		lda ($26),y			lda 	(zTemp1),y
.ead8	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.eadb	85 2a		sta $2a				sta 	zTargetAddr+0
.eadd	c8		iny				iny
.eade	b1 26		lda ($26),y			lda 	(zTemp1),y
.eae0	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.eae3	85 2b		sta $2b				sta 	zTargetAddr+1
.eae5	c8		iny				iny
.eae6	b1 26		lda ($26),y			lda 	(zTemp1),y
.eae8	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.eaeb	85 2c		sta $2c				sta 	zTargetAddr+2
.eaed	c8		iny				iny
.eaee	b1 26		lda ($26),y			lda 	(zTemp1),y
.eaf0	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.eaf3	85 2d		sta $2d				sta 	zTargetAddr+3
.eaf5	7a		ply				ply 								; restore Y
.eaf6	68		pla				pla 								; restore the operator.
.eaf7	4c 88 ea	jmp $ea88			jmp 	_CLEWriteToAddress
.eafa					_CLEByteWrite:
.eafa	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.eafd	5a		phy				phy 								; write the byte preserving Y
.eafe	a0 00		ldy #$00			ldy 	#0
.eb00	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb02	7a		ply				ply
.eb03	60		rts				rts
.eb04					_CLEWordWrite:
.eb04	5a		phy				phy
.eb05	a0 00		ldy #$00			ldy 	#0
.eb07	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.eb0a	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb0c	c8		iny				iny
.eb0d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb10	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb12	c8		iny				iny
.eb13	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eb16	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb18	c8		iny				iny
.eb19	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eb1c	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb1e	7a		ply				ply 								; restore Y
.eb1f	60		rts				rts
.eb20					_CLEStringWrite:
.eb20	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.eb23	85 26		sta $26				sta 	zTemp1
.eb25	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb28	85 27		sta $27				sta 	zTemp1+1
.eb2a	5a		phy				phy
.eb2b	a0 00		ldy #$00			ldy 	#0
.eb2d					_CLEStringCopy:
.eb2d	b1 26		lda ($26),y			lda 	(zTemp1),y
.eb2f	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eb31	c9 00		cmp #$00			cmp 	#0
.eb33	f0 16		beq $eb4b			beq	 	_CLEStringWritten
.eb35	c8		iny				iny
.eb36	d0 f5		bne $eb2d			bne 	_CLEStringCopy
.eb38	20 69 eb	jsr $eb69			jsr 	ReportError
>eb3b	42 61 64 20 73 74 72 69				.text 	"Bad string copy",$00
>eb43	6e 67 20 63 6f 70 79 00
.eb4b					_CLEStringWritten:
.eb4b	7a		ply				ply
.eb4c	60		rts				rts

;******  Return to file: basic.asm

.eb4d					Start:
.eb4d	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.eb4f	9a		txs			txs
.eb50	20 04 e4	jsr $e404			jsr 	SIOInitialise 				; initialise the I/O system.
.eb53					h1:
.eb53	20 69 e4	jsr $e469			jsr 	SIOReadLine
.eb56	80 fb		bra $eb53			bra 	h1
.eb58	20 c8 e9	jsr $e9c8			jsr 	COMMAND_New 				; do a new
.eb5b	20 0f ea	jsr $ea0f			jsr 	COMMAND_Old 				; get back the old program as we're deving.
.eb5e					WarmStart:
.eb5e	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.eb60	9a		txs			txs
.eb61	4c 2e e9	jmp $e92e			jmp 	COMMAND_Run 				; RUN current program.
.eb64					SyntaxError:
.eb64	a9 01		lda #$01			lda 	#1
.eb66	ea		nop				nop
.eb67	80 fb		bra $eb64			bra 	SyntaxError
.eb69					ReportError:
.eb69	a9 02		lda #$02			lda 	#2
.eb6b	ea		nop				nop
.eb6c	80 fb		bra $eb69			bra 	ReportError

;******  Processing file: include/basic_generated.inc

>2200	2c 01 00 43 20 92 20 34			.byte $2c,$01,$00,$43,$20,$92,$20,$34,$32,$8d,$44,$20,$92,$20,$8b,$32,$8d,$45,$20,$92,$20,$43,$20,$89,$20,$32,$8d,$40,$20,$92,$20,$8b,$31,$8d,$40,$20,$92,$20,$44,$20,$8b,$20,$31,$00,$20,$02,$00,$95,$82,$31,$46,$46,$46,$20,$92,$20,$36,$33,$8d,$80,$82,$31,$46,$46,$38,$92,$82,$41,$42,$37,$38,$34,$35,$30,$31,$00,$2e,$03,$00,$51,$92,$82,$31,$45,$30,$30,$8d,$20,$51,$51,$33,$92,$45,$8d,$80,$51,$92,$8b,$31,$8d,$51,$51,$32,$92,$8b,$32,$8d,$51,$87,$34,$88,$92,$82,$35,$41,$36,$41,$37,$41,$38,$41,$00,$1a,$04,$00,$51,$80,$32,$34,$92,$82,$31,$32,$33,$34,$35,$36,$37,$38,$8d,$51,$95,$32,$39,$92,$34,$32,$00,$1e,$05,$00,$41,$92,$82,$31,$44,$30,$30,$8d,$41,$41,$31,$92,$82,$31,$44,$38,$30,$8d,$41,$41,$31,$95,$33,$92,$34,$32,$00,$22,$06,$00,$83,$41,$92,$81,$48,$69,$81,$8d,$41,$83,$38,$92,$81,$77,$6f,$72,$6c,$64,$81,$8d,$40,$92,$9a,$87,$41,$83,$38,$88,$8d,$ad,$00,$05,$07,$00,$ad,$00,$00
>2208	32 8d 44 20 92 20 8b 32 8d 45 20 92 20 43 20 89
>2218	20 32 8d 40 20 92 20 8b 31 8d 40 20 92 20 44 20
>2228	8b 20 31 00 20 02 00 95 82 31 46 46 46 20 92 20
>2238	36 33 8d 80 82 31 46 46 38 92 82 41 42 37 38 34
>2248	35 30 31 00 2e 03 00 51 92 82 31 45 30 30 8d 20
>2258	51 51 33 92 45 8d 80 51 92 8b 31 8d 51 51 32 92
>2268	8b 32 8d 51 87 34 88 92 82 35 41 36 41 37 41 38
>2278	41 00 1a 04 00 51 80 32 34 92 82 31 32 33 34 35
>2288	36 37 38 8d 51 95 32 39 92 34 32 00 1e 05 00 41
>2298	92 82 31 44 30 30 8d 41 41 31 92 82 31 44 38 30
>22a8	8d 41 41 31 95 33 92 34 32 00 22 06 00 83 41 92
>22b8	81 48 69 81 8d 41 83 38 92 81 77 6f 72 6c 64 81
>22c8	8d 40 92 9a 87 41 83 38 88 8d ad 00 05 07 00 ad
>22d8	00 00

;******  Return to file: basic.asm


;******  End of listing
