
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D TARGET=2 -b -L rom.lst -o rom.bin basic.asm
; Sat Jul 27 16:48:46 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	86 e8						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_6502.asm

>0000	00					.byte 	0
=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$0800					EXTLowMemory = $0800 						; Workspace RAM starts here
=$6000					EXTHighMemory = $6000 						; Workspace RAM ends here
=$b000					PScreen = $B000								; 1k screen RAM here
=$b800					PKeyboard = $B800							; Keyboard port.
.a000					EXTStartPersonalise:
.a000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.a002	9a		txs			txs
.a003	20 7e a0	jsr $a07e		jsr 	EXTReset 						; reset video
.a006	20 34 a0	jsr $a034		jsr 	EXTClearScreen 					; clear screen
.a009	4c 86 e8	jmp $e886		jmp 	Start 							; start main application
.a00c					EXTReadKey:
.a00c	ad 00 b8	lda $b800		lda 	PKeyboard							; read key
.a00f	d0 01		bne $a012		bne 	EXTClearBuffer
.a011	60		rts			rts
.a012					EXTClearBuffer:
.a012	48		pha			pha 										; key pressed clear queue byte.
.a013	a9 00		lda #$00		lda 	#0
.a015	8d 00 b8	sta $b800		sta 	PKeyboard
.a018	68		pla			pla
.a019	60		rts			rts
.a01a					EXTReadScreen:
.a01a	5a		phy			phy 										; save Y
.a01b	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.a01d	98		tya			tya
.a01e	09 b0		ora #$b0		ora 	#PScreen>>8 						; move into screen area
.a020	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.a022	a0 00		ldy #$00		ldy 	#0
.a024	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a026	7a		ply			ply 										; restore Y and exit.
.a027	60		rts			rts
.a028					EXTWriteScreen:
.a028	5a		phy			phy
.a029	48		pha			pha
.a02a	20 1a a0	jsr $a01a		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.a02d	a0 00		ldy #$00		ldy 	#0
.a02f	68		pla			pla 										; restore and write.
.a030	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a032	7a		ply			ply
.a033	60		rts			rts
.a034					EXTClearScreen:
.a034	48		pha			pha 										; save registers
.a035	da		phx			phx
.a036	a2 00		ldx #$00		ldx 	#0
.a038					_EXTCSLoop:
.a038	a9 20		lda #$20		lda 	#32
.a03a	9d 00 b0	sta $b000,x		sta 	PScreen+0,x
.a03d	9d 00 b1	sta $b100,x		sta 	PScreen+$100,x
.a040	9d 00 b2	sta $b200,x		sta 	PScreen+$200,x
.a043	9d 00 b3	sta $b300,x		sta 	PScreen+$300,x
.a046	e8		inx			inx
.a047	d0 ef		bne $a038		bne 	_EXTCSLoop
.a049	fa		plx			plx 										; restore
.a04a	68		pla			pla
.a04b	60		rts			rts
.a04c					EXTScrollDisplay:
.a04c	48		pha			pha 										; save registers
.a04d	5a		phy			phy
.a04e	a9 00		lda #$00		lda 	#PScreen & $FF 					; set pointer to screen
.a050	85 04		sta $04			sta 	EXTZPWork+0
.a052	a9 b0		lda #$b0		lda 	#PScreen >> 8
.a054	85 05		sta $05			sta 	EXTZPWork+1
.a056					_EXTScroll:
.a056	a0 28		ldy #$28		ldy 	#EXTWidth
.a058	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a05a	a0 00		ldy #$00		ldy 	#0
.a05c	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a05e	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.a060	d0 02		bne $a064		bne 	_EXTNoCarry
.a062	e6 05		inc $05			inc 	EXTZPWork+1
.a064					_EXTNoCarry:
.a064	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.a066	c9 c0		cmp #$c0		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) & $FF
.a068	d0 ec		bne $a056		bne 	_EXTScroll
.a06a	a5 05		lda $05			lda 	EXTZPWork+1
.a06c	c9 b3		cmp #$b3		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) >> 8
.a06e	d0 e6		bne $a056		bne 	_EXTScroll
.a070	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.a072					_EXTLastLine:
.a072	a9 20		lda #$20		lda 	#32
.a074	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a076	c8		iny			iny
.a077	c0 28		cpy #$28		cpy 	#EXTWidth
.a079	d0 f7		bne $a072		bne 	_EXTLastLine
.a07b	7a		ply			ply 										; restore and exit.
.a07c	68		pla			pla
.a07d	60		rts			rts
.a07e					EXTReset:
.a07e	60		rts			rts

;******  Return to file: porting.asm


;******  Processing file: personalities/personality_io.asm

.a07f					IOInitialise:
.a07f	20 7e a0	jsr $a07e			jsr 	EXTReset 					; reset display.
.a082	20 34 a0	jsr $a034			jsr 	EXTClearScreen 				; clear screen.
.a085	48		pha				pha
.a086	a9 00		lda #$00			lda 	#00 						; home cursor
.a088	85 08		sta $08				sta 	IOCursorX
.a08a	85 09		sta $09				sta 	IOCursorY
.a08c	68		pla				pla
.a08d	60		rts				rts
.a08e					IOPrintChar:
.a08e	48		pha				pha 								; save registers
.a08f	da		phx				phx
.a090	5a		phy				phy
.a091	29 7f		and #$7f			and 	#$7F 						; bits 0-6 only
.a093	20 e1 a0	jsr $a0e1			jsr 	IOUpperCase 				; convert to upper case.
.a096	c9 0d		cmp #$0d			cmp 	#13 						; new line ?
.a098	f0 16		beq $a0b0			beq 	_IOPCNewLine
.a09a	c9 20		cmp #$20			cmp 	#32 						; not printable.
.a09c	90 23		bcc $a0c1			bcc 	_IOPCExit
.a09e	48		pha				pha 								; print at cursor
.a09f	20 ed a0	jsr $a0ed			jsr 	IOGetCursorXY
.a0a2	68		pla				pla
.a0a3	29 3f		and #$3f			and 	#$3F 						; 6 Bit ASCII
.a0a5	20 28 a0	jsr $a028			jsr 	EXTWriteScreen
.a0a8	e6 08		inc $08				inc 	IOCursorX 					; move left.
.a0aa	a5 08		lda $08				lda 	IOCursorX
.a0ac	c9 28		cmp #$28			cmp		#EXTWidth 					; will be zero if at RHS
.a0ae	d0 11		bne $a0c1			bne 	_IOPCExit 					; exit otherwise
.a0b0					_IOPCNewLine:
.a0b0	a9 00		lda #$00			lda 	#0 							; go down and to lhs
.a0b2	85 08		sta $08				sta 	IOCursorX
.a0b4	e6 09		inc $09				inc 	IOCursorY
.a0b6	a5 09		lda $09				lda 	IOCursorY 					; off bottom
.a0b8	c9 19		cmp #$19			cmp 	#EXTHeight
.a0ba	90 05		bcc $a0c1			bcc 	_IOPCExit
.a0bc	20 4c a0	jsr $a04c			jsr 	EXTScrollDisplay 			; scroll
.a0bf	c6 09		dec $09				dec 	IOCursorY 					; fix up.
.a0c1					_IOPCExit:
.a0c1	7a		ply				ply
.a0c2	fa		plx				plx
.a0c3	68		pla				pla
.a0c4	60		rts				rts
.a0c5					IOReadKey:
.a0c5	da		phx				phx 								; save XY
.a0c6	5a		phy				phy
.a0c7	20 ed a0	jsr $a0ed			jsr 	IOGetCursorXY 				; show prompt
.a0ca	a9 1d		lda #$1d			lda 	#$1D
.a0cc	20 28 a0	jsr $a028			jsr  	EXTWriteScreen
.a0cf					_IORKWait:
.a0cf	20 0c a0	jsr $a00c			jsr 	EXTReadKey
.a0d2	f0 fb		beq $a0cf			beq 	_IORKWait
.a0d4	48		pha				pha 								; clear prompt
.a0d5	20 ed a0	jsr $a0ed			jsr 	IOGetCursorXY
.a0d8	a9 20		lda #$20			lda 	#" "
.a0da	20 28 a0	jsr $a028			jsr  	EXTWriteScreen
.a0dd	68		pla				pla
.a0de	7a		ply				ply 								; restore and exit.
.a0df	fa		plx				plx
.a0e0	60		rts				rts
.a0e1					IOUpperCase:
.a0e1	c9 61		cmp #$61			cmp 	#"a"
.a0e3	90 07		bcc $a0ec			bcc 	_IOUCExit
.a0e5	c9 7b		cmp #$7b			cmp 	#"z"+1
.a0e7	b0 03		bcs $a0ec			bcs 	_IOUCExit
.a0e9	38		sec				sec
.a0ea	e9 20		sbc #$20			sbc 	#32
.a0ec					_IOUCExit:
.a0ec	60		rts				rts
.a0ed					IOGetCursorXY:
.a0ed	48		pha				pha
.a0ee	a5 09		lda $09				lda 	IOCursorY 					; multiply IOCursorY x 5
.a0f0	0a		asl a				asl		a
.a0f1	0a		asl a				asl		a 							; x 4, carry clear
.a0f2	65 09		adc $09				adc 	IOCursorY 					; so this will be 0..199 now
.a0f4	aa		tax				tax
.a0f5	8a		txa				txa 								; x 10
.a0f6	0a		asl a				asl 	a
.a0f7	aa		tax				tax
.a0f8	a9 00		lda #$00			lda 	#0
.a0fa	2a		rol a				rol 	a
.a0fb	a8		tay				tay
.a0fc	8a		txa				txa 								; x 20
.a0fd	0a		asl a				asl 	a
.a0fe	aa		tax				tax
.a0ff	98		tya				tya
.a100	2a		rol a				rol 	a
.a101	a8		tay				tay
.a102	8a		txa				txa 								; x 40
.a103	0a		asl a				asl 	a
.a104	aa		tax				tax
.a105	98		tya				tya
.a106	2a		rol a				rol 	a
.a107	a8		tay				tay
.a108	8a		txa				txa 								; add X to that.
.a109	18		clc				clc
.a10a	65 08		adc $08				adc 	IOCursorX
.a10c	aa		tax				tax
.a10d	90 01		bcc $a110			bcc 	_IOGCXYExit
.a10f	c8		iny				iny
.a110					_IOGCXYExit:
.a110	68		pla				pla
.a111	60		rts				rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	67 e4					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	98 e8					.word	SyntaxError                   ; """        ($0081)
>e004	98 e8					.word	SyntaxError                   ; "#"        ($0082)
>e006	5c e4					.word	BFUNC_String                  ; "$"        ($0083)
>e008	fb e5					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	6e e4					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	98 e8					.word	SyntaxError                   ; "'"        ($0086)
>e00e	98 e8					.word	SyntaxError                   ; "("        ($0087)
>e010	98 e8					.word	SyntaxError                   ; ")"        ($0088)
>e012	dd e4					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	10 e4					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	36 e4					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	34 e5					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	98 e8					.word	SyntaxError                   ; ":"        ($008d)
>e01c	98 e8					.word	SyntaxError                   ; ";"        ($008e)
>e01e	79 e6					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	1a e6					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	54 e6					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	17 e6					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	57 e6					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	76 e6					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	60 e4					.word	BFUNC_ByteInd                 ; "?"        ($0095)
>e02c	b8 e4					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	da e7					.word	COMMAND_Assert                ; "assert"   ($0097)
>e030	2d e7					.word	UNARY_Abs                     ; "abs"      ($0098)
>e032	1c e8					.word	COMMAND_Clear                 ; "clear"    ($0099)
>e034	18 e7					.word	UNARY_Ch                      ; "ch"       ($009a)
>e036	98 e8					.word	SyntaxError                   ; "do"       ($009b)
>e038	d6 e7					.word	COMMAND_End                   ; "end"      ($009c)
>e03a	98 e8					.word	SyntaxError                   ; "for"      ($009d)
>e03c	98 e8					.word	SyntaxError                   ; "gosub"    ($009e)
>e03e	98 e8					.word	SyntaxError                   ; "goto"     ($009f)
>e040	98 e8					.word	SyntaxError                   ; "input"    ($00a0)
>e042	98 e8					.word	SyntaxError                   ; "if"       ($00a1)
>e044	98 e8					.word	SyntaxError                   ; "list"     ($00a2)
>e046	98 e8					.word	SyntaxError                   ; "loop"     ($00a3)
>e048	98 e8					.word	SyntaxError                   ; "link"     ($00a4)
>e04a	98 e8					.word	SyntaxError                   ; "let"      ($00a5)
>e04c	d6 e6					.word	UNARY_Len                     ; "len"      ($00a6)
>e04e	98 e8					.word	SyntaxError                   ; "next"     ($00a7)
>e050	09 e8					.word	COMMAND_New                   ; "new"      ($00a8)
>e052	50 e8					.word	COMMAND_Old                   ; "old"      ($00a9)
>e054	98 e8					.word	SyntaxError                   ; "print"    ($00aa)
>e056	ff e7					.word	COMMAND_Rem                   ; "rem"      ($00ab)
>e058	4a e7					.word	UNARY_Rnd                     ; "rnd"      ($00ac)
>e05a	ce e7					.word	COMMAND_Stop                  ; "stop"     ($00ad)
>e05c	98 e8					.word	SyntaxError                   ; "step"     ($00ae)
>e05e	98 e8					.word	SyntaxError                   ; "then"     ($00af)
>e060	35 e7					.word	UNARY_Top                     ; "top"      ($00b0)
>e062	98 e8					.word	SyntaxError                   ; "to"       ($00b1)
>e064	93 e4					.word	BFUNC_Or                      ; "|"        ($00b2)
>e066	98 e6					.word	BFUNC_StringCompare           ; "~"        ($00b3)
.e068					TokenText:
>e068	a1					.byte $a1                             ; $0080 !
>e069	a2					.byte $a2                             ; $0081 "
>e06a	a3					.byte $a3                             ; $0082 #
>e06b	a4					.byte $a4                             ; $0083 $
>e06c	a5					.byte $a5                             ; $0084 %
>e06d	a6					.byte $a6                             ; $0085 &
>e06e	a7					.byte $a7                             ; $0086 '
>e06f	a8					.byte $a8                             ; $0087 (
>e070	a9					.byte $a9                             ; $0088 )
>e071	aa					.byte $aa                             ; $0089 *
>e072	ab					.byte $ab                             ; $008a +
>e073	ad					.byte $ad                             ; $008b -
>e074	af					.byte $af                             ; $008c /
>e075	ba					.byte $ba                             ; $008d :
>e076	bb					.byte $bb                             ; $008e ;
>e077	3c bd					.byte $3c,$bd                         ; $008f <=
>e079	3c be					.byte $3c,$be                         ; $0090 <>
>e07b	bc					.byte $bc                             ; $0091 <
>e07c	bd					.byte $bd                             ; $0092 =
>e07d	3e bd					.byte $3e,$bd                         ; $0093 >=
>e07f	be					.byte $be                             ; $0094 >
>e080	bf					.byte $bf                             ; $0095 ?
>e081	de					.byte $de                             ; $0096 ^
>e082	61 73 73 65 72 f4			.byte $61,$73,$73,$65,$72,$f4         ; $0097 assert
>e088	61 62 f3				.byte $61,$62,$f3                     ; $0098 abs
>e08b	63 6c 65 61 f2				.byte $63,$6c,$65,$61,$f2             ; $0099 clear
>e090	63 e8					.byte $63,$e8                         ; $009a ch
>e092	64 ef					.byte $64,$ef                         ; $009b do
>e094	65 6e e4				.byte $65,$6e,$e4                     ; $009c end
>e097	66 6f f2				.byte $66,$6f,$f2                     ; $009d for
>e09a	67 6f 73 75 e2				.byte $67,$6f,$73,$75,$e2             ; $009e gosub
>e09f	67 6f 74 ef				.byte $67,$6f,$74,$ef                 ; $009f goto
>e0a3	69 6e 70 75 f4				.byte $69,$6e,$70,$75,$f4             ; $00a0 input
>e0a8	69 e6					.byte $69,$e6                         ; $00a1 if
>e0aa	6c 69 73 f4				.byte $6c,$69,$73,$f4                 ; $00a2 list
>e0ae	6c 6f 6f f0				.byte $6c,$6f,$6f,$f0                 ; $00a3 loop
>e0b2	6c 69 6e eb				.byte $6c,$69,$6e,$eb                 ; $00a4 link
>e0b6	6c 65 f4				.byte $6c,$65,$f4                     ; $00a5 let
>e0b9	6c 65 ee				.byte $6c,$65,$ee                     ; $00a6 len
>e0bc	6e 65 78 f4				.byte $6e,$65,$78,$f4                 ; $00a7 next
>e0c0	6e 65 f7				.byte $6e,$65,$f7                     ; $00a8 new
>e0c3	6f 6c e4				.byte $6f,$6c,$e4                     ; $00a9 old
>e0c6	70 72 69 6e f4				.byte $70,$72,$69,$6e,$f4             ; $00aa print
>e0cb	72 65 ed				.byte $72,$65,$ed                     ; $00ab rem
>e0ce	72 6e e4				.byte $72,$6e,$e4                     ; $00ac rnd
>e0d1	73 74 6f f0				.byte $73,$74,$6f,$f0                 ; $00ad stop
>e0d5	73 74 65 f0				.byte $73,$74,$65,$f0                 ; $00ae step
>e0d9	74 68 65 ee				.byte $74,$68,$65,$ee                 ; $00af then
>e0dd	74 6f f0				.byte $74,$6f,$f0                     ; $00b0 top
>e0e0	74 ef					.byte $74,$ef                         ; $00b1 to
>e0e2	fc					.byte $fc                             ; $00b2 |
>e0e3	fe					.byte $fe                             ; $00b3 ~
>e0e4	00					.byte $00
.e0e5					TokenTypeInformation:
>e0e5	04					.byte $04                             ; $0080 !
>e0e6	0a					.byte $0a                             ; $0081 "
>e0e7	0a					.byte $0a                             ; $0082 #
>e0e8	04					.byte $04                             ; $0083 $
>e0e9	03					.byte $03                             ; $0084 %
>e0ea	00					.byte $00                             ; $0085 &
>e0eb	0a					.byte $0a                             ; $0086 '
>e0ec	0a					.byte $0a                             ; $0087 (
>e0ed	0a					.byte $0a                             ; $0088 )
>e0ee	03					.byte $03                             ; $0089 *
>e0ef	02					.byte $02                             ; $008a +
>e0f0	02					.byte $02                             ; $008b -
>e0f1	03					.byte $03                             ; $008c /
>e0f2	0a					.byte $0a                             ; $008d :
>e0f3	0a					.byte $0a                             ; $008e ;
>e0f4	01					.byte $01                             ; $008f <=
>e0f5	01					.byte $01                             ; $0090 <>
>e0f6	01					.byte $01                             ; $0091 <
>e0f7	01					.byte $01                             ; $0092 =
>e0f8	01					.byte $01                             ; $0093 >=
>e0f9	01					.byte $01                             ; $0094 >
>e0fa	04					.byte $04                             ; $0095 ?
>e0fb	00					.byte $00                             ; $0096 ^
>e0fc	04					.byte $04                             ; $0097 assert
>e0fd	09					.byte $09                             ; $0098 abs
>e0fe	04					.byte $04                             ; $0099 clear
>e0ff	09					.byte $09                             ; $009a ch
>e100	04					.byte $04                             ; $009b do
>e101	04					.byte $04                             ; $009c end
>e102	04					.byte $04                             ; $009d for
>e103	04					.byte $04                             ; $009e gosub
>e104	04					.byte $04                             ; $009f goto
>e105	04					.byte $04                             ; $00a0 input
>e106	04					.byte $04                             ; $00a1 if
>e107	04					.byte $04                             ; $00a2 list
>e108	04					.byte $04                             ; $00a3 loop
>e109	04					.byte $04                             ; $00a4 link
>e10a	04					.byte $04                             ; $00a5 let
>e10b	09					.byte $09                             ; $00a6 len
>e10c	04					.byte $04                             ; $00a7 next
>e10d	04					.byte $04                             ; $00a8 new
>e10e	04					.byte $04                             ; $00a9 old
>e10f	04					.byte $04                             ; $00aa print
>e110	04					.byte $04                             ; $00ab rem
>e111	09					.byte $09                             ; $00ac rnd
>e112	04					.byte $04                             ; $00ad stop
>e113	04					.byte $04                             ; $00ae step
>e114	04					.byte $04                             ; $00af then
>e115	09					.byte $09                             ; $00b0 top
>e116	04					.byte $04                             ; $00b1 to
>e117	00					.byte $00                             ; $00b2 |
>e118	01					.byte $01                             ; $00b3 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CH = $009a
=$009b					KW_DO = $009b
=$009c					KW_END = $009c
=$009d					KW_FOR = $009d
=$009e					KW_GOSUB = $009e
=$009f					KW_GOTO = $009f
=$00a0					KW_INPUT = $00a0
=$00a1					KW_IF = $00a1
=$00a2					KW_LIST = $00a2
=$00a3					KW_LOOP = $00a3
=$00a4					KW_LINK = $00a4
=$00a5					KW_LET = $00a5
=$00a6					KW_LEN = $00a6
=$00a7					KW_NEXT = $00a7
=$00a8					KW_NEW = $00a8
=$00a9					KW_OLD = $00a9
=$00aa					KW_PRINT = $00aa
=$00ab					KW_REM = $00ab
=$00ac					KW_RND = $00ac
=$00ad					KW_STOP = $00ad
=$00ae					KW_STEP = $00ae
=$00af					KW_THEN = $00af
=$00b0					KW_TOP = $00b0
=$00b1					KW_TO = $00b1
=$00b2					KW_BAR = $00b2
=$00b3					KW_TILDE = $00b3

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e119					CheckNextCharacter:
.e119	8d 6e 20	sta $206e			sta 	Temp1 						; save character to check
.e11c					_CNCLoop:
.e11c	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e11e	f0 0b		beq $e12b			beq 	_CNCFail 					; end of line, so no character
.e120	c8		iny				iny
.e121	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e123	f0 f7		beq $e11c			beq 	_CNCLoop
.e125	cd 6e 20	cmp $206e			cmp 	Temp1 						; fail if not what was wanted
.e128	d0 01		bne $e12b			bne 	_CNCFail
.e12a	60		rts				rts
.e12b					_CNCFail:
.e12b	20 9d e8	jsr $e89d			jsr 	ReportError
>e12e	4d 69 73 73 69 6e 67 20				.text 	"Missing token",$00
>e136	74 6f 6b 65 6e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e13c							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zBasicStack:	.word 	? 					; stack for BASIC.
>0024					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0026					zTemp1:			.word 	?					; temporary vars
>0028					zTemp2:			.word 	?
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>206e					Temp1:			.dword	?					; 4 byte temporary stores.
>2072					SignCount:		.byte 	? 					; count of signs in divide.
>2073					StringBufferPos:.byte 	? 					; next free slot in string buffer
>2074					RandomSeed 		.word 	? 					; Random Number
>2076									.align	256
.2100					StringBuffer:
>2100									.byte ?
>2101									.align	256
.2200					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e13c					EvaluateSNError:
.e13c	4c 98 e8	jmp $e898			jmp 	SyntaxError
.e13f					EvaluateMissingQuote:
.e13f	20 9d e8	jsr $e89d			jsr 	ReportError
>e142	4d 69 73 73 69 6e 67 20				.text 	"Missing quote",$00
>e14a	71 75 6f 74 65 00
.e150					EvaluateStringFull:
.e150	20 9d e8	jsr $e89d			jsr 	ReportError
>e153	53 74 72 69 6e 67 20 42				.text 	"String Buffer full",$00
>e15b	75 66 66 65 72 20 66 75 6c 6c 00
.e166					EvaluateBadHex:
.e166	20 9d e8	jsr $e89d			jsr 	ReportError
>e169	42 61 64 20 48 65 78 00				.text 	"Bad Hex",$00
.e171					EvaluateAtomCurrentLevel:
.e171	a9 07		lda #$07			lda 	#7
.e173	80 04		bra $e179			bra 	EvaluateAtPrecedenceLevel
.e175					EvaluateBase:
.e175	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e177					EvaluateBaseCurrentLevel:
.e177	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e179					EvaluateAtPrecedenceLevel:
.e179	48		pha				pha 								; save precedence level
.e17a	a9 00		lda #$00			lda 	#0 							; zero the result.
.e17c	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e17f	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e182	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e185	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e188					_EVALSkipSpace1:
.e188	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e18a	f0 b0		beq $e13c			beq 	EvaluateSNError 			; end of line, without token.
.e18c	c8		iny				iny
.e18d	c9 20		cmp #$20			cmp 	#32
.e18f	f0 f7		beq $e188			beq 	_EVALSkipSpace1
.e191	88		dey				dey 								; points at the token.
.e192	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e194	f0 14		beq $e1aa			beq 	_EVALString  				; if so load in a constant string
.e196	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e198	f0 36		beq $e1d0			beq 	_EVALHexadecimal
.e19a	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e19c	90 04		bcc $e1a2			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e19e	c9 3a		cmp #$3a			cmp 	#'9'+1
.e1a0	90 03		bcc $e1a5			bcc 	_EVALDecimal
.e1a2					_EVALGoKeywordVariable:
.e1a2	4c 27 e2	jmp $e227			jmp 	_EVALKeywordVariable
.e1a5					_EVALDecimal:
.e1a5	20 84 e2	jsr $e284			jsr 	EVALGetDecConstant 			; get decimal constant
.e1a8	80 34		bra $e1de			bra 	_EVALGotAtom 				; got atom.
.e1aa					_EVALString:
.e1aa	da		phx				phx 								; save X on stack
.e1ab	a9 21		lda #$21			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e1ad	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1b0	ad 73 20	lda $2073			lda 	StringBufferPos 			; X = Buffer Position.
.e1b3	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e1b6	aa		tax				tax 								; put in X to build the string.
.e1b7	c8		iny				iny 								; skip over opening quote character
.e1b8					_EVALStringCopy:
.e1b8	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e1ba	c8		iny				iny
.e1bb	f0 82		beq $e13f			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e1bd	9d 00 21	sta $2100,x			sta 	StringBuffer,x 				; copy into the buffer
.e1c0	e8		inx				inx 								; and bump that pointer.
.e1c1	f0 8d		beq $e150			beq 	EvaluateStringFull 			; buffer is full.
.e1c3	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e1c5	d0 f1		bne $e1b8			bne 	_EVALStringCopy
.e1c7	8e 73 20	stx $2073			stx 	StringBufferPos 			; this is the new next free slot.
.e1ca	9d ff 20	sta $20ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e1cd	fa		plx				plx 								; restore X
.e1ce	80 0e		bra $e1de			bra 	_EVALGotAtom 				; got the atom.
.e1d0					_EVALHexaDecimal
.e1d0	c8		iny				iny 								; skip over the '#'
.e1d1	5a		phy				phy 								; save Y
.e1d2	20 f0 e2	jsr $e2f0			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e1d5	8c 6e 20	sty $206e			sty 	Temp1 						; has Y changed ?
.e1d8	68		pla				pla
.e1d9	cd 6e 20	cmp $206e			cmp 	Temp1
.e1dc	f0 88		beq $e166			beq 	EvaluateBadHex 				; if not, error.
.e1de					_EVALGotAtom:
.e1de					_EVALGetOperator:
.e1de	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e1e0	c8		iny				iny 								; this should be binary operator
.e1e1	c9 20		cmp #$20			cmp 	#$20
.e1e3	f0 f9		beq $e1de			beq 	_EVALGetOperator
.e1e5	88		dey				dey
.e1e6	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e1e8	10 3b		bpl $e225			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e1ea	da		phx				phx 								; save X
.e1eb	aa		tax				tax 								; token in X
.e1ec	bd 65 e0	lda $e065,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e1ef	8d 6e 20	sta $206e			sta 	Temp1 						; save precedence in Temp1
.e1f2	fa		plx				plx 								; restore X
.e1f3	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e1f5	b0 2e		bcs $e225			bcs 	_EVALExitPullA
.e1f7	68		pla				pla 								; get and save precedence level.
.e1f8	48		pha				pha
.e1f9	cd 6e 20	cmp $206e			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e1fc	f0 02		beq $e200			beq 	_EVALDoCalc					; equal, do it.
.e1fe	b0 25		bcs $e225			bcs 	_EVALExitPullA				; too high, then exit.
.e200					_EVALDoCalc:
.e200	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e202	c8		iny				iny
.e203	48		pha				pha
.e204	da		phx				phx
.e205	e8		inx				inx 								; work out right hand side.
.e206	e8		inx				inx
.e207	e8		inx				inx
.e208	e8		inx				inx
.e209	ad 6e 20	lda $206e			lda 	Temp1 						; get current operator precedence level.
.e20c	1a		inc a				inc 	a 							; so work it out at the next level.
.e20d	20 79 e1	jsr $e179			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e210	fa		plx				plx 								; fix X back.
.e211	68		pla				pla 								; get keyword
.e212					_EVALExecuteA:
.e212	0a		asl a				asl 	a 							; shift left, drop bit 7
.e213	8d 6f 20	sta $206f			sta 	Temp1+1						; save in Temp1.1
.e216	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e218	8d 70 20	sta $2070			sta 	Temp1+2 					; set at Temp1.2
.e21b	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e21d	8d 6e 20	sta $206e			sta 	Temp1+0
.e220	20 6e 20	jsr $206e			jsr 	Temp1 						; call that routine.
.e223	80 b9		bra $e1de			bra 	_EVALGotAtom 				; and loop back again.
.e225					_EVALExitPullA:
.e225	68		pla				pla 								; restore precedence.
.e226	60		rts				rts
.e227					_EVALKeywordVariable:
.e227	09 00		ora #$00			ora 	#0 							; check bit 7
.e229	10 0f		bpl $e23a			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e22b	da		phx				phx
.e22c	aa		tax				tax
.e22d	bd 65 e0	lda $e065,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e230	fa		plx				plx
.e231	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e233	d0 05		bne $e23a			bne 	_EVALNotUnaryFunction
.e235	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e237	c8		iny				iny 								; consume it
.e238	80 d8		bra $e212			bra 	_EVALExecuteA 				; execute TOS.
.e23a					_EVALNotUnaryFunction:
.e23a	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e23c	10 3d		bpl $e27b			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e23e	c9 8b		cmp #$8b			cmp 	#KW_MINUS 					; check negation
.e240	f0 0f		beq $e251			beq 	_EVALUnaryNegation
.e242	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e244	d0 14		bne $e25a			bne		_EVALCheckUnaryOperator
.e246	c8		iny				iny 								; skip left bracket.
.e247	20 77 e1	jsr $e177			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e24a	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e24c	20 19 e1	jsr $e119			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e24f	80 8d		bra $e1de			bra 	_EVALGotAtom
.e251					_EVALUnaryNegation:
.e251	c8		iny				iny 								; skip over the - sign.
.e252	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e255	20 d6 e5	jsr $e5d6			jsr 	BFUNC_NegateAlways 			; negate it.
.e258	80 84		bra $e1de			bra 	_EVALGotAtom
.e25a					_EVALCheckUnaryOperator:
.e25a	48		pha				pha 								; save indirection operator.
.e25b	c8		iny				iny 								; skip over the operator
.e25c	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e25f	68		pla				pla 								; restore the operator
.e260	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e262	f0 0e		beq $e272			beq 	_EVALGoGotAtom
.e264	c9 95		cmp #$95			cmp 	#KW_QUESTION				; byte indirection
.e266	f0 07		beq $e26f			beq 	_EVALByteRead
.e268	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e26a	f0 09		beq $e275			beq 	_EVALWordRead
.e26c	4c 98 e8	jmp $e898			jmp 	SyntaxError 				; give up.
.e26f					_EVALByteRead:
.e26f	20 2f e3	jsr $e32f			jsr 	EVALReadByteIndirect
.e272					_EVALGoGotAtom:
.e272	4c de e1	jmp $e1de			jmp 	_EVALGotAtom
.e275					_EVALWordRead:
.e275	20 58 e3	jsr $e358			jsr 	EVALReadWordIndirect
.e278	4c de e1	jmp $e1de			jmp 	_EVALGotAtom
.e27b					_EVALCheckVariable:
.e27b	20 88 e3	jsr $e388			jsr 	VARReference 				; get variable reference to ZTemp1
.e27e	20 6c e3	jsr $e36c			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e281	4c de e1	jmp $e1de			jmp 	_EVALGotAtom 				; and go round.
.e284					EVALGetDecConstant:
.e284	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e286	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e288	90 04		bcc $e28e			bcc 	_EVGDExit
.e28a	c9 3a		cmp #$3a			cmp 	#'9'+1
.e28c	90 01		bcc $e28f			bcc 	_EVGDValue 					; if so has legal value
.e28e					_EVGDExit:
.e28e	60		rts				rts
.e28f					_EVGDValue:
.e28f	48		pha				pha 								; save value, Y on stack
.e290	5a		phy				phy
.e291	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e293	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e296	48		pha				pha
.e297	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e29a	48		pha				pha
.e29b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e29e	48		pha				pha
.e29f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e2a2	48		pha				pha
.e2a3					_EVGDLoop:
.e2a3	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e2a6	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e2a9	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e2ac	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e2af	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e2b1	d0 1d		bne $e2d0			bne 	_EVGDNoAdd
.e2b3	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e2b4	68		pla				pla
.e2b5	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e2b8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e2bb	68		pla				pla
.e2bc	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e2bf	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e2c2	68		pla				pla
.e2c3	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e2c6	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e2c9	68		pla				pla
.e2ca	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e2cd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e2d0					_EVGDNoAdd:
.e2d0	88		dey				dey
.e2d1	d0 d0		bne $e2a3			bne 	_EVGDLoop
.e2d3	7a		ply				ply 								; restore YA
.e2d4	68		pla				pla
.e2d5	c8		iny				iny 								; next character
.e2d6	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e2d8	18		clc				clc
.e2d9	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e2dc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e2df	90 a3		bcc $e284			bcc 	EVALGetDecConstant 			; propogate constant through
.e2e1	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e2e4	d0 9e		bne $e284			bne 	EVALGetDecConstant
.e2e6	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e2e9	d0 99		bne $e284			bne 	EVALGetDecConstant
.e2eb	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e2ee	80 94		bra $e284			bra 	EVALGetDecConstant 			; go back and try again.
.e2f0					EVALGetHexConstant:
.e2f0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e2f2	20 24 e3	jsr $e324			jsr 	EVALToUpper 				; make upper case
.e2f5	38		sec				sec
.e2f6	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e2f8	90 0a		bcc $e304			bcc 	_EVGHExit 					; exit if CC
.e2fa	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e2fc	90 07		bcc $e305			bcc 	_EVGHValue
.e2fe	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e300	c9 10		cmp #$10			cmp 	#15+1
.e302	90 01		bcc $e305			bcc 	_EVGHValue
.e304					_EVGHExit:
.e304	60		rts				rts
.e305					_EVGHValue:
.e305	5a		phy				phy 								; save Y and new digit.
.e306	48		pha				pha
.e307	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e309					_EVGHRotate:
.e309	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e30c	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e30f	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e312	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e315	88		dey				dey
.e316	d0 f1		bne $e309			bne 	_EVGHRotate
.e318	68		pla				pla 								; restore digit and X
.e319	7a		ply				ply
.e31a	c8		iny				iny 								; next character
.e31b	18		clc				clc
.e31c	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e31f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e322	80 cc		bra $e2f0			bra 	EVALGetHexConstant 			; go back and try again.
.e324					EVALToUpper:
.e324	c9 61		cmp #$61			cmp 	#'a'
.e326	90 06		bcc $e32e			bcc 	_EVTUExit
.e328	c9 7b		cmp #$7b			cmp 	#'z'+1
.e32a	b0 02		bcs $e32e			bcs 	_EVTUExit
.e32c	49 20		eor #$20			eor 	#32
.e32e					_EVTUExit:
.e32e	60		rts				rts
.e32f					EVALReadByteIndirect:
.e32f	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e332	85 26		sta $26				sta 	zTemp1
.e334	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e337	85 27		sta $27				sta 	zTemp1+1
.e339	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e33c	85 28		sta $28				sta 	zTemp1+2
.e33e	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e341	85 29		sta $29				sta 	zTemp1+3
.e343	5a		phy				phy
.e344	a0 00		ldy #$00			ldy 	#0 							; read byte
.e346	b1 26		lda ($26),y			lda 	(zTemp1),y
.e348	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e34b	7a		ply				ply
.e34c	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e34e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e351	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e354	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e357	60		rts				rts
.e358					EVALReadWordIndirect:
.e358	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e35b	85 26		sta $26				sta 	zTemp1
.e35d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e360	85 27		sta $27				sta 	zTemp1+1
.e362	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e365	85 28		sta $28				sta 	zTemp1+2
.e367	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e36a	85 29		sta $29				sta 	zTemp1+3
.e36c					EVALReadWordIndirectZTemp:
.e36c	5a		phy				phy
.e36d	a0 00		ldy #$00			ldy 	#0 							; read word
.e36f	b1 26		lda ($26),y			lda 	(zTemp1),y
.e371	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e374	c8		iny				iny
.e375	b1 26		lda ($26),y			lda 	(zTemp1),y
.e377	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e37a	c8		iny				iny
.e37b	b1 26		lda ($26),y			lda 	(zTemp1),y
.e37d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e380	c8		iny				iny
.e381	b1 26		lda ($26),y			lda 	(zTemp1),y
.e383	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e386	7a		ply				ply
.e387	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e388					VARReference:
.e388	48		pha				pha
.e389	a9 04		lda #$04			lda 	#4
.e38b	8d 08 20	sta $2008			sta 	FixedVariables+8
.e38e	a9 e0		lda #$e0			lda 	#$E0 						; Fix ; set B = $E004
.e390	8d 09 20	sta $2009			sta 	FixedVariables+9
.e393	68		pla				pla
.e394	38		sec				sec 								; check range @-Z there
.e395	c9 40		cmp #$40			cmp 	#'@'
.e397	90 04		bcc $e39d			bcc 	_VARRError
.e399	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e39b	90 03		bcc $e3a0			bcc 	_VARROkay
.e39d					_VARRError:
.e39d	4c 98 e8	jmp $e898			jmp		SyntaxError
.e3a0					_VARROkay:
.e3a0	c8		iny				iny 								; consume the variable.
.e3a1	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e3a3	f0 1b		beq $e3c0			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e3a5	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e3a7	88		dey				dey 								; point back to the first character
.e3a8	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e3aa	f0 14		beq $e3c0			beq 	_VARArrayAccess
.e3ac	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e3ae	c8		iny				iny
.e3af	29 1f		and #$1f			and		#31 						; mask out
.e3b1	0a		asl a				asl 	a 							; x 4
.e3b2	0a		asl a				asl 	a
.e3b3	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e3b5	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e3b7	85 27		sta $27				sta 	zTemp1+1
.e3b9	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e3bb	85 28		sta $28				sta 	zTemp1+2
.e3bd	85 29		sta $29				sta 	zTemp1+3 					; return with address set.
.e3bf	60		rts				rts
.e3c0					_VARArrayAccess:
.e3c0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e3c2	c8		iny				iny
.e3c3	29 1f		and #$1f			and 	#31 						; mask it off
.e3c5	48		pha				pha 								; save on the stack.
.e3c6	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e3c9	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e3cc	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3cf	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3d2	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3d5	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e3d8	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3db	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3de	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3e1	68		pla				pla 								; put address in zTemp1
.e3e2	0a		asl a				asl 	a 							; x 4
.e3e3	0a		asl a				asl 	a
.e3e4	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e3e6	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e3e8	85 27		sta $27				sta 	zTemp1+1
.e3ea	5a		phy				phy
.e3eb	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e3ed	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3ef	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e3f2	48		pha				pha 								; save first result as we need the indirection.
.e3f3	c8		iny				iny 								; 2nd byte
.e3f4	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3f6	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e3f9	85 27		sta $27				sta 	zTemp1+1
.e3fb	68		pla				pla 								; save the low byte.
.e3fc	85 26		sta $26				sta 	zTemp1+0
.e3fe	a9 00		lda #$00			lda 	#0
.e400	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e403	85 28		sta $28				sta 	zTemp1+2
.e405	a9 00		lda #$00			lda 	#0
.e407	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e40a	85 29		sta $29				sta 	zTemp1+3
.e40c	7a		ply				ply 								; restore Y, address setup
.e40d	60		rts				rts
.e40e	80 fe		bra $e40e	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e410					BFUNC_Add:
.e410	18		clc				clc
.e411	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e414	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e417	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e41a	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e41d	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e420	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e423	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e426	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e429	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e42c	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e42f	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e432	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e435	60		rts				rts
.e436					BFUNC_Subtract:
.e436	38		sec				sec
.e437	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e43a	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e43d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e440	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e443	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e446	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e449	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e44c	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e44f	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e452	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e455	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e458	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e45b	60		rts				rts
.e45c					BFUNC_String:
.e45c	20 10 e4	jsr $e410			jsr 	BFUNC_Add
.e45f	60		rts				rts
.e460					BFUNC_ByteInd:
.e460	20 10 e4	jsr $e410			jsr 	BFUNC_Add
.e463	20 2f e3	jsr $e32f			jsr 	EVALReadByteIndirect
.e466	60		rts				rts
.e467					BFUNC_WordInd:
.e467	20 10 e4	jsr $e410			jsr 	BFUNC_Add
.e46a	20 58 e3	jsr $e358			jsr 	EVALReadWordIndirect
.e46d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e46e					BFUNC_And:
.e46e	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e471	3d 04 04	and $0404,x			and 	evalStack+4,x
.e474	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e477	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e47a	3d 05 04	and $0405,x			and 	evalStack+5,x
.e47d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e480	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e483	3d 06 04	and $0406,x			and 	evalStack+6,x
.e486	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e489	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e48c	3d 07 04	and $0407,x			and 	evalStack+7,x
.e48f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e492	60		rts				rts
.e493					BFUNC_Or:
.e493	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e496	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e499	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e49c	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e49f	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e4a2	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e4a5	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e4a8	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e4ab	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e4ae	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e4b1	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e4b4	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e4b7	60		rts				rts
.e4b8					BFUNC_Xor:
.e4b8	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e4bb	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e4be	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e4c1	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e4c4	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e4c7	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e4ca	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e4cd	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e4d0	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e4d3	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e4d6	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e4d9	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e4dc	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e4dd					BFUNC_Multiply:
.e4dd	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e4e0	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e4e3	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e4e6	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e4e9	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e4ec	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e4ef	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e4f2	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e4f5	a9 00		lda #$00			lda 	#0
.e4f7	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e4fa	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e4fd	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e500	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e503					_BFMMultiply:
.e503	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e506	29 01		and #$01			and 	#1
.e508	f0 03		beq $e50d			beq 	_BFMNoAdd
.e50a	20 10 e4	jsr $e410			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e50d					_BFMNoAdd:
.e50d	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e510	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e513	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e516	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e519	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e51c	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e51f	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e522	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e525	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e528	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e52b	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e52e	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e531	d0 d0		bne $e503			bne 	_BFMMultiply
.e533	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e534					BFUNC_Divide:
.e534	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e537	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e53a	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e53d	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e540	d0 13		bne $e555			bne 	_BFDOkay
.e542	20 9d e8	jsr $e89d			jsr 	ReportError
>e545	44 69 76 69 73 6f 6e 20				.text 	"Divison by Zero",$00
>e54d	62 79 20 5a 65 72 6f 00
.e555					_BFDOkay:
.e555	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e557	8d 6e 20	sta $206e			sta 	Temp1 						; Q/Dividend/Left in +0
.e55a	8d 6f 20	sta $206f			sta 	Temp1+1 					; M/Divisor/Right in +4
.e55d	8d 70 20	sta $2070			sta 	Temp1+2
.e560	8d 71 20	sta $2071			sta 	Temp1+3
.e563	8d 72 20	sta $2072			sta 	SignCount 					; Count of signs.
.e566	20 d1 e5	jsr $e5d1			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e569	da		phx				phx
.e56a	e8		inx				inx
.e56b	e8		inx				inx
.e56c	e8		inx				inx
.e56d	e8		inx				inx
.e56e	20 d1 e5	jsr $e5d1			jsr 	BFUNC_Negate
.e571	fa		plx				plx
.e572	5a		phy				phy 								; Y is the counter
.e573	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e575					_BFDLoop:
.e575	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e578	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e57b	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e57e	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e581	2e 6e 20	rol $206e			rol 	Temp1
.e584	2e 6f 20	rol $206f			rol 	Temp1+1
.e587	2e 70 20	rol $2070			rol 	Temp1+2
.e58a	2e 71 20	rol $2071			rol 	Temp1+3
.e58d	38		sec				sec
.e58e	ad 6e 20	lda $206e			lda 	Temp1+0 					; Calculate A-M on stack.
.e591	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e594	48		pha				pha
.e595	ad 6f 20	lda $206f			lda 	Temp1+1
.e598	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e59b	48		pha				pha
.e59c	ad 70 20	lda $2070			lda 	Temp1+2
.e59f	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e5a2	48		pha				pha
.e5a3	ad 71 20	lda $2071			lda 	Temp1+3
.e5a6	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e5a9	90 19		bcc $e5c4			bcc 	_BFDNoAdd
.e5ab	8d 71 20	sta $2071			sta 	Temp1+3 					; update A
.e5ae	68		pla				pla
.e5af	8d 70 20	sta $2070			sta 	Temp1+2
.e5b2	68		pla				pla
.e5b3	8d 6f 20	sta $206f			sta 	Temp1+1
.e5b6	68		pla				pla
.e5b7	8d 6e 20	sta $206e			sta 	Temp1+0
.e5ba	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.e5bd	09 01		ora #$01			ora 	#1
.e5bf	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e5c2	80 03		bra $e5c7			bra 	_BFDNext
.e5c4					_BFDNoAdd:
.e5c4	68		pla				pla 								; Throw away the intermediate calculations
.e5c5	68		pla				pla
.e5c6	68		pla				pla
.e5c7					_BFDNext:
.e5c7	88		dey				dey
.e5c8	d0 ab		bne $e575			bne 	_BFDLoop
.e5ca	7a		ply				ply 								; restore Y and exit
.e5cb	4e 72 20	lsr $2072			lsr 	SignCount 					; if sign count odd,
.e5ce	b0 06		bcs $e5d6			bcs		BFUNC_NegateAlways 			; negate the result
.e5d0	60		rts				rts
.e5d1					BFUNC_Negate:
.e5d1	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e5d4	10 24		bpl $e5fa			bpl 	BFNExit
.e5d6					BFUNC_NegateAlways:
.e5d6	38		sec				sec
.e5d7	a9 00		lda #$00			lda 	#0
.e5d9	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.e5dc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e5df	a9 00		lda #$00			lda 	#0
.e5e1	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.e5e4	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e5e7	a9 00		lda #$00			lda 	#0
.e5e9	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.e5ec	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e5ef	a9 00		lda #$00			lda 	#0
.e5f1	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.e5f4	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e5f7	ee 72 20	inc $2072			inc 	SignCount
.e5fa					BFNExit:
.e5fa	60		rts				rts
.e5fb					BFUNC_Modulus:
.e5fb	20 34 e5	jsr $e534			jsr 	BFUNC_Divide 				; start with division.
.e5fe	ad 6e 20	lda $206e			lda 	Temp1+0 					; copy remainder
.e601	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e604	ad 6f 20	lda $206f			lda 	Temp1+1
.e607	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e60a	ad 70 20	lda $2070			lda 	Temp1+2
.e60d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e610	ad 71 20	lda $2071			lda 	Temp1+3
.e613	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e616	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e617					BFUNC_Equals:
.e617	18		clc				clc
.e618	80 01		bra $e61b			bra 	BFUNC_EqualCheck
.e61a					BFUNC_NotEquals:
.e61a	38		sec				sec
.e61b					BFUNC_EqualCheck:
.e61b	08		php				php									; save invert flag
.e61c	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e61f	cd 04 04	cmp $0404			cmp 	evalStack+4
.e622	d0 1c		bne $e640			bne 	COMP_Fail
.e624	ad 01 04	lda $0401			lda 	evalStack+1
.e627	cd 05 04	cmp $0405			cmp 	evalStack+5
.e62a	d0 14		bne $e640			bne 	COMP_Fail
.e62c	ad 02 04	lda $0402			lda 	evalStack+2
.e62f	cd 06 04	cmp $0406			cmp 	evalStack+6
.e632	d0 0c		bne $e640			bne 	COMP_Fail
.e634	ad 03 04	lda $0403			lda 	evalStack+3
.e637	cd 07 04	cmp $0407			cmp 	evalStack+7
.e63a	d0 04		bne $e640			bne 	COMP_Fail
.e63c					COMP_Succeed:
.e63c	a9 ff		lda #$ff			lda 	#$FF
.e63e	80 02		bra $e642			bra 	COMP_SetResult
.e640					COMP_Fail:
.e640	a9 00		lda #$00			lda 	#0 							; here return 0
.e642					COMP_SetResult:
.e642	28		plp				plp 								; but if CS
.e643	90 02		bcc $e647			bcc 	COMP_Accept
.e645	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e647					COMP_Accept:
.e647	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e64a	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e64d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e650	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e653	60		rts				rts
.e654					BFUNC_Less:
.e654	18		clc				clc
.e655	80 01		bra $e658			bra 	BFUNC_LessCheck
.e657					BFUNC_GreaterEqual:
.e657	38		sec				sec
.e658					BFUNC_LessCheck:
.e658	08		php				php
.e659	38		sec				sec
.e65a	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e65d	ed 04 04	sbc $0404			sbc 	evalStack+4
.e660	ad 01 04	lda $0401			lda 	evalStack+1
.e663	ed 05 04	sbc $0405			sbc 	evalStack+5
.e666	ad 02 04	lda $0402			lda 	evalStack+2
.e669	ed 06 04	sbc $0406			sbc 	evalStack+6
.e66c	ad 03 04	lda $0403			lda 	evalStack+3
.e66f	ed 07 04	sbc $0407			sbc 	evalStack+7
.e672	30 c8		bmi $e63c			bmi 	COMP_Succeed
.e674	80 ca		bra $e640			bra 	COMP_Fail
.e676					BFUNC_Greater:
.e676	18		clc				clc
.e677	80 01		bra $e67a			bra 	BFUNC_GreaterCheck
.e679					BFUNC_LessEqual:
.e679	38		sec				sec
.e67a					BFUNC_GreaterCheck:
.e67a	08		php				php
.e67b	38		sec				sec
.e67c	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.e67f	ed 00 04	sbc $0400			sbc 	evalStack+0
.e682	ad 05 04	lda $0405			lda 	evalStack+5
.e685	ed 01 04	sbc $0401			sbc 	evalStack+1
.e688	ad 06 04	lda $0406			lda 	evalStack+6
.e68b	ed 02 04	sbc $0402			sbc 	evalStack+2
.e68e	ad 07 04	lda $0407			lda 	evalStack+7
.e691	ed 03 04	sbc $0403			sbc 	evalStack+3
.e694	30 a6		bmi $e63c			bmi 	COMP_Succeed
.e696	80 a8		bra $e640			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.e698					BFUNC_StringCompare:
.e698	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.e69b	85 26		sta $26				sta 	zTemp1
.e69d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e6a0	85 27		sta $27				sta 	zTemp1+1
.e6a2	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.e6a5	85 28		sta $28				sta 	zTemp2
.e6a7	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.e6aa	85 29		sta $29				sta 	zTemp2+1
.e6ac	a0 00		ldy #$00			ldy 	#0
.e6ae					_BFSCLoop:
.e6ae	b1 26		lda ($26),y			lda 	(zTemp1),y 					; comparison
.e6b0	38		sec				sec
.e6b1	d1 28		cmp ($28),y			cmp 	(zTemp2),y
.e6b3	d0 14		bne $e6c9			bne		_BFSCDifferent 				; return different result.
.e6b5	c8		iny				iny
.e6b6	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.e6b8	d0 f4		bne $e6ae			bne 	_BFSCLoop
.e6ba	a9 00		lda #$00			lda 	#0
.e6bc					_BFSCSetAll:
.e6bc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e6bf	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e6c2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e6c5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e6c8	60		rts				rts
.e6c9					_BFSCDifferent:
.e6c9	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.e6cb	90 ef		bcc $e6bc			bcc 	_BFSCSetAll
.e6cd	a9 00		lda #$00			lda 	#0 							; set all zero
.e6cf	20 bc e6	jsr $e6bc			jsr 	_BFSCSetAll
.e6d2	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.e6d5	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.e6d6					UNARY_Len:
.e6d6	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e6d9	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.e6dc	85 26		sta $26				sta 	zTemp1
.e6de	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e6e1	85 27		sta $27				sta 	zTemp1+1
.e6e3	5a		phy				phy
.e6e4	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.e6e6					_ULGetLength:
.e6e6	b1 26		lda ($26),y			lda 	(zTemp1),y 					; read character
.e6e8	f0 1d		beq $e707			beq 	_ULFoundEOL 				; found end of line.
.e6ea	c8		iny				iny
.e6eb	d0 f9		bne $e6e6			bne 	_ULGetLength 				; scan 256 only.
.e6ed	20 9d e8	jsr $e89d			jsr 	ReportError
>e6f0	43 61 6e 6e 6f 74 20 66				.text 	"Cannot find string end",$00
>e6f8	69 6e 64 20 73 74 72 69 6e 67 20 65 6e 64 00
.e707					_ULFoundEOL:
.e707	98		tya				tya 								; length in A, restore Y
.e708	7a		ply				ply
.e709					UNARY_ReturnByte:
.e709	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e70c	a9 00		lda #$00			lda 	#0 							; clear the rests
.e70e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e711	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e714	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e717	60		rts				rts
.e718					UNARY_Ch:
.e718	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e71b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.e71e	85 26		sta $26				sta 	zTemp1
.e720	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e723	85 27		sta $27				sta 	zTemp1+1
.e725	5a		phy				phy
.e726	a0 00		ldy #$00			ldy 	#0 							; now get first character
.e728	b1 26		lda ($26),y			lda 	(zTemp1),y
.e72a	7a		ply				ply
.e72b	80 dc		bra $e709			bra 	UNARY_ReturnByte 			; return that byte.
.e72d					UNARY_Abs:
.e72d	ea		nop				nop
.e72e	20 71 e1	jsr $e171			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e731	20 d1 e5	jsr $e5d1			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.e734	60		rts				rts
.e735					UNARY_Top:
.e735	ad 6c 20	lda $206c			lda 	highMemory
.e738	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e73b	ad 6d 20	lda $206d			lda 	highMemory+1
.e73e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e741	a9 00		lda #$00			lda 	#0
.e743	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e746	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e749	60		rts				rts
.e74a					UNARY_Rnd:
.e74a	20 55 e7	jsr $e755			jsr 	Random16 					; call 16 bit RNG twice
.e74d	e8		inx				inx
.e74e	e8		inx				inx
.e74f	20 55 e7	jsr $e755			jsr 	Random16
.e752	ca		dex				dex
.e753	ca		dex				dex
.e754	60		rts				rts
.e755					Random16:
.e755	ad 74 20	lda $2074			lda 	RandomSeed 					; initialise if nonzero
.e758	0d 75 20	ora $2075			ora 	RandomSeed+1
.e75b	d0 0d		bne $e76a			bne 	_R16_NoInit
.e75d	ee 74 20	inc $2074			inc 	RandomSeed 					; by setting low to 1
.e760	5a		phy				phy
.e761	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.e763					_R16_Setup:
.e763	20 55 e7	jsr $e755			jsr 	Random16
.e766	88		dey				dey
.e767	d0 fa		bne $e763			bne 	_R16_Setup
.e769	7a		ply				ply
.e76a					_R16_NoInit:
.e76a	4e 75 20	lsr $2075			lsr 	RandomSeed+1				; shift seed right
.e76d	6e 74 20	ror $2074			ror 	RandomSeed
.e770	90 08		bcc $e77a			bcc 	_R16_NoXor
.e772	ad 75 20	lda $2075			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.e775	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.e777	8d 75 20	sta $2075			sta 	RandomSeed+1
.e77a					_R16_NoXor:
.e77a	ad 74 20	lda $2074			lda 	RandomSeed					; copy result to evaluate stack.
.e77d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e780	ad 75 20	lda $2075			lda 	RandomSeed+1
.e783	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e786	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.e787					COMMAND_Run:
.e787	20 1c e8	jsr $e81c			jsr 	COMMAND_Clear 				; clear everything for a new run.
.e78a	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.e78c	a0 22		ldy #$22			ldy 	#BasicProgram >> 8
.e78e	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.e790	84 21		sty $21				sty 	zCurrentLine+1
.e792					CRUNNewLine:
.e792	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.e794	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e796	f0 3e		beq $e7d6			beq 	COMMAND_End 				; if zero, off end of program so stop.
.e798	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.e79a					CRUNNextInstruction:
.e79a	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.e79c	f0 07		beq $e7a5			beq 	CRUNNextLine 				; if zero, then end of line.
.e79e					CRUNNotEndOfLine:
.e79e	c9 8d		cmp #$8d			cmp 	#KW_Colon 					; check for a colon first.
.e7a0	d0 12		bne $e7b4			bne 	CRUNExecuteOne 				; if not that, execute the token.
.e7a2	c8		iny				iny		 							; if colon, skip it and loop round.
.e7a3	80 f5		bra $e79a			bra 	CRUNNextInstruction
.e7a5					CRUNNextLine:
.e7a5	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.e7a7	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e7a9	18		clc				clc
.e7aa	65 20		adc $20				adc 	zCurrentLine
.e7ac	85 20		sta $20				sta 	zCurrentLine
.e7ae	90 e2		bcc $e792			bcc 	CRUNNewLine
.e7b0	e6 21		inc $21				inc 	zCurrentLine+1
.e7b2	80 de		bra $e792			bra 	CRUNNewLine
.e7b4					CRUNExecuteOne:
.e7b4	c8		iny				iny 								; skip over loaded token
.e7b5	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.e7b6	8d 6f 20	sta $206f			sta 	Temp1+1 					; this is the low byte into the KVT
.e7b9	8a		txa				txa
.e7ba	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e7bc	8d 70 20	sta $2070			sta 	Temp1+2
.e7bf	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.e7c1	8d 6e 20	sta $206e			sta 	Temp1+0
.e7c4	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.e7c6	8d 73 20	sta $2073			sta 	StringBufferPos
.e7c9	20 6e 20	jsr $206e			jsr 	Temp1 						; call instruction
.e7cc	80 cc		bra $e79a			bra 	CRUNNextInstruction 		; do next instruction.
.e7ce					COMMAND_Stop:
.e7ce	20 9d e8	jsr $e89d			jsr 	ReportError
>e7d1	53 74 6f 70 00					.text 	"Stop",$00
.e7d6					COMMAND_End:
>e7d6	02						.byte 	2
.e7d7	4c 92 e8	jmp $e892			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.e7da					COMMAND_Assert:
.e7da	20 75 e1	jsr $e175			jsr 	EvaluateBase 				; evaluate the expression
.e7dd	ea		nop				nop
.e7de	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.e7e1	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e7e4	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.e7e7	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e7ea	d0 12		bne $e7fe			bne 	_CMDAExit
.e7ec	ea		nop				nop
.e7ed	20 9d e8	jsr $e89d			jsr 	ReportError
>e7f0	41 73 73 65 72 74 20 66				.text 	"Assert failed",$00
>e7f8	61 69 6c 65 64 00
.e7fe					_CMDAExit:
.e7fe	60		rts				rts
.e7ff					COMMAND_Rem:
.e7ff	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.e801	f0 05		beq $e808			beq 	_CREMExit 					; End of line, then exit.
.e803	c8		iny				iny 								; something to skip
.e804	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; if not a colon
.e806	d0 f7		bne $e7ff			bne 	COMMAND_Rem 				; keep searching
.e808					_CREMExit:
.e808	60		rts				rts
.e809					COMMAND_New:
.e809	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.e80b	8d 00 22	sta $2200			sta 	BasicProgram 				; by zeroing the initial offset.
.e80e	20 1c e8	jsr $e81c			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.e811	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.e813	8d 6c 20	sta $206c			sta 	HighMemory
.e816	a9 80		lda #$80			lda 	#endMemory >> 8
.e818	8d 6d 20	sta $206d			sta 	HighMemory+1
.e81b	60		rts				rts
.e81c					COMMAND_Clear:
.e81c	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.e81e					_CCClearVar:
.e81e	a9 00		lda #$00			lda 	#$00
.e820	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.e823	e8		inx				inx
.e824	e0 6c		cpx #$6c			cpx 	#27*4
.e826	10 f6		bpl $e81e			bpl 	_CCClearVar
.e828	a9 00		lda #$00			lda 	#basicStack & $FF 			; reset BASIC stack
.e82a	85 22		sta $22				sta 	zBasicStack
.e82c	a9 02		lda #$02			lda 	#basicStack >> 8
.e82e	85 23		sta $23				sta 	zBasicStack+1
.e830	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.e832	85 24		sta $24				sta 	zLowMemory
.e834	a9 22		lda #$22			lda 	#BasicProgram >> 8
.e836	85 25		sta $25				sta 	zLowMemory+1
.e838					_CCFindEnd:
.e838	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.e83a	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.e83c	f0 0b		beq $e849			beq 	_CCFoundEnd
.e83e	18		clc				clc 								; go to next line.
.e83f	65 24		adc $24				adc 	zLowMemory
.e841	85 24		sta $24				sta 	zLowMemory
.e843	90 f3		bcc $e838			bcc 	_CCFindEnd
.e845	e6 25		inc $25				inc 	zLowMemory+1
.e847	80 ef		bra $e838			bra 	_CCFindEnd
.e849					_CCFoundEnd:
.e849	e6 24		inc $24				inc 	zLowMemory 					; variables etc. start after end of program.
.e84b	d0 02		bne $e84f			bne 	_CCNoCarry 					; skip over zero end offset.
.e84d	e6 25		inc $25				inc 	zLowMemory+1
.e84f					_CCNoCarry:
.e84f	60		rts				rts
.e850					COMMAND_Old:
.e850	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.e852	85 24		sta $24				sta 	zLowMemory
.e854	a9 22		lda #$22			lda 	#BasicProgram >> 8
.e856	85 25		sta $25				sta 	zLowMemory+1
.e858	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.e85a					_COScan:
.e85a	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; look at next byte pair
.e85c	c8		iny				iny
.e85d	f0 0d		beq $e86c			beq 	_COFail 					; can't find marker, corrupted maybe ?
.e85f	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.e861	d0 f7		bne $e85a			bne 	_COScan
.e863	98		tya				tya 								; Y is the new offset to the next instruction
.e864	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.e866	91 24		sta ($24),y			sta 	(zLowMemory),y
.e868	20 1c e8	jsr $e81c			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.e86b	60		rts				rts
.e86c					_COFail:
.e86c	20 9d e8	jsr $e89d			jsr 	ReportError
>e86f	43 61 6e 6e 6f 74 20 72				.text 	"Cannot recover program",$00
>e877	65 63 6f 76 65 72 20 70 72 6f 67 72 61 6d 00

;******  Return to file: basic.asm

.e886					Start:
.e886	20 7f a0	jsr $a07f			jsr 	IOInitialise 				; set up porting stuff.
.e889	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.e88b	9a		txs			txs
.e88c	20 09 e8	jsr $e809			jsr 	COMMAND_New 				; do a new
.e88f	20 50 e8	jsr $e850			jsr 	COMMAND_Old 				; get back the old program as we're deving.
.e892					WarmStart:
.e892	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.e894	9a		txs			txs
.e895	4c 87 e7	jmp $e787			jmp 	COMMAND_Run 				; RUN current program.
.e898					SyntaxError:
.e898	a9 01		lda #$01			lda 	#1
.e89a	ea		nop				nop
.e89b	80 fb		bra $e898			bra 	SyntaxError
.e89d					ReportError:
.e89d	a9 02		lda #$02			lda 	#2
.e89f	ea		nop				nop
.e8a0	80 fb		bra $e89d			bra 	ReportError

;******  Processing file: include/basic_generated.inc

>2200	0a 01 00 97 20 42 80 31			.byte $0a,$01,$00,$97,$20,$42,$80,$31,$32,$00,$00
>2208	32 00 00

;******  Return to file: basic.asm


;******  End of listing
