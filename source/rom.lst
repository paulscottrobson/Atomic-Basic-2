
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D TARGET=2 -b -L rom.lst -o rom.bin basic.asm
; Thu Aug  1 21:40:06 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	ea f1						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_6502.asm

>0000	00					.byte 	0
=80					EXTWidth = 80 								; screen width
=25					EXTHeight = 25 								; screen height
=$0800					EXTLowMemory = $0800 						; Workspace RAM starts here
=$6000					EXTHighMemory = $6000 						; Workspace RAM ends here
=$b000					PScreen = $B000								; 2k screen RAM here
=$b800					PKeyboard = $B800							; Keyboard port.
=$b801					PBreak = $B801 								; Break key.
.a000					EXTStartPersonalise:
.a000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.a002	9a		txs			txs
.a003	20 8e a0	jsr $a08e		jsr 	EXTReset 						; reset video
.a006	20 38 a0	jsr $a038		jsr 	EXTClearScreen 					; clear screen
.a009	4c ea f1	jmp $f1ea		jmp 	Start 							; start main application
.a00c					EXTReadKeyPort:
.a00c	ad 00 b8	lda $b800		lda 	PKeyboard							; read key
.a00f	09 00		ora #$00		ora 	#0
.a011	60		rts			rts
.a012					EXTRemoveKeyPressed:
.a012	48		pha			pha 										; key pressed clear queue byte.
.a013	a9 00		lda #$00		lda 	#0
.a015	8d 00 b8	sta $b800		sta 	PKeyboard
.a018	68		pla			pla
.a019	60		rts			rts
.a01a					EXTCheckBreak:
.a01a	ad 01 b8	lda $b801		lda 	PBreak
.a01d	60		rts			rts
.a01e					EXTReadScreen:
.a01e	5a		phy			phy 										; save Y
.a01f	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.a021	98		tya			tya
.a022	09 b0		ora #$b0		ora 	#PScreen>>8 						; move into screen area
.a024	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.a026	a0 00		ldy #$00		ldy 	#0
.a028	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a02a	7a		ply			ply 										; restore Y and exit.
.a02b	60		rts			rts
.a02c					EXTWriteScreen:
.a02c	5a		phy			phy
.a02d	48		pha			pha
.a02e	20 1e a0	jsr $a01e		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.a031	a0 00		ldy #$00		ldy 	#0
.a033	68		pla			pla 										; restore and write.
.a034	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a036	7a		ply			ply
.a037	60		rts			rts
.a038					EXTClearScreen:
.a038	48		pha			pha 										; save registers
.a039	da		phx			phx
.a03a	a2 00		ldx #$00		ldx 	#0
.a03c					_EXTCSLoop:
.a03c	a9 20		lda #$20		lda 	#32
.a03e	9d 00 b0	sta $b000,x		sta 	PScreen+0,x
.a041	9d 00 b1	sta $b100,x		sta 	PScreen+$100,x
.a044	9d 00 b2	sta $b200,x		sta 	PScreen+$200,x
.a047	9d 00 b3	sta $b300,x		sta 	PScreen+$300,x
.a04a	9d 00 b4	sta $b400,x		sta 	PScreen+$400,x
.a04d	9d 00 b5	sta $b500,x		sta 	PScreen+$500,x
.a050	9d 00 b6	sta $b600,x		sta 	PScreen+$600,x
.a053	9d 00 b7	sta $b700,x		sta 	PScreen+$700,x
.a056	e8		inx			inx
.a057	d0 e3		bne $a03c		bne 	_EXTCSLoop
.a059	fa		plx			plx 										; restore
.a05a	68		pla			pla
.a05b	60		rts			rts
.a05c					EXTScrollDisplay:
.a05c	48		pha			pha 										; save registers
.a05d	5a		phy			phy
.a05e	a9 00		lda #$00		lda 	#PScreen & $FF 					; set pointer to screen
.a060	85 04		sta $04			sta 	EXTZPWork+0
.a062	a9 b0		lda #$b0		lda 	#PScreen >> 8
.a064	85 05		sta $05			sta 	EXTZPWork+1
.a066					_EXTScroll:
.a066	a0 50		ldy #$50		ldy 	#EXTWidth
.a068	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a06a	a0 00		ldy #$00		ldy 	#0
.a06c	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a06e	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.a070	d0 02		bne $a074		bne 	_EXTNoCarry
.a072	e6 05		inc $05			inc 	EXTZPWork+1
.a074					_EXTNoCarry:
.a074	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.a076	c9 80		cmp #$80		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) & $FF
.a078	d0 ec		bne $a066		bne 	_EXTScroll
.a07a	a5 05		lda $05			lda 	EXTZPWork+1
.a07c	c9 b7		cmp #$b7		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) >> 8
.a07e	d0 e6		bne $a066		bne 	_EXTScroll
.a080	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.a082					_EXTLastLine:
.a082	a9 20		lda #$20		lda 	#32
.a084	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a086	c8		iny			iny
.a087	c0 50		cpy #$50		cpy 	#EXTWidth
.a089	d0 f7		bne $a082		bne 	_EXTLastLine
.a08b	7a		ply			ply 										; restore and exit.
.a08c	68		pla			pla
.a08d	60		rts			rts
.a08e					EXTReset:
.a08e	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm

.2300					IncludeBasicCode:

;******  Processing file: include/basic_generated.inc

>2300	19 01 00 4d 93 a6 8e 4d			.byte $19,$01,$00,$4d,$93,$a6,$8e,$4d,$96,$34,$37,$93,$82,$34,$37,$8e,$4d,$96,$34,$37,$93,$83,$35,$33,$00,$1b,$02,$00,$b0,$81,$4d,$20,$53,$45,$54,$20,$55,$50,$20,$56,$49,$43,$20,$49,$56,$20,$49,$4e,$49,$54,$81,$00,$05,$03,$00,$b7,$00,$00
>2308	96 34 37 93 82 34 37 8e 4d 96 34 37 93 83 35 33
>2318	00 1b 02 00 b0 81 4d 20 53 45 54 20 55 50 20 56
>2328	49 43 20 49 56 20 49 4e 49 54 81 00 05 03 00 b7
>2338	00 00
.233a					StartBehaviour:
>233a	52					.text "R"

;******  Return to file: basic.asm

.233b					EndBasicCode:

;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	c5 e8					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	62 e1					.word	SyntaxError                   ; """        ($0081)
>e004	62 e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	ba e8					.word	BFUNC_String                  ; "$"        ($0083)
>e008	84 ea					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	cc e8					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	62 e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	62 e1					.word	SyntaxError                   ; "("        ($0087)
>e010	62 e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	a0 ea					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	6e e8					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	62 e1					.word	SyntaxError                   ; ","        ($008b)
>e018	94 e8					.word	BFUNC_Subtract                ; "-"        ($008c)
>e01a	bc e9					.word	BFUNC_Divide                  ; "/"        ($008d)
>e01c	62 e1					.word	SyntaxError                   ; ":"        ($008e)
>e01e	62 e1					.word	SyntaxError                   ; ";"        ($008f)
>e020	9d e9					.word	BFUNC_LessEqual               ; "<="       ($0090)
>e022	3e e9					.word	BFUNC_NotEquals               ; "<>"       ($0091)
>e024	78 e9					.word	BFUNC_Less                    ; "<"        ($0092)
>e026	3b e9					.word	BFUNC_Equals                  ; "="        ($0093)
>e028	7b e9					.word	BFUNC_GreaterEqual            ; ">="       ($0094)
>e02a	9a e9					.word	BFUNC_Greater                 ; ">"        ($0095)
>e02c	be e8					.word	BFUNC_ByteInd                 ; "?"        ($0096)
>e02e	16 e9					.word	BFUNC_Xor                     ; "^"        ($0097)
>e030	88 ef					.word	COMMAND_Assert                ; "assert"   ($0098)
>e032	8f eb					.word	UNARY_Abs                     ; "abs"      ($0099)
>e034	cf ef					.word	COMMAND_Clear                 ; "clear"    ($009a)
>e036	53 f1					.word	COMMAND_CLS                   ; "cls"      ($009b)
>e038	1b ec					.word	UNARY_CPU                     ; "cpu"      ($009c)
>e03a	7a eb					.word	UNARY_Ch                      ; "ch"       ($009d)
>e03c	2e ec					.word	COMMAND_Dim                   ; "dim"      ($009e)
>e03e	b7 ec					.word	COMMAND_Do                    ; "do"       ($009f)
>e040	d5 ed					.word	COMMAND_ELSE                  ; "else"     ($00a0)
>e042	df f1					.word	COMMAND_End                   ; "end"      ($00a1)
>e044	62 e1					.word	SyntaxError                   ; "for"      ($00a2)
>e046	44 ed					.word	COMMAND_Gosub                 ; "gosub"    ($00a3)
>e048	31 ed					.word	COMMAND_Goto                  ; "goto"     ($00a4)
>e04a	ac eb					.word	UNARY_Get                     ; "get"      ($00a5)
>e04c	06 ec					.word	UNARY_IOAddr                  ; "ioaddr"   ($00a6)
>e04e	62 e1					.word	SyntaxError                   ; "input"    ($00a7)
>e050	a3 ed					.word	COMMAND_IF                    ; "if"       ($00a8)
>e052	e8 ee					.word	COMMAND_List                  ; "list"     ($00a9)
>e054	62 e1					.word	SyntaxError                   ; "link"     ($00aa)
>e056	de ed					.word	COMMAND_Let                   ; "let"      ($00ab)
>e058	38 eb					.word	UNARY_Len                     ; "len"      ($00ac)
>e05a	62 e1					.word	SyntaxError                   ; "next"     ($00ad)
>e05c	b6 ef					.word	COMMAND_NewExec               ; "new"      ($00ae)
>e05e	05 f0					.word	COMMAND_OldExec               ; "old"      ($00af)
>e060	45 f0					.word	COMMAND_Print                 ; "print"    ($00b0)
>e062	b6 eb					.word	UNARY_Page                    ; "page"     ($00b1)
>e064	50 ed					.word	COMMAND_Return                ; "return"   ($00b2)
>e066	ac ef					.word	COMMAND_Rem                   ; "rem"      ($00b3)
>e068	56 f1					.word	COMMAND_Run                   ; "run"      ($00b4)
>e06a	41 f0					.word	COMMAND_RST                   ; "rst"      ($00b5)
>e06c	c9 eb					.word	UNARY_Rnd                     ; "rnd"      ($00b6)
>e06e	d7 f1					.word	COMMAND_Stop                  ; "stop"     ($00b7)
>e070	62 e1					.word	SyntaxError                   ; "step"     ($00b8)
>e072	c1 ed					.word	COMMAND_THEN                  ; "then"     ($00b9)
>e074	97 eb					.word	UNARY_Top                     ; "top"      ($00ba)
>e076	62 e1					.word	SyntaxError                   ; "to"       ($00bb)
>e078	bd ec					.word	COMMAND_Until                 ; "until"    ($00bc)
>e07a	f1 e8					.word	BFUNC_Or                      ; "|"        ($00bd)
>e07c	f7 ea					.word	BFUNC_StringCompare           ; "~"        ($00be)
.e07e					TokenText:
>e07e	a1					.byte $a1                             ; $0080 !
>e07f	a2					.byte $a2                             ; $0081 "
>e080	a3					.byte $a3                             ; $0082 #
>e081	a4					.byte $a4                             ; $0083 $
>e082	a5					.byte $a5                             ; $0084 %
>e083	a6					.byte $a6                             ; $0085 &
>e084	a7					.byte $a7                             ; $0086 '
>e085	a8					.byte $a8                             ; $0087 (
>e086	a9					.byte $a9                             ; $0088 )
>e087	aa					.byte $aa                             ; $0089 *
>e088	ab					.byte $ab                             ; $008a +
>e089	ac					.byte $ac                             ; $008b ,
>e08a	ad					.byte $ad                             ; $008c -
>e08b	af					.byte $af                             ; $008d /
>e08c	ba					.byte $ba                             ; $008e :
>e08d	bb					.byte $bb                             ; $008f ;
>e08e	3c bd					.byte $3c,$bd                         ; $0090 <=
>e090	3c be					.byte $3c,$be                         ; $0091 <>
>e092	bc					.byte $bc                             ; $0092 <
>e093	bd					.byte $bd                             ; $0093 =
>e094	3e bd					.byte $3e,$bd                         ; $0094 >=
>e096	be					.byte $be                             ; $0095 >
>e097	bf					.byte $bf                             ; $0096 ?
>e098	de					.byte $de                             ; $0097 ^
>e099	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0098 assert
>e09f	41 42 d3				.byte $41,$42,$d3                     ; $0099 abs
>e0a2	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $009a clear
>e0a7	43 4c d3				.byte $43,$4c,$d3                     ; $009b cls
>e0aa	43 50 d5				.byte $43,$50,$d5                     ; $009c cpu
>e0ad	43 c8					.byte $43,$c8                         ; $009d ch
>e0af	44 49 cd				.byte $44,$49,$cd                     ; $009e dim
>e0b2	44 cf					.byte $44,$cf                         ; $009f do
>e0b4	45 4c 53 c5				.byte $45,$4c,$53,$c5                 ; $00a0 else
>e0b8	45 4e c4				.byte $45,$4e,$c4                     ; $00a1 end
>e0bb	46 4f d2				.byte $46,$4f,$d2                     ; $00a2 for
>e0be	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $00a3 gosub
>e0c3	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $00a4 goto
>e0c7	47 45 d4				.byte $47,$45,$d4                     ; $00a5 get
>e0ca	49 4f 41 44 44 d2			.byte $49,$4f,$41,$44,$44,$d2         ; $00a6 ioaddr
>e0d0	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a7 input
>e0d5	49 c6					.byte $49,$c6                         ; $00a8 if
>e0d7	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a9 list
>e0db	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00aa link
>e0df	4c 45 d4				.byte $4c,$45,$d4                     ; $00ab let
>e0e2	4c 45 ce				.byte $4c,$45,$ce                     ; $00ac len
>e0e5	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00ad next
>e0e9	4e 45 d7				.byte $4e,$45,$d7                     ; $00ae new
>e0ec	4f 4c c4				.byte $4f,$4c,$c4                     ; $00af old
>e0ef	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00b0 print
>e0f4	50 41 47 c5				.byte $50,$41,$47,$c5                 ; $00b1 page
>e0f8	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce         ; $00b2 return
>e0fe	52 45 cd				.byte $52,$45,$cd                     ; $00b3 rem
>e101	52 55 ce				.byte $52,$55,$ce                     ; $00b4 run
>e104	52 53 d4				.byte $52,$53,$d4                     ; $00b5 rst
>e107	52 4e c4				.byte $52,$4e,$c4                     ; $00b6 rnd
>e10a	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00b7 stop
>e10e	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00b8 step
>e112	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b9 then
>e116	54 4f d0				.byte $54,$4f,$d0                     ; $00ba top
>e119	54 cf					.byte $54,$cf                         ; $00bb to
>e11b	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc             ; $00bc until
>e120	fc					.byte $fc                             ; $00bd |
>e121	fe					.byte $fe                             ; $00be ~
>e122	00					.byte $00
.e123					TokenTypeInformation:
>e123	04					.byte $04                             ; $0080 !
>e124	0a					.byte $0a                             ; $0081 "
>e125	0a					.byte $0a                             ; $0082 #
>e126	04					.byte $04                             ; $0083 $
>e127	03					.byte $03                             ; $0084 %
>e128	00					.byte $00                             ; $0085 &
>e129	0a					.byte $0a                             ; $0086 '
>e12a	0a					.byte $0a                             ; $0087 (
>e12b	0a					.byte $0a                             ; $0088 )
>e12c	03					.byte $03                             ; $0089 *
>e12d	02					.byte $02                             ; $008a +
>e12e	0a					.byte $0a                             ; $008b ,
>e12f	02					.byte $02                             ; $008c -
>e130	03					.byte $03                             ; $008d /
>e131	0a					.byte $0a                             ; $008e :
>e132	0a					.byte $0a                             ; $008f ;
>e133	01					.byte $01                             ; $0090 <=
>e134	01					.byte $01                             ; $0091 <>
>e135	01					.byte $01                             ; $0092 <
>e136	01					.byte $01                             ; $0093 =
>e137	01					.byte $01                             ; $0094 >=
>e138	01					.byte $01                             ; $0095 >
>e139	04					.byte $04                             ; $0096 ?
>e13a	00					.byte $00                             ; $0097 ^
>e13b	08					.byte $08                             ; $0098 assert
>e13c	09					.byte $09                             ; $0099 abs
>e13d	08					.byte $08                             ; $009a clear
>e13e	08					.byte $08                             ; $009b cls
>e13f	09					.byte $09                             ; $009c cpu
>e140	09					.byte $09                             ; $009d ch
>e141	08					.byte $08                             ; $009e dim
>e142	08					.byte $08                             ; $009f do
>e143	08					.byte $08                             ; $00a0 else
>e144	08					.byte $08                             ; $00a1 end
>e145	08					.byte $08                             ; $00a2 for
>e146	08					.byte $08                             ; $00a3 gosub
>e147	08					.byte $08                             ; $00a4 goto
>e148	09					.byte $09                             ; $00a5 get
>e149	09					.byte $09                             ; $00a6 ioaddr
>e14a	08					.byte $08                             ; $00a7 input
>e14b	08					.byte $08                             ; $00a8 if
>e14c	08					.byte $08                             ; $00a9 list
>e14d	08					.byte $08                             ; $00aa link
>e14e	08					.byte $08                             ; $00ab let
>e14f	09					.byte $09                             ; $00ac len
>e150	08					.byte $08                             ; $00ad next
>e151	08					.byte $08                             ; $00ae new
>e152	08					.byte $08                             ; $00af old
>e153	08					.byte $08                             ; $00b0 print
>e154	09					.byte $09                             ; $00b1 page
>e155	08					.byte $08                             ; $00b2 return
>e156	08					.byte $08                             ; $00b3 rem
>e157	08					.byte $08                             ; $00b4 run
>e158	08					.byte $08                             ; $00b5 rst
>e159	09					.byte $09                             ; $00b6 rnd
>e15a	08					.byte $08                             ; $00b7 stop
>e15b	08					.byte $08                             ; $00b8 step
>e15c	08					.byte $08                             ; $00b9 then
>e15d	09					.byte $09                             ; $00ba top
>e15e	08					.byte $08                             ; $00bb to
>e15f	08					.byte $08                             ; $00bc until
>e160	00					.byte $00                             ; $00bd |
>e161	01					.byte $01                             ; $00be ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_COMMA = $008b
=$008c					KW_MINUS = $008c
=$008d					KW_FSLASH = $008d
=$008e					KW_COLON = $008e
=$008f					KW_SEMICOLON = $008f
=$0090					KW_LESSEQUAL = $0090
=$0091					KW_LESSGREATER = $0091
=$0092					KW_LESS = $0092
=$0093					KW_EQUAL = $0093
=$0094					KW_GREATEREQUAL = $0094
=$0095					KW_GREATER = $0095
=$0096					KW_QUESTION = $0096
=$0097					KW_HAT = $0097
=$0098					KW_ASSERT = $0098
=$0099					KW_ABS = $0099
=$009a					KW_CLEAR = $009a
=$009b					KW_CLS = $009b
=$009c					KW_CPU = $009c
=$009d					KW_CH = $009d
=$009e					KW_DIM = $009e
=$009f					KW_DO = $009f
=$00a0					KW_ELSE = $00a0
=$00a1					KW_END = $00a1
=$00a2					KW_FOR = $00a2
=$00a3					KW_GOSUB = $00a3
=$00a4					KW_GOTO = $00a4
=$00a5					KW_GET = $00a5
=$00a6					KW_IOADDR = $00a6
=$00a7					KW_INPUT = $00a7
=$00a8					KW_IF = $00a8
=$00a9					KW_LIST = $00a9
=$00aa					KW_LINK = $00aa
=$00ab					KW_LET = $00ab
=$00ac					KW_LEN = $00ac
=$00ad					KW_NEXT = $00ad
=$00ae					KW_NEW = $00ae
=$00af					KW_OLD = $00af
=$00b0					KW_PRINT = $00b0
=$00b1					KW_PAGE = $00b1
=$00b2					KW_RETURN = $00b2
=$00b3					KW_REM = $00b3
=$00b4					KW_RUN = $00b4
=$00b5					KW_RST = $00b5
=$00b6					KW_RND = $00b6
=$00b7					KW_STOP = $00b7
=$00b8					KW_STEP = $00b8
=$00b9					KW_THEN = $00b9
=$00ba					KW_TOP = $00ba
=$00bb					KW_TO = $00bb
=$00bc					KW_UNTIL = $00bc
=$00bd					KW_BAR = $00bd
=$00be					KW_TILDE = $00be

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e162					SyntaxError:
.e162	20 72 e1	jsr $e172			jsr 	ReportError
>e165	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e16d	52 52 4f 52 00
.e172					ReportError:
.e172	fa		plx				plx
.e173	7a		ply				ply
.e174	e8		inx				inx
.e175	d0 01		bne $e178			bne 	_REPrint
.e177	c8		iny				iny
.e178					_REPrint:
.e178	20 b4 e4	jsr $e4b4			jsr 	SIOPrintString
.e17b	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e17d	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e17f	f0 13		beq $e194			beq 	_RENoLineNumber
.e181	a2 9c		ldx #$9c			ldx 	#_REAt & $FF
.e183	a0 e1		ldy #$e1			ldy 	#_REAt >> 8
.e185	20 b4 e4	jsr $e4b4			jsr 	SIOPrintString
.e188	a0 01		ldy #$01			ldy 	#1
.e18a	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e18c	aa		tax				tax
.e18d	c8		iny				iny
.e18e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e190	a8		tay				tay
.e191	20 a1 e1	jsr $e1a1			jsr 	PrintWordInteger
.e194					_RENoLineNumber:
.e194	a9 0d		lda #$0d			lda 	#13
.e196	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.e199	4c 23 f2	jmp $f223			jmp 	WarmStart
>e19c	20 41 54 20 00			_REAt:	.text 	" AT ",0
.e1a1					PrintWordInteger:
.e1a1	8a		txa				txa
.e1a2	a2 00		ldx #$00			ldx 	#0
.e1a4	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1a7	98		tya				tya
.e1a8	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1ab	c8		iny				iny
.e1ac	a9 00		lda #$00			lda 	#0
.e1ae	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e1b1	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e1b4	20 1b f1	jsr $f11b			jsr 	CPRPrintInteger
.e1b7	60		rts				rts
.e1b8					CheckNextCharacter:
.e1b8	8d c0 20	sta $20c0			sta 	Temp1 						; save character to check
.e1bb					_CNCLoop:
.e1bb	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e1bd	f0 0b		beq $e1ca			beq 	_CNCFail 					; end of line, so no character
.e1bf	c8		iny				iny
.e1c0	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e1c2	f0 f7		beq $e1bb			beq 	_CNCLoop
.e1c4	cd c0 20	cmp $20c0			cmp 	Temp1 						; fail if not what was wanted
.e1c7	d0 01		bne $e1ca			bne 	_CNCFail
.e1c9	60		rts				rts
.e1ca					_CNCFail:
.e1ca	20 72 e1	jsr $e172			jsr 	ReportError
>e1cd	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e1d5	54 4f 4b 45 4e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e1db							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0024					zTemp1:			.word 	?					; temporary vars
>0026					zTemp2:			.word 	?
>0028					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>20be					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>20c0					Temp1:			.dword	?					; 4 byte temporary stores.
>20c4					SignCount:		.byte 	? 					; count of signs in divide.
>20c5					StringBufferPos:.byte 	? 					; next free slot in string buffer
>20c6					RandomSeed 		.word 	? 					; Random Number
>20c8					xCursor 		.byte 	? 					; cursor position
>20c9					yCursor 		.byte 	?
>20ca					breakCheckCount	.byte 	?					; how often check for break.
>20cb					basicStackIndex	.byte 	? 					; index into Basic Stack.
>20cc					registers		.fill 	5 					; A X Y Z P registers in/out for LINK.
>20d1									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e1db					EvaluateSNError:
.e1db	4c 62 e1	jmp $e162			jmp 	SyntaxError
.e1de					EvaluateMissingQuote:
.e1de	20 72 e1	jsr $e172			jsr 	ReportError
>e1e1	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e1e9	51 55 4f 54 45 00
.e1ef					EvaluateStringFull:
.e1ef	20 72 e1	jsr $e172			jsr 	ReportError
>e1f2	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e1fa	55 46 46 45 52 20 46 55 4c 4c 00
.e205					EvaluateBadHex:
.e205	20 72 e1	jsr $e172			jsr 	ReportError
>e208	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e210					EvaluateAtomCurrentLevel:
.e210	a9 07		lda #$07			lda 	#7
.e212	80 04		bra $e218			bra 	EvaluateAtPrecedenceLevel
.e214					EvaluateBase:
.e214	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e216					EvaluateBaseCurrentLevel:
.e216	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e218					EvaluateAtPrecedenceLevel:
.e218	48		pha				pha 								; save precedence level
.e219	a9 00		lda #$00			lda 	#0 							; zero the result.
.e21b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e21e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e221	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e224	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e227					_EVALSkipSpace1:
.e227	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e229	f0 b0		beq $e1db			beq 	EvaluateSNError 			; end of line, without token.
.e22b	c8		iny				iny
.e22c	c9 20		cmp #$20			cmp 	#32
.e22e	f0 f7		beq $e227			beq 	_EVALSkipSpace1
.e230	88		dey				dey 								; points at the token.
.e231	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e233	f0 14		beq $e249			beq 	_EVALString  				; if so load in a constant string
.e235	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e237	f0 36		beq $e26f			beq 	_EVALHexadecimal
.e239	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e23b	90 04		bcc $e241			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e23d	c9 3a		cmp #$3a			cmp 	#'9'+1
.e23f	90 03		bcc $e244			bcc 	_EVALDecimal
.e241					_EVALGoKeywordVariable:
.e241	4c c6 e2	jmp $e2c6			jmp 	_EVALKeywordVariable
.e244					_EVALDecimal:
.e244	20 23 e3	jsr $e323			jsr 	EVALGetDecConstant 			; get decimal constant
.e247	80 34		bra $e27d			bra 	_EVALGotAtom 				; got atom.
.e249					_EVALString:
.e249	da		phx				phx 								; save X on stack
.e24a	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e24c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e24f	ad c5 20	lda $20c5			lda 	StringBufferPos 			; X = Buffer Position.
.e252	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e255	aa		tax				tax 								; put in X to build the string.
.e256	c8		iny				iny 								; skip over opening quote character
.e257					_EVALStringCopy:
.e257	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e259	c8		iny				iny
.e25a	f0 82		beq $e1de			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e25c	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e25f	e8		inx				inx 								; and bump that pointer.
.e260	f0 8d		beq $e1ef			beq 	EvaluateStringFull 			; buffer is full.
.e262	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e264	d0 f1		bne $e257			bne 	_EVALStringCopy
.e266	8e c5 20	stx $20c5			stx 	StringBufferPos 			; this is the new next free slot.
.e269	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e26c	fa		plx				plx 								; restore X
.e26d	80 0e		bra $e27d			bra 	_EVALGotAtom 				; got the atom.
.e26f					_EVALHexaDecimal
.e26f	c8		iny				iny 								; skip over the '#'
.e270	5a		phy				phy 								; save Y
.e271	20 8f e3	jsr $e38f			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e274	8c c0 20	sty $20c0			sty 	Temp1 						; has Y changed ?
.e277	68		pla				pla
.e278	cd c0 20	cmp $20c0			cmp 	Temp1
.e27b	f0 88		beq $e205			beq 	EvaluateBadHex 				; if not, error.
.e27d					_EVALGotAtom:
.e27d					_EVALGetOperator:
.e27d	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e27f	c8		iny				iny 								; this should be binary operator
.e280	c9 20		cmp #$20			cmp 	#$20
.e282	f0 f9		beq $e27d			beq 	_EVALGetOperator
.e284	88		dey				dey
.e285	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e287	10 3b		bpl $e2c4			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e289	da		phx				phx 								; save X
.e28a	aa		tax				tax 								; token in X
.e28b	bd a3 e0	lda $e0a3,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e28e	8d c0 20	sta $20c0			sta 	Temp1 						; save precedence in Temp1
.e291	fa		plx				plx 								; restore X
.e292	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e294	b0 2e		bcs $e2c4			bcs 	_EVALExitPullA
.e296	68		pla				pla 								; get and save precedence level.
.e297	48		pha				pha
.e298	cd c0 20	cmp $20c0			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e29b	f0 02		beq $e29f			beq 	_EVALDoCalc					; equal, do it.
.e29d	b0 25		bcs $e2c4			bcs 	_EVALExitPullA				; too high, then exit.
.e29f					_EVALDoCalc:
.e29f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e2a1	c8		iny				iny
.e2a2	48		pha				pha
.e2a3	da		phx				phx
.e2a4	e8		inx				inx 								; work out right hand side.
.e2a5	e8		inx				inx
.e2a6	e8		inx				inx
.e2a7	e8		inx				inx
.e2a8	ad c0 20	lda $20c0			lda 	Temp1 						; get current operator precedence level.
.e2ab	1a		inc a				inc 	a 							; so work it out at the next level.
.e2ac	20 18 e2	jsr $e218			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e2af	fa		plx				plx 								; fix X back.
.e2b0	68		pla				pla 								; get keyword
.e2b1					_EVALExecuteA:
.e2b1	0a		asl a				asl 	a 							; shift left, drop bit 7
.e2b2	8d c1 20	sta $20c1			sta 	Temp1+1						; save in Temp1.1
.e2b5	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e2b7	8d c2 20	sta $20c2			sta 	Temp1+2 					; set at Temp1.2
.e2ba	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e2bc	8d c0 20	sta $20c0			sta 	Temp1+0
.e2bf	20 c0 20	jsr $20c0			jsr 	Temp1 						; call that routine.
.e2c2	80 b9		bra $e27d			bra 	_EVALGotAtom 				; and loop back again.
.e2c4					_EVALExitPullA:
.e2c4	68		pla				pla 								; restore precedence.
.e2c5	60		rts				rts
.e2c6					_EVALKeywordVariable:
.e2c6	09 00		ora #$00			ora 	#0 							; check bit 7
.e2c8	10 0f		bpl $e2d9			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e2ca	da		phx				phx
.e2cb	aa		tax				tax
.e2cc	bd a3 e0	lda $e0a3,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e2cf	fa		plx				plx
.e2d0	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e2d2	d0 05		bne $e2d9			bne 	_EVALNotUnaryFunction
.e2d4	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e2d6	c8		iny				iny 								; consume it
.e2d7	80 d8		bra $e2b1			bra 	_EVALExecuteA 				; execute TOS.
.e2d9					_EVALNotUnaryFunction:
.e2d9	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e2db	10 3d		bpl $e31a			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e2dd	c9 8c		cmp #$8c			cmp 	#KW_MINUS 					; check negation
.e2df	f0 0f		beq $e2f0			beq 	_EVALUnaryNegation
.e2e1	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e2e3	d0 14		bne $e2f9			bne		_EVALCheckUnaryOperator
.e2e5	c8		iny				iny 								; skip left bracket.
.e2e6	20 16 e2	jsr $e216			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e2e9	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e2eb	20 b8 e1	jsr $e1b8			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e2ee	80 8d		bra $e27d			bra 	_EVALGotAtom
.e2f0					_EVALUnaryNegation:
.e2f0	c8		iny				iny 								; skip over the - sign.
.e2f1	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e2f4	20 5f ea	jsr $ea5f			jsr 	BFUNC_NegateAlways 			; negate it.
.e2f7	80 84		bra $e27d			bra 	_EVALGotAtom
.e2f9					_EVALCheckUnaryOperator:
.e2f9	48		pha				pha 								; save indirection operator.
.e2fa	c8		iny				iny 								; skip over the operator
.e2fb	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e2fe	68		pla				pla 								; restore the operator
.e2ff	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e301	f0 0e		beq $e311			beq 	_EVALGoGotAtom
.e303	c9 96		cmp #$96			cmp 	#KW_QUESTION				; byte indirection
.e305	f0 07		beq $e30e			beq 	_EVALByteRead
.e307	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e309	f0 09		beq $e314			beq 	_EVALWordRead
.e30b	4c 62 e1	jmp $e162			jmp 	SyntaxError 				; give up.
.e30e					_EVALByteRead:
.e30e	20 ce e3	jsr $e3ce			jsr 	EVALReadByteIndirect
.e311					_EVALGoGotAtom:
.e311	4c 7d e2	jmp $e27d			jmp 	_EVALGotAtom
.e314					_EVALWordRead:
.e314	20 f7 e3	jsr $e3f7			jsr 	EVALReadWordIndirect
.e317	4c 7d e2	jmp $e27d			jmp 	_EVALGotAtom
.e31a					_EVALCheckVariable:
.e31a	20 27 e4	jsr $e427			jsr 	VARReference 				; get variable reference to ZTemp1
.e31d	20 0b e4	jsr $e40b			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e320	4c 7d e2	jmp $e27d			jmp 	_EVALGotAtom 				; and go round.
.e323					EVALGetDecConstant:
.e323	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e325	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e327	90 04		bcc $e32d			bcc 	_EVGDExit
.e329	c9 3a		cmp #$3a			cmp 	#'9'+1
.e32b	90 01		bcc $e32e			bcc 	_EVGDValue 					; if so has legal value
.e32d					_EVGDExit:
.e32d	60		rts				rts
.e32e					_EVGDValue:
.e32e	48		pha				pha 								; save value, Y on stack
.e32f	5a		phy				phy
.e330	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e332	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e335	48		pha				pha
.e336	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e339	48		pha				pha
.e33a	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e33d	48		pha				pha
.e33e	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e341	48		pha				pha
.e342					_EVGDLoop:
.e342	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e345	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e348	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e34b	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e34e	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e350	d0 1d		bne $e36f			bne 	_EVGDNoAdd
.e352	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e353	68		pla				pla
.e354	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e357	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e35a	68		pla				pla
.e35b	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e35e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e361	68		pla				pla
.e362	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e365	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e368	68		pla				pla
.e369	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e36c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e36f					_EVGDNoAdd:
.e36f	88		dey				dey
.e370	d0 d0		bne $e342			bne 	_EVGDLoop
.e372	7a		ply				ply 								; restore YA
.e373	68		pla				pla
.e374	c8		iny				iny 								; next character
.e375	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e377	18		clc				clc
.e378	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e37b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e37e	90 a3		bcc $e323			bcc 	EVALGetDecConstant 			; propogate constant through
.e380	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e383	d0 9e		bne $e323			bne 	EVALGetDecConstant
.e385	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e388	d0 99		bne $e323			bne 	EVALGetDecConstant
.e38a	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e38d	80 94		bra $e323			bra 	EVALGetDecConstant 			; go back and try again.
.e38f					EVALGetHexConstant:
.e38f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e391	20 c3 e3	jsr $e3c3			jsr 	EVALToUpper 				; make upper case
.e394	38		sec				sec
.e395	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e397	90 0a		bcc $e3a3			bcc 	_EVGHExit 					; exit if CC
.e399	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e39b	90 07		bcc $e3a4			bcc 	_EVGHValue
.e39d	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e39f	c9 10		cmp #$10			cmp 	#15+1
.e3a1	90 01		bcc $e3a4			bcc 	_EVGHValue
.e3a3					_EVGHExit:
.e3a3	60		rts				rts
.e3a4					_EVGHValue:
.e3a4	5a		phy				phy 								; save Y and new digit.
.e3a5	48		pha				pha
.e3a6	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e3a8					_EVGHRotate:
.e3a8	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e3ab	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3ae	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3b1	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3b4	88		dey				dey
.e3b5	d0 f1		bne $e3a8			bne 	_EVGHRotate
.e3b7	68		pla				pla 								; restore digit and X
.e3b8	7a		ply				ply
.e3b9	c8		iny				iny 								; next character
.e3ba	18		clc				clc
.e3bb	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e3be	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3c1	80 cc		bra $e38f			bra 	EVALGetHexConstant 			; go back and try again.
.e3c3					EVALToUpper:
.e3c3	c9 61		cmp #$61			cmp 	#'a'
.e3c5	90 06		bcc $e3cd			bcc 	_EVTUExit
.e3c7	c9 7b		cmp #$7b			cmp 	#'z'+1
.e3c9	b0 02		bcs $e3cd			bcs 	_EVTUExit
.e3cb	49 20		eor #$20			eor 	#32
.e3cd					_EVTUExit:
.e3cd	60		rts				rts
.e3ce					EVALReadByteIndirect:
.e3ce	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3d1	85 24		sta $24				sta 	zTemp1
.e3d3	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3d6	85 25		sta $25				sta 	zTemp1+1
.e3d8	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3db	85 26		sta $26				sta 	zTemp1+2
.e3dd	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3e0	85 27		sta $27				sta 	zTemp1+3
.e3e2					_ERBBase:
.e3e2	5a		phy				phy
.e3e3	a0 00		ldy #$00			ldy 	#0 							; read byte
.e3e5	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3e7	7a		ply				ply
.e3e8					_ERBExit:
.e3e8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3eb	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e3ed	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3f0	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3f3	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3f6	60		rts				rts
.e3f7					EVALReadWordIndirect:
.e3f7	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3fa	85 24		sta $24				sta 	zTemp1
.e3fc	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3ff	85 25		sta $25				sta 	zTemp1+1
.e401	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e404	85 26		sta $26				sta 	zTemp1+2
.e406	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e409	85 27		sta $27				sta 	zTemp1+3
.e40b					EVALReadWordIndirectZTemp:
.e40b					_ERWBase
.e40b	5a		phy				phy
.e40c	a0 00		ldy #$00			ldy 	#0 							; read word
.e40e	b1 24		lda ($24),y			lda 	(zTemp1),y
.e410	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e413	c8		iny				iny
.e414	b1 24		lda ($24),y			lda 	(zTemp1),y
.e416	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e419	c8		iny				iny
.e41a	b1 24		lda ($24),y			lda 	(zTemp1),y
.e41c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e41f	c8		iny				iny
.e420	b1 24		lda ($24),y			lda 	(zTemp1),y
.e422	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e425	7a		ply				ply
.e426					_ERWExit:
.e426	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e427					VARReference:
.e427	38		sec				sec 								; check range @-Z there
.e428	c9 40		cmp #$40			cmp 	#'@'
.e42a	90 04		bcc $e430			bcc 	_VARRError
.e42c	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e42e	90 03		bcc $e433			bcc 	_VARROkay
.e430					_VARRError:
.e430	4c 62 e1	jmp $e162			jmp		SyntaxError
.e433					_VARROkay:
.e433	c8		iny				iny 								; consume the variable.
.e434	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e436	f0 1b		beq $e453			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e438	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e43a	88		dey				dey 								; point back to the first character
.e43b	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e43d	f0 14		beq $e453			beq 	_VARArrayAccess
.e43f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e441	c8		iny				iny
.e442	29 1f		and #$1f			and		#31 						; mask out
.e444	0a		asl a				asl 	a 							; x 4
.e445	0a		asl a				asl 	a
.e446	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e448	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e44a	85 25		sta $25				sta 	zTemp1+1
.e44c	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e44e	85 26		sta $26				sta 	zTemp1+2
.e450	85 27		sta $27				sta 	zTemp1+3 					; return with address set.
.e452	60		rts				rts
.e453					_VARArrayAccess:
.e453	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e455	c8		iny				iny
.e456	29 1f		and #$1f			and 	#31 						; mask it off
.e458	48		pha				pha 								; save on the stack.
.e459	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e45c	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e45f	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e462	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e465	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e468	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e46b	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e46e	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e471	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e474	68		pla				pla 								; put address in zTemp1
.e475	0a		asl a				asl 	a 							; x 4
.e476	0a		asl a				asl 	a
.e477	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e479	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e47b	85 25		sta $25				sta 	zTemp1+1
.e47d	5a		phy				phy
.e47e	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e480	b1 24		lda ($24),y			lda 	(zTemp1),y
.e482	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e485	48		pha				pha 								; save first result as we need the indirection.
.e486	c8		iny				iny 								; 2nd byte
.e487	b1 24		lda ($24),y			lda 	(zTemp1),y
.e489	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e48c	85 25		sta $25				sta 	zTemp1+1
.e48e	68		pla				pla 								; save the low byte.
.e48f	85 24		sta $24				sta 	zTemp1+0
.e491	a9 00		lda #$00			lda 	#0
.e493	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e496	85 26		sta $26				sta 	zTemp1+2
.e498	a9 00		lda #$00			lda 	#0
.e49a	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e49d	85 27		sta $27				sta 	zTemp1+3
.e49f	7a		ply				ply 								; restore Y, address setup
.e4a0	60		rts				rts
.e4a1	80 fe		bra $e4a1	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e4a3					SIOInitialise:
.e4a3	20 8e a0	jsr $a08e			jsr 	EXTReset 					; reset video
.e4a6					SIOClearScreen:
.e4a6	20 38 a0	jsr $a038			jsr 	EXTClearScreen 				; clear screen
.e4a9					SIOHomeCursor:
.e4a9	48		pha				pha 								; home cursor
.e4aa	a9 00		lda #$00			lda 	#0
.e4ac	8d c8 20	sta $20c8			sta 	xCursor
.e4af	8d c9 20	sta $20c9			sta 	yCursor
.e4b2	68		pla				pla
.e4b3	60		rts				rts
.e4b4					SIOPrintString:
.e4b4	48		pha				pha 								; save registers
.e4b5	da		phx				phx
.e4b6	5a		phy				phy
.e4b7	86 26		stx $26				stx 	zTemp2 						; set up indirect pointer
.e4b9	84 27		sty $27				sty 	zTemp2+1
.e4bb	a0 00		ldy #$00			ldy 	#0
.e4bd					_SIOPSLoop:
.e4bd	b1 26		lda ($26),y			lda 	(zTemp2),y 					; read next, exit if 0
.e4bf	f0 1c		beq $e4dd			beq 	_SIOPSExit
.e4c1	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter 			; print and bump
.e4c4	c8		iny				iny
.e4c5	d0 f6		bne $e4bd			bne 	_SIOPSLoop
.e4c7	20 72 e1	jsr $e172			jsr 	ReportError
>e4ca	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e4d2	4e 47 20 50 52 49 4e 54 45 44 00
.e4dd					_SIOPSExit:
.e4dd	7a		ply				ply 								; restore and exit.
.e4de	fa		plx				plx
.e4df	68		pla				pla
.e4e0	60		rts				rts
.e4e1					SIOPrintCharacter:
.e4e1	48		pha				pha 								; save AXY
.e4e2	da		phx				phx
.e4e3	5a		phy				phy
.e4e4	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e4e6	f0 16		beq $e4fe			beq 	_SIOPReturn
.e4e8	c9 09		cmp #$09			cmp 	#9
.e4ea	f0 2b		beq $e517			beq 	_SIOPTab
.e4ec	20 51 e6	jsr $e651			jsr 	SIOLoadCursor 				; load cursor position in.
.e4ef	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e4f1	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen 				; write character out.
.e4f4	ee c8 20	inc $20c8			inc 	xCursor 					; move right
.e4f7	ad c8 20	lda $20c8			lda 	xCursor 					; reached the RHS
.e4fa	c9 50		cmp #$50			cmp 	#EXTWidth
.e4fc	90 15		bcc $e513			bcc 	_SIOPExit
.e4fe					_SIOPReturn:
.e4fe	a9 00		lda #$00			lda 	#0 							; zero x
.e500	8d c8 20	sta $20c8			sta 	xCursor
.e503	ee c9 20	inc $20c9			inc 	yCursor 					; go down
.e506	ad c9 20	lda $20c9			lda 	yCursor
.e509	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e50b	90 06		bcc $e513			bcc 	_SIOPExit
.e50d	20 5c a0	jsr $a05c			jsr 	EXTScrollDisplay 			; scroll display up
.e510	ce c9 20	dec $20c9			dec 	yCursor 					; cursor on bottom line.
.e513					_SIOPExit:
.e513	7a		ply				ply 								; restore and exit.
.e514	fa		plx				plx
.e515	68		pla				pla
.e516	60		rts				rts
.e517					_SIOPTab:
.e517	a9 20		lda #$20			lda 	#32 						; tab.
.e519	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.e51c	ad c8 20	lda $20c8			lda 	xCursor
.e51f	29 07		and #$07			and 	#7
.e521	d0 f4		bne $e517			bne 	_SIOPTab
.e523	80 ee		bra $e513			bra 	_SIOPExit
.e525					SIOGetKey:
.e525	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort 				; wait for a key
.e528	f0 fb		beq $e525			beq 	SIOGetKey
.e52a	20 c3 e3	jsr $e3c3			jsr 	EVALToUpper 				; capitalise it.
.e52d	4c 12 a0	jmp $a012			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e530					SIOReadLine:
.e530	48		pha				pha 								; save registers
.e531	da		phx				phx
.e532	5a		phy				phy
.e533					_SIORLoop:
.e533	20 51 e6	jsr $e651			jsr 	SIOLoadCursor 				; cursor in XY
.e536	20 1e a0	jsr $a01e			jsr 	EXTReadScreen 				; read the display.
.e539	48		pha				pha 								; save on stack.
.e53a	a9 66		lda #$66			lda 	#102 						; write cursor out
.e53c	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e53f	20 25 e5	jsr $e525			jsr 	SIOGetKey
.e542	aa		tax				tax 								; save in X
.e543	68		pla				pla 								; old character
.e544	da		phx				phx 								; save key pressed
.e545	20 51 e6	jsr $e651			jsr 	SIOLoadCursor 				; cursor in XY
.e548	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e54b	68		pla				pla
.e54c	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e54e	f0 29		beq $e579			beq 	_SIOCursorLeft
.e550	c9 13		cmp #$13			cmp 	#"S"-64
.e552	f0 49		beq $e59d			beq 	_SIOCursorDown
.e554	c9 04		cmp #$04			cmp 	#"D"-64
.e556	f0 2d		beq $e585			beq 	_SIOCursorRight
.e558	c9 17		cmp #$17			cmp 	#"W"-64
.e55a	f0 35		beq $e591			beq 	_SIOCursorUp
.e55c	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e55e	f0 49		beq $e5a9			beq 	_SIOClearScreen
.e560	c9 08		cmp #$08			cmp 	#"H"-64
.e562	f0 4a		beq $e5ae			beq 	_SIOBackspace
.e564	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e566	f0 0e		beq $e576			beq 	_SIOGoReturn
.e568	c9 20		cmp #$20			cmp 	#32 						; any control
.e56a	90 c7		bcc $e533			bcc 	_SIORLoop
.e56c	48		pha				pha
.e56d	20 ec e5	jsr $e5ec			jsr 	_SIOInsert 					; insert a space for new character
.e570	68		pla				pla
.e571	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter 			; print character in A
.e574	80 bd		bra $e533			bra 	_SIORLoop
.e576					_SIOGoReturn:
.e576	4c 17 e6	jmp $e617			jmp 	_SIOReturn
.e579					_SIOCursorLeft:
.e579	ce c8 20	dec $20c8			dec 	xCursor
.e57c	10 b5		bpl $e533			bpl 	_SIORLoop
.e57e	a9 4f		lda #$4f			lda 	#EXTWidth-1
.e580					_SIOWXLoop:
.e580	8d c8 20	sta $20c8			sta 	xCursor
.e583	80 ae		bra $e533			bra 	_SIORLoop
.e585					_SIOCursorRight:
.e585	ee c8 20	inc $20c8			inc 	xCursor
.e588	ad c8 20	lda $20c8			lda 	xCursor
.e58b	49 50		eor #$50			eor 	#EXTWidth
.e58d	d0 a4		bne $e533			bne 	_SIORLoop
.e58f	80 ef		bra $e580			bra 	_SIOWXLoop
.e591					_SIOCursorUp:
.e591	ce c9 20	dec $20c9			dec 	yCursor
.e594	10 9d		bpl $e533			bpl 	_SIORLoop
.e596	a9 18		lda #$18			lda 	#EXTHeight-1
.e598					_SIOWYLoop:
.e598	8d c9 20	sta $20c9			sta 	yCursor
.e59b	80 96		bra $e533			bra 	_SIORLoop
.e59d					_SIOCursorDown:
.e59d	ee c9 20	inc $20c9			inc 	yCursor
.e5a0	ad c9 20	lda $20c9			lda 	yCursor
.e5a3	49 19		eor #$19			eor 	#EXTHeight
.e5a5	d0 8c		bne $e533			bne 	_SIORLoop
.e5a7	80 ef		bra $e598			bra 	_SIOWYLoop
.e5a9					_SIOClearScreen:
.e5a9	20 a6 e4	jsr $e4a6			jsr 	SIOClearScreen
.e5ac	80 85		bra $e533			bra 	_SIORLoop
.e5ae					_SIOBackspace:
.e5ae	ad c8 20	lda $20c8			lda 	xCursor 					; backspace possible ?
.e5b1	f0 80		beq $e533			beq 	_SIORLoop 					; start of line, no.
.e5b3	48		pha				pha 								; save position.
.e5b4	c9 4f		cmp #$4f			cmp 	#EXTWidth-1 				; not required
.e5b6	f0 1f		beq $e5d7			beq 	_SIONoShift
.e5b8	ce c8 20	dec $20c8			dec 	xCursor
.e5bb					_SIOShift2:
.e5bb	ee c8 20	inc $20c8			inc 	xCursor 					; copy character backward
.e5be	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e5c1	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5c4	ce c8 20	dec $20c8			dec 	xCursor
.e5c7	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e5ca	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5cd	ee c8 20	inc $20c8			inc 	xCursor
.e5d0	ad c8 20	lda $20c8			lda 	xCursor
.e5d3	c9 4f		cmp #$4f			cmp 	#EXTWidth-1
.e5d5	d0 e4		bne $e5bb			bne 	_SIOShift2
.e5d7					_SIONoShift:
.e5d7	a9 4f		lda #$4f			lda 	#EXTWidth-1 				; space on far end.
.e5d9	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e5dc	a9 20		lda #$20			lda 	#32
.e5de	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5e1	68		pla				pla 								; restore cursor, back one.
.e5e2	3a		dec a				dec 	a
.e5e3	8d c8 20	sta $20c8			sta 	xCursor
.e5e6	20 51 e6	jsr $e651			jsr 	SIOLoadCursor 				; overwrite
.e5e9	4c 33 e5	jmp $e533			jmp	 	_SIORLoop
.e5ec					_SIOInsert:
.e5ec	ad c8 20	lda $20c8			lda 	xCursor 					; at far right, nothing to do.
.e5ef	c9 4f		cmp #$4f			cmp 	#EXTWidth-1
.e5f1	f0 23		beq $e616			beq 	_SIOIExit
.e5f3	85 26		sta $26				sta 	zTemp2 						; save in temporary workspace.
.e5f5	a9 4f		lda #$4f			lda 	#EXTWidth-1 				; cursor at far right.
.e5f7	8d c8 20	sta $20c8			sta 	xCursor
.e5fa					_SIOShift:
.e5fa	ce c8 20	dec $20c8			dec 	xCursor 					; copy character forward
.e5fd	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e600	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e603	ee c8 20	inc $20c8			inc 	xCursor
.e606	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e609	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e60c	ce c8 20	dec $20c8			dec 	xCursor
.e60f	ad c8 20	lda $20c8			lda 	xCursor						; until shifted line to this point.
.e612	c5 26		cmp $26				cmp 	zTemp2
.e614	d0 e4		bne $e5fa			bne 	_SIOShift
.e616					_SIOIExit:
.e616	60		rts				rts
.e617					_SIOReturn:
.e617	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e619	8d c8 20	sta $20c8			sta 	xCursor
.e61c					_SIOCopy:
.e61c	20 51 e6	jsr $e651			jsr 	SIOLoadCursor
.e61f	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e622	49 20		eor #$20			eor 	#$20
.e624	18		clc				clc
.e625	69 20		adc #$20			adc 	#$20
.e627	ae c8 20	ldx $20c8			ldx 	xCursor
.e62a	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e62d	ee c8 20	inc $20c8			inc 	xCursor
.e630	ad c8 20	lda $20c8			lda 	xCursor
.e633	c9 50		cmp #$50			cmp 	#EXTWidth
.e635	d0 e5		bne $e61c			bne 	_SIOCopy
.e637	aa		tax				tax 								; X contains width
.e638					_SIOStrip:
.e638	ca		dex				dex									; back one
.e639	30 07		bmi $e642			bmi		_SIOFound 					; if -ve gone too far
.e63b	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e63e	c9 20		cmp #$20			cmp 	#' '
.e640	f0 f6		beq $e638			beq 	_SIOStrip
.e642					_SIOFound:
.e642	e8		inx				inx
.e643	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e645	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e648	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e64a	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.e64d	7a		ply				ply
.e64e	fa		plx				plx
.e64f	68		pla				pla
.e650	60		rts				rts
.e651					SIOLoadCursor:
.e651	48		pha				pha
.e652	ad c9 20	lda $20c9			lda 	yCursor  					; Y Position
.e655	0a		asl a				asl 	a 							; x 2 	(80)
.e656	0a		asl a				asl 	a 							; x 2 	(160)
.e657	6d c9 20	adc $20c9			adc 	yCursor 					; x 5 	(200) (CC)
.e65a	85 24		sta $24				sta 	zTemp1
.e65c	a9 00		lda #$00			lda 	#0
.e65e	85 25		sta $25				sta 	zTemp1+1
.e660	06 24		asl $24				asl 	zTemp1						; x 10
.e662	26 25		rol $25				rol 	zTemp1+1
.e664	06 24		asl $24				asl 	zTemp1						; x 20
.e666	26 25		rol $25				rol 	zTemp1+1
.e668	06 24		asl $24				asl 	zTemp1						; x 40
.e66a	26 25		rol $25				rol 	zTemp1+1 					;
.e66c	06 24		asl $24				asl 	zTemp1						; x 80
.e66e	26 25		rol $25				rol 	zTemp1+1 					; (CC)
.e670	a5 24		lda $24				lda 	zTemp1 						; add X
.e672	6d c8 20	adc $20c8			adc 	xCursor
.e675	aa		tax				tax
.e676	a5 25		lda $25				lda 	zTemp1+1
.e678	69 00		adc #$00			adc 	#0
.e67a	a8		tay				tay
.e67b	68		pla				pla 								; restore and exit
.e67c	60		rts				rts
.e67d					SIOPrintHex:
.e67d	48		pha				pha
.e67e	48		pha				pha
.e67f	a9 20		lda #$20			lda 	#32
.e681	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.e684	68		pla				pla
.e685	48		pha				pha
.e686	4a		lsr a				lsr 	a
.e687	4a		lsr a				lsr 	a
.e688	4a		lsr a				lsr 	a
.e689	4a		lsr a				lsr 	a
.e68a	20 93 e6	jsr $e693			jsr 	_SIOPHex
.e68d	68		pla				pla
.e68e	20 93 e6	jsr $e693			jsr 	_SIOPHex
.e691	68		pla				pla
.e692	60		rts				rts
.e693					_SIOPHex:
.e693	29 0f		and #$0f			and 	#15
.e695	c9 0a		cmp #$0a			cmp 	#10
.e697	90 02		bcc $e69b			bcc 	_SIOPHex2
.e699	69 06		adc #$06			adc 	#6
.e69b					_SIOPHex2:
.e69b	69 30		adc #$30			adc 	#48
.e69d	4c e1 e4	jmp $e4e1			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e6a0					TokeniseString:
.e6a0	a0 00		ldy #$00			ldy 	#0							; source
.e6a2	a2 00		ldx #$00			ldx 	#0 							; target
.e6a4					_TokLoop:
.e6a4	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get first
.e6a6	f0 5d		beq $e705			beq 	_TokExit 					; End, exit.
.e6a8	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e6aa	f0 35		beq $e6e1			beq 	_TokCopy1
.e6ac	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e6ae	f0 3a		beq $e6ea			beq 	_TokCopyString
.e6b0	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e6b2	90 22		bcc $e6d6			bcc 	_TokPunctuation
.e6b4	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e6b6	90 29		bcc $e6e1			bcc 	_TokCopy1
.e6b8	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e6ba	90 1a		bcc $e6d6			bcc 	_TokPunctuation
.e6bc	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e6be	b0 16		bcs $e6d6			bcs 	_TokPunctuation
.e6c0					_TokWord:
.e6c0	20 0b e7	jsr $e70b			jsr 	TokeniseSearch 				; search for tokenised word.
.e6c3	b0 16		bcs $e6db			bcs 	_TokFound 					; if successful, copy it out.
.e6c5					_TokSkip:
.e6c5	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e6c7	c9 41		cmp #$41			cmp 	#"A"
.e6c9	90 d9		bcc $e6a4			bcc 	_TokLoop
.e6cb	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e6cd	b0 d5		bcs $e6a4			bcs 	_TokLoop
.e6cf	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6d2	e8		inx				inx
.e6d3	c8		iny				iny
.e6d4	80 ef		bra $e6c5			bra 	_TokSkip
.e6d6					_TokPunctuation:
.e6d6	20 0b e7	jsr $e70b			jsr 	TokeniseSearch 				; find it.
.e6d9	90 06		bcc $e6e1			bcc 	_TokCopy1 					; if found, just copy 1 character
.e6db					_TokFound:
.e6db	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e6de	e8		inx				inx 								; advance target ; source is already advanced.
.e6df	80 c3		bra $e6a4			bra 	_TokLoop 					; do the next character.
.e6e1					_TokCopy1:
.e6e1	b1 24		lda ($24),y			lda 	(zTemp1),y
.e6e3	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6e6	e8		inx				inx
.e6e7	c8		iny				iny
.e6e8	80 ba		bra $e6a4			bra 	_TokLoop
.e6ea					_TokCopyString:
.e6ea	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e6ec	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6ef	e8		inx				inx 								; skip buffer and first quote.
.e6f0	c8		iny				iny
.e6f1					_TokCSLoop:
.e6f1	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get next character
.e6f3	f0 10		beq $e705			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e6f5	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e6f8	e8		inx				inx 								; advance both.
.e6f9	c8		iny				iny
.e6fa	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e6fc	d0 f3		bne $e6f1			bne 	_TokCSLoop
.e6fe	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e700	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e703	80 9f		bra $e6a4			bra 	_TokLoop
.e705					_TokExit:
.e705	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e707	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e70a	60		rts				rts
.e70b					TokeniseSearch:
.e70b	48		pha				pha 								; save AXY
.e70c	da		phx				phx
.e70d	5a		phy				phy
.e70e	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e710	85 26		sta $26				sta 	zTemp2
.e712	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e714	bd 7e e0	lda $e07e,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e717	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e719	d1 24		cmp ($24),y			cmp 	(zTemp1),y 					; do the characters match.
.e71b	f0 13		beq $e730			beq 	_TSTryFullMatch 			; if so, try the full match.
.e71d					_TSGotoNext:
.e71d	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; read it
.e720	e8		inx				inx 								; bump index
.e721	0a		asl a				asl 	a 							; shift into C
.e722	90 f9		bcc $e71d			bcc 	_TSGotoNext 				; keep going until read the end character
.e724	e6 26		inc $26				inc 	zTemp2 						; bump the current token pointer.
.e726	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; look at the first character of the next token
.e729	d0 e9		bne $e714			bne 	_TSNext 					; if non-zero, go to the next.
.e72b					_TSFail:
.e72b	7a		ply				ply 								; fail.
.e72c	fa		plx				plx
.e72d	68		pla				pla
.e72e	18		clc				clc 				 				; return with carry clear.
.e72f	60		rts				rts
.e730					_TSTryFullMatch:
.e730	da		phx				phx									; save X and Y.
.e731	5a		phy				phy
.e732					_TSFullMatch:
.e732	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; compare the 7 bits.
.e735	29 7f		and #$7f			and 	#$7F
.e737	d1 24		cmp ($24),y			cmp 	(zTemp1),y
.e739	d0 15		bne $e750			bne 	_TSFullFail 				; different, this one doesn't match.
.e73b	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.e73e	e8		inx				inx 								; advance to next character
.e73f	c8		iny				iny
.e740	0a		asl a				asl 	a 							; bit 7 of token text in C
.e741	90 ef		bcc $e732			bcc 	_TSFullMatch
.e743	84 27		sty $27				sty 	zTemp2+1 					; save the Y after last
.e745	68		pla				pla 								; so we don't restore Y
.e746	68		pla				pla 								; or X from the full test.
.e747	7a		ply				ply 								; restore original Y and X and A
.e748	fa		plx				plx
.e749	68		pla				pla
.e74a	a5 26		lda $26				lda 	zTemp2 						; and return token ID in A
.e74c	a4 27		ldy $27				ldy 	zTemp2+1 					; Y after the tokenised text.
.e74e	38		sec				sec 								; with carry set.
.e74f	60		rts				rts
.e750					_TSFullFail:
.e750	7a		ply				ply 								; restore Y and X
.e751	fa		plx				plx
.e752	80 c9		bra $e71d			bra 	_TSGotoNext 				; and go to the next token to test.
.e754					TokeniseTest:
.e754	a9 60		lda #$60			lda 	#TTString & $FF
.e756	85 24		sta $24				sta 	zTemp1
.e758	a9 e7		lda #$e7			lda 	#TTString >> 8
.e75a	85 25		sta $25				sta 	zTemp1+1
.e75c	20 a0 e6	jsr $e6a0			jsr 	TokeniseString
.e75f	ea		nop				nop
.e760					TTString:
>e760	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e768	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: general/editor.asm

.e775					EditProgram:
.e775	a2 00		ldx #$00			ldx 	#0
.e777	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; get the line number
.e77a	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; upper bytes must be zero
.e77d	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e780	d0 37		bne $e7b9			bne 	_EPBadLine
.e782	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; lower bytes must be non-zero
.e785	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e788	f0 2f		beq $e7b9			beq 	_EPBadLine
.e78a	5a		phy				phy 								; save position
.e78b	20 c5 e7	jsr $e7c5			jsr 	EDFindLine 					; locate the line.
.e78e	90 12		bcc $e7a2			bcc 	_EPNotFound 				; skip delete if not found.
.e790	a5 24		lda $24				lda 	zTemp1 						; save the target address, as we will
.e792	48		pha				pha 								; insert the line, if done, at the same
.e793	a5 25		lda $25				lda 	zTemp1+1 					; place
.e795	48		pha				pha
.e796	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; clear all vars, make sure zLowMemory is right.
.e799	20 fc e7	jsr $e7fc			jsr 	EDDeleteLine 				; delete the line at zTemp1
.e79c	68		pla				pla 								; restore the target address.
.e79d	85 25		sta $25				sta 	zTemp1+1
.e79f	68		pla				pla
.e7a0	85 24		sta $24				sta 	zTemp1
.e7a2					_EPNotFound
.e7a2	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e7a5	7a		ply				ply 								; get pointer back
.e7a6					_EPSkipSpaces:
.e7a6	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get character
.e7a8	f0 0c		beq $e7b6			beq 	_EPGoWarmStart 				; EOL, just delete, so warm start.
.e7aa	c8		iny				iny
.e7ab	c9 20		cmp #$20			cmp 	#32
.e7ad	f0 f7		beq $e7a6			beq 	_EPSkipSpaces
.e7af	88		dey				dey
.e7b0	20 1c e8	jsr $e81c			jsr 	EDInsertLine 				; insert the line.
.e7b3	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e7b6					_EPGoWarmStart:
.e7b6	4c 23 f2	jmp $f223			jmp 	WarmStart
.e7b9					_EPBadLine:
.e7b9	20 72 e1	jsr $e172			jsr 	ReportError
>e7bc	42 41 44 20 4c 49 4e 45				.text 	"BAD LINE",$00
>e7c4	00
.e7c5					EDFindLine:
.e7c5	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set zTemp1
.e7c7	85 24		sta $24				sta 	zTemp1
.e7c9	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e7cb	85 25		sta $25				sta 	zTemp1+1
.e7cd					_EDFLLoop:
.e7cd	a0 00		ldy #$00			ldy 	#0 							; reached the end
.e7cf	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7d1	f0 25		beq $e7f8			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.e7d3	c8		iny				iny
.e7d4	38		sec				sec
.e7d5	ad 00 04	lda $0400			lda 	evalStack+0					; subtract the current from the target
.e7d8	f1 24		sbc ($24),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.e7da	aa		tax				tax	 								; this will return 10.
.e7db	ad 01 04	lda $0401			lda 	evalStack+1
.e7de	c8		iny				iny
.e7df	f1 24		sbc ($24),y			sbc 	(zTemp1),y
.e7e1	90 15		bcc $e7f8			bcc 	_EDFLFail					; if target < current then failed.
.e7e3	d0 04		bne $e7e9			bne 	_EDFLNext 					; if non-zero then goto next
.e7e5	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.e7e7	f0 11		beq $e7fa			beq 	_EDFLFound
.e7e9					_EDFLNext:
.e7e9	a0 00		ldy #$00			ldy 	#0 							; get offset
.e7eb	18		clc				clc
.e7ec	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7ee	65 24		adc $24				adc 	zTemp1 						; add to pointer
.e7f0	85 24		sta $24				sta 	zTemp1
.e7f2	90 d9		bcc $e7cd			bcc 	_EDFLLoop
.e7f4	e6 25		inc $25				inc 	zTemp1+1 					; carry out.
.e7f6	80 d5		bra $e7cd			bra 	_EDFLLoop
.e7f8					_EDFLFail:
.e7f8	18		clc				clc
.e7f9	60		rts				rts
.e7fa					_EDFLFound:
.e7fa	38		sec				sec
.e7fb	60		rts				rts
.e7fc					EDDeleteLine:
.e7fc	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.e7fe	a2 00		ldx #$00			ldx 	#0
.e800	b1 24		lda ($24),y			lda 	(zTemp1),y
.e802	a8		tay				tay 								; put in Y
.e803					_EDDelLoop:
.e803	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get it
.e805	81 24		sta ($24,x)			sta 	(zTemp1,x) 					; write it.
.e807	a5 24		lda $24				lda 	zTemp1 						; check if pointer has reached the end of
.e809	c5 22		cmp $22				cmp		zLowMemory 					; low memory. We will have copied down an
.e80b	d0 06		bne $e813			bne 	_EDDelNext 					; extra pile of stuff - technically should
.e80d	a5 25		lda $25				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.e80f	c5 23		cmp $23				cmp 	zLowMemory+1				; doesn't really matter.
.e811	f0 08		beq $e81b			beq		_EDDelExit
.e813					_EDDelNext:
.e813	e6 24		inc $24				inc 	zTemp1 						; go to next byte.
.e815	d0 ec		bne $e803			bne 	_EDDelLoop
.e817	e6 25		inc $25				inc 	zTemp1+1
.e819	80 e8		bra $e803			bra 	_EDDelLoop
.e81b					_EDDelExit:
.e81b	60		rts				rts
.e81c					EDInsertLine:
.e81c	98		tya				tya 								; make zCurrentLine point to the actual new line.
.e81d	18		clc				clc
.e81e	65 20		adc $20				adc 	zCurrentLine
.e820	85 20		sta $20				sta 	zCurrentLine
.e822	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.e824					_EDGetLength:
.e824	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e826	c8		iny				iny
.e827	c9 00		cmp #$00			cmp 	#0
.e829	d0 f9		bne $e824			bne 	_EDGetLength
.e82b	88		dey				dey 								; fix up.
.e82c	98		tya				tya
.e82d	18		clc				clc
.e82e	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.e830	48		pha				pha 								; save total size (e.g. offset)
.e831	a8		tay				tay 								; in Y
.e832	a2 00		ldx #$00			ldx 	#0
.e834					_EDInsLoop:
.e834	a1 22		lda ($22,x)			lda 	(zLowMemory,x)				; copy it up
.e836	91 22		sta ($22),y			sta 	(zLowMemory),y
.e838	a5 22		lda $22				lda 	zLowMemory 					; reached the insert point (zTemp1)
.e83a	c5 24		cmp $24				cmp 	zTemp1
.e83c	d0 06		bne $e844			bne 	_EDINextShift
.e83e	a5 23		lda $23				lda 	zLowMemory+1
.e840	c5 25		cmp $25				cmp 	zTemp1+1
.e842	f0 0a		beq $e84e			beq 	_EDIShiftOver
.e844					_EDINextShift:
.e844	a5 22		lda $22				lda 	zLowMemory 					; decrement the copy pointer.
.e846	d0 02		bne $e84a			bne 	_EDINoBorrow
.e848	c6 23		dec $23				dec 	zLowMemory+1
.e84a					_EDINoBorrow:
.e84a	c6 22		dec $22				dec 	zLowMemory
.e84c	80 e6		bra $e834			bra 	_EDInsLoop
.e84e					_EDIShiftOver:
.e84e	68		pla				pla 								; this is the size + others, e.g. offset
.e84f	a0 00		ldy #$00			ldy 	#0
.e851	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write that out.
.e853	ad 00 04	lda $0400			lda 	evalStack+0 				; write LIne# out
.e856	c8		iny				iny
.e857	91 22		sta ($22),y			sta 	(zLowMemory),y
.e859	ad 01 04	lda $0401			lda 	evalStack+1
.e85c	c8		iny				iny
.e85d	91 22		sta ($22),y			sta 	(zLowMemory),y
.e85f	c8		iny				iny 								; where the code goes.
.e860	a2 00		ldx #$00			ldx 	#0 							; comes from
.e862					_EDICopyCode:
.e862	a1 20		lda ($20,x)			lda 	(zCurrentLine,x)			; read from the current line
.e864	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write out
.e866	c8		iny				iny 								; bump pointers
.e867	e6 20		inc $20				inc 	zCurrentLine
.e869	c9 00		cmp #$00			cmp 	#0 							; until zero copied
.e86b	d0 f5		bne $e862			bne 	_EDICopyCode
.e86d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e86e					BFUNC_Add:
.e86e	18		clc				clc
.e86f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e872	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e875	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e878	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e87b	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e87e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e881	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e884	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e887	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e88a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e88d	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e890	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e893	60		rts				rts
.e894					BFUNC_Subtract:
.e894	38		sec				sec
.e895	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e898	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e89b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e89e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8a1	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e8a4	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8a7	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8aa	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e8ad	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8b0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8b3	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e8b6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8b9	60		rts				rts
.e8ba					BFUNC_String:
.e8ba	20 6e e8	jsr $e86e			jsr 	BFUNC_Add
.e8bd	60		rts				rts
.e8be					BFUNC_ByteInd:
.e8be	20 6e e8	jsr $e86e			jsr 	BFUNC_Add
.e8c1	20 ce e3	jsr $e3ce			jsr 	EVALReadByteIndirect
.e8c4	60		rts				rts
.e8c5					BFUNC_WordInd:
.e8c5	20 6e e8	jsr $e86e			jsr 	BFUNC_Add
.e8c8	20 f7 e3	jsr $e3f7			jsr 	EVALReadWordIndirect
.e8cb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e8cc					BFUNC_And:
.e8cc	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8cf	3d 04 04	and $0404,x			and 	evalStack+4,x
.e8d2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8d5	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8d8	3d 05 04	and $0405,x			and 	evalStack+5,x
.e8db	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8de	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8e1	3d 06 04	and $0406,x			and 	evalStack+6,x
.e8e4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8e7	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8ea	3d 07 04	and $0407,x			and 	evalStack+7,x
.e8ed	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8f0	60		rts				rts
.e8f1					BFUNC_Or:
.e8f1	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8f4	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e8f7	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8fa	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8fd	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e900	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e903	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e906	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e909	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e90c	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e90f	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e912	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e915	60		rts				rts
.e916					BFUNC_Xor:
.e916	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e919	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e91c	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e91f	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e922	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e925	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e928	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e92b	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e92e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e931	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e934	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e937	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e93a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e93b					BFUNC_Equals:
.e93b	18		clc				clc
.e93c	80 01		bra $e93f			bra 	BFUNC_EqualCheck
.e93e					BFUNC_NotEquals:
.e93e	38		sec				sec
.e93f					BFUNC_EqualCheck:
.e93f	08		php				php									; save invert flag
.e940	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e943	cd 04 04	cmp $0404			cmp 	evalStack+4
.e946	d0 1c		bne $e964			bne 	COMP_Fail
.e948	ad 01 04	lda $0401			lda 	evalStack+1
.e94b	cd 05 04	cmp $0405			cmp 	evalStack+5
.e94e	d0 14		bne $e964			bne 	COMP_Fail
.e950	ad 02 04	lda $0402			lda 	evalStack+2
.e953	cd 06 04	cmp $0406			cmp 	evalStack+6
.e956	d0 0c		bne $e964			bne 	COMP_Fail
.e958	ad 03 04	lda $0403			lda 	evalStack+3
.e95b	cd 07 04	cmp $0407			cmp 	evalStack+7
.e95e	d0 04		bne $e964			bne 	COMP_Fail
.e960					COMP_Succeed:
.e960	a9 ff		lda #$ff			lda 	#$FF
.e962	80 02		bra $e966			bra 	COMP_SetResult
.e964					COMP_Fail:
.e964	a9 00		lda #$00			lda 	#0 							; here return 0
.e966					COMP_SetResult:
.e966	28		plp				plp 								; but if CS
.e967	90 02		bcc $e96b			bcc 	COMP_Accept
.e969	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e96b					COMP_Accept:
.e96b	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e96e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e971	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e974	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e977	60		rts				rts
.e978					BFUNC_Less:
.e978	18		clc				clc
.e979	80 01		bra $e97c			bra 	BFUNC_LessCheck
.e97b					BFUNC_GreaterEqual:
.e97b	38		sec				sec
.e97c					BFUNC_LessCheck:
.e97c	08		php				php
.e97d	38		sec				sec
.e97e	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e981	ed 04 04	sbc $0404			sbc 	evalStack+4
.e984	ad 01 04	lda $0401			lda 	evalStack+1
.e987	ed 05 04	sbc $0405			sbc 	evalStack+5
.e98a	ad 02 04	lda $0402			lda 	evalStack+2
.e98d	ed 06 04	sbc $0406			sbc 	evalStack+6
.e990	ad 03 04	lda $0403			lda 	evalStack+3
.e993	ed 07 04	sbc $0407			sbc 	evalStack+7
.e996	30 c8		bmi $e960			bmi 	COMP_Succeed
.e998	80 ca		bra $e964			bra 	COMP_Fail
.e99a					BFUNC_Greater:
.e99a	18		clc				clc
.e99b	80 01		bra $e99e			bra 	BFUNC_GreaterCheck
.e99d					BFUNC_LessEqual:
.e99d	38		sec				sec
.e99e					BFUNC_GreaterCheck:
.e99e	08		php				php
.e99f	38		sec				sec
.e9a0	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.e9a3	ed 00 04	sbc $0400			sbc 	evalStack+0
.e9a6	ad 05 04	lda $0405			lda 	evalStack+5
.e9a9	ed 01 04	sbc $0401			sbc 	evalStack+1
.e9ac	ad 06 04	lda $0406			lda 	evalStack+6
.e9af	ed 02 04	sbc $0402			sbc 	evalStack+2
.e9b2	ad 07 04	lda $0407			lda 	evalStack+7
.e9b5	ed 03 04	sbc $0403			sbc 	evalStack+3
.e9b8	30 a6		bmi $e960			bmi 	COMP_Succeed
.e9ba	80 a8		bra $e964			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e9bc					BFUNC_Divide:
.e9bc	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e9bf	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e9c2	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e9c5	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e9c8	d0 14		bne $e9de			bne 	_BFDOkay
.e9ca	20 72 e1	jsr $e172			jsr 	ReportError
>e9cd	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>e9d5	20 42 59 20 5a 45 52 4f 00
.e9de					_BFDOkay:
.e9de	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e9e0	8d c0 20	sta $20c0			sta 	Temp1 						; Q/Dividend/Left in +0
.e9e3	8d c1 20	sta $20c1			sta 	Temp1+1 					; M/Divisor/Right in +4
.e9e6	8d c2 20	sta $20c2			sta 	Temp1+2
.e9e9	8d c3 20	sta $20c3			sta 	Temp1+3
.e9ec	8d c4 20	sta $20c4			sta 	SignCount 					; Count of signs.
.e9ef	20 5a ea	jsr $ea5a			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e9f2	da		phx				phx
.e9f3	e8		inx				inx
.e9f4	e8		inx				inx
.e9f5	e8		inx				inx
.e9f6	e8		inx				inx
.e9f7	20 5a ea	jsr $ea5a			jsr 	BFUNC_Negate
.e9fa	fa		plx				plx
.e9fb	5a		phy				phy 								; Y is the counter
.e9fc	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e9fe					_BFDLoop:
.e9fe	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.ea01	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.ea04	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.ea07	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.ea0a	2e c0 20	rol $20c0			rol 	Temp1
.ea0d	2e c1 20	rol $20c1			rol 	Temp1+1
.ea10	2e c2 20	rol $20c2			rol 	Temp1+2
.ea13	2e c3 20	rol $20c3			rol 	Temp1+3
.ea16	38		sec				sec
.ea17	ad c0 20	lda $20c0			lda 	Temp1+0 					; Calculate A-M on stack.
.ea1a	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.ea1d	48		pha				pha
.ea1e	ad c1 20	lda $20c1			lda 	Temp1+1
.ea21	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.ea24	48		pha				pha
.ea25	ad c2 20	lda $20c2			lda 	Temp1+2
.ea28	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.ea2b	48		pha				pha
.ea2c	ad c3 20	lda $20c3			lda 	Temp1+3
.ea2f	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.ea32	90 19		bcc $ea4d			bcc 	_BFDNoAdd
.ea34	8d c3 20	sta $20c3			sta 	Temp1+3 					; update A
.ea37	68		pla				pla
.ea38	8d c2 20	sta $20c2			sta 	Temp1+2
.ea3b	68		pla				pla
.ea3c	8d c1 20	sta $20c1			sta 	Temp1+1
.ea3f	68		pla				pla
.ea40	8d c0 20	sta $20c0			sta 	Temp1+0
.ea43	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.ea46	09 01		ora #$01			ora 	#1
.ea48	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea4b	80 03		bra $ea50			bra 	_BFDNext
.ea4d					_BFDNoAdd:
.ea4d	68		pla				pla 								; Throw away the intermediate calculations
.ea4e	68		pla				pla
.ea4f	68		pla				pla
.ea50					_BFDNext:
.ea50	88		dey				dey
.ea51	d0 ab		bne $e9fe			bne 	_BFDLoop
.ea53	7a		ply				ply 								; restore Y and exit
.ea54	4e c4 20	lsr $20c4			lsr 	SignCount 					; if sign count odd,
.ea57	b0 06		bcs $ea5f			bcs		BFUNC_NegateAlways 			; negate the result
.ea59	60		rts				rts
.ea5a					BFUNC_Negate:
.ea5a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ea5d	10 24		bpl $ea83			bpl 	BFNExit
.ea5f					BFUNC_NegateAlways:
.ea5f	38		sec				sec
.ea60	a9 00		lda #$00			lda 	#0
.ea62	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.ea65	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea68	a9 00		lda #$00			lda 	#0
.ea6a	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.ea6d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea70	a9 00		lda #$00			lda 	#0
.ea72	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.ea75	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea78	a9 00		lda #$00			lda 	#0
.ea7a	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.ea7d	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea80	ee c4 20	inc $20c4			inc 	SignCount
.ea83					BFNExit:
.ea83	60		rts				rts
.ea84					BFUNC_Modulus:
.ea84	20 bc e9	jsr $e9bc			jsr 	BFUNC_Divide 				; start with division.
.ea87	ad c0 20	lda $20c0			lda 	Temp1+0 					; copy remainder
.ea8a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea8d	ad c1 20	lda $20c1			lda 	Temp1+1
.ea90	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea93	ad c2 20	lda $20c2			lda 	Temp1+2
.ea96	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea99	ad c3 20	lda $20c3			lda 	Temp1+3
.ea9c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea9f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.eaa0					BFUNC_Multiply:
.eaa0	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.eaa3	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.eaa6	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eaa9	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.eaac	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eaaf	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.eab2	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eab5	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.eab8	a9 00		lda #$00			lda 	#0
.eaba	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.eabd	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eac0	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eac3	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eac6					_BFMMultiply:
.eac6	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.eac9	29 01		and #$01			and 	#1
.eacb	f0 03		beq $ead0			beq 	_BFMNoAdd
.eacd	20 6e e8	jsr $e86e			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.ead0					_BFMNoAdd:
.ead0	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.ead3	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.ead6	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.ead9	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.eadc	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.eadf	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.eae2	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.eae5	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.eae8	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.eaeb	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.eaee	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.eaf1	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.eaf4	d0 d0		bne $eac6			bne 	_BFMMultiply
.eaf6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.eaf7					BFUNC_StringCompare:
.eaf7	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.eafa	85 24		sta $24				sta 	zTemp1
.eafc	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eaff	85 25		sta $25				sta 	zTemp1+1
.eb01	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.eb04	85 26		sta $26				sta 	zTemp2
.eb06	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.eb09	85 27		sta $27				sta 	zTemp2+1
.eb0b	5a		phy				phy
.eb0c	a0 00		ldy #$00			ldy 	#0
.eb0e					_BFSCLoop:
.eb0e	b1 24		lda ($24),y			lda 	(zTemp1),y 					; comparison
.eb10	38		sec				sec
.eb11	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.eb13	d0 15		bne $eb2a			bne		_BFSCDifferent 				; return different result.
.eb15	c8		iny				iny
.eb16	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.eb18	d0 f4		bne $eb0e			bne 	_BFSCLoop
.eb1a	7a		ply				ply
.eb1b	a9 00		lda #$00			lda 	#0
.eb1d					_BFSCSetAll:
.eb1d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb20	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb23	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb26	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb29	60		rts				rts
.eb2a					_BFSCDifferent:
.eb2a	7a		ply				ply
.eb2b	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.eb2d	90 ee		bcc $eb1d			bcc 	_BFSCSetAll
.eb2f	a9 00		lda #$00			lda 	#0 							; set all zero
.eb31	20 1d eb	jsr $eb1d			jsr 	_BFSCSetAll
.eb34	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.eb37	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.eb38					UNARY_Len:
.eb38	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb3b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb3e	85 24		sta $24				sta 	zTemp1
.eb40	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb43	85 25		sta $25				sta 	zTemp1+1
.eb45	5a		phy				phy
.eb46	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.eb48					_ULGetLength:
.eb48	b1 24		lda ($24),y			lda 	(zTemp1),y 					; read character
.eb4a	f0 1d		beq $eb69			beq 	_ULFoundEOL 				; found end of line.
.eb4c	c8		iny				iny
.eb4d	d0 f9		bne $eb48			bne 	_ULGetLength 				; scan 256 only.
.eb4f	20 72 e1	jsr $e172			jsr 	ReportError
>eb52	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>eb5a	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.eb69					_ULFoundEOL:
.eb69	98		tya				tya 								; length in A, restore Y
.eb6a	7a		ply				ply
.eb6b					UNARY_ReturnByte:
.eb6b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb6e	a9 00		lda #$00			lda 	#0 							; clear the rests
.eb70	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb73	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb76	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb79	60		rts				rts
.eb7a					UNARY_Ch:
.eb7a	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb7d	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb80	85 24		sta $24				sta 	zTemp1
.eb82	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb85	85 25		sta $25				sta 	zTemp1+1
.eb87	5a		phy				phy
.eb88	a0 00		ldy #$00			ldy 	#0 							; now get first character
.eb8a	b1 24		lda ($24),y			lda 	(zTemp1),y
.eb8c	7a		ply				ply
.eb8d	80 dc		bra $eb6b			bra 	UNARY_ReturnByte 			; return that byte.
.eb8f					UNARY_Abs:
.eb8f	ea		nop				nop
.eb90	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb93	20 5a ea	jsr $ea5a			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.eb96	60		rts				rts
.eb97					UNARY_Top:
.eb97	ad be 20	lda $20be			lda 	highMemory
.eb9a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb9d	ad bf 20	lda $20bf			lda 	highMemory+1
.eba0	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eba3	a9 00		lda #$00			lda 	#0
.eba5	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eba8	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebab	60		rts				rts
.ebac					UNARY_Get:
.ebac	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort
.ebaf	f0 fb		beq $ebac			beq 	UNARY_Get
.ebb1	20 12 a0	jsr $a012			jsr 	EXTRemoveKeyPressed
.ebb4	80 b5		bra $eb6b			bra 	UNARY_ReturnByte
.ebb6					UNARY_Page:
.ebb6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.ebb8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebbb	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ebbd	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebc0	a9 00		lda #$00			lda 	#0
.ebc2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ebc5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebc8	60		rts				rts
.ebc9					UNARY_Rnd:
.ebc9	20 d4 eb	jsr $ebd4			jsr 	Random16 					; call 16 bit RNG twice
.ebcc	e8		inx				inx
.ebcd	e8		inx				inx
.ebce	20 d4 eb	jsr $ebd4			jsr 	Random16
.ebd1	ca		dex				dex
.ebd2	ca		dex				dex
.ebd3	60		rts				rts
.ebd4					Random16:
.ebd4	ad c6 20	lda $20c6			lda 	RandomSeed 					; initialise if nonzero
.ebd7	0d c7 20	ora $20c7			ora 	RandomSeed+1
.ebda	d0 0d		bne $ebe9			bne 	_R16_NoInit
.ebdc	ee c6 20	inc $20c6			inc 	RandomSeed 					; by setting low to 1
.ebdf	5a		phy				phy
.ebe0	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.ebe2					_R16_Setup:
.ebe2	20 d4 eb	jsr $ebd4			jsr 	Random16
.ebe5	88		dey				dey
.ebe6	d0 fa		bne $ebe2			bne 	_R16_Setup
.ebe8	7a		ply				ply
.ebe9					_R16_NoInit:
.ebe9	4e c7 20	lsr $20c7			lsr 	RandomSeed+1				; shift seed right
.ebec	6e c6 20	ror $20c6			ror 	RandomSeed
.ebef	90 08		bcc $ebf9			bcc 	_R16_NoXor
.ebf1	ad c7 20	lda $20c7			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.ebf4	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ebf6	8d c7 20	sta $20c7			sta 	RandomSeed+1
.ebf9					_R16_NoXor:
.ebf9	ad c6 20	lda $20c6			lda 	RandomSeed					; copy result to evaluate stack.
.ebfc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebff	ad c7 20	lda $20c7			lda 	RandomSeed+1
.ec02	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec05	60		rts				rts
.ec06					UNARY_IOAddr:
.ec06	a9 0f		lda #$0f			lda 	#$0F
.ec08	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec0b	a9 fd		lda #$fd			lda 	#$FD
.ec0d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec10	a9 30		lda #$30			lda 	#$30
.ec12	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec15	a9 00		lda #$00			lda 	#$00
.ec17	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec1a	60		rts				rts
.ec1b					UNARY_CPU:
.ec1b	a9 00		lda #$00			lda 	#$00
.ec1d	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec20	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec23	a9 20		lda #$20			lda 	#registers >> 8
.ec25	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec28	a9 cc		lda #$cc			lda 	#registers & $FF
.ec2a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec2d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/dim.asm

.ec2e					COMMAND_Dim:
.ec2e	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; skip over , and space
.ec30	f0 0b		beq $ec3d			beq 	_CDIMExit
.ec32	c8		iny				iny
.ec33	c9 8b		cmp #$8b			cmp 	#KW_COMMA
.ec35	f0 f7		beq $ec2e			beq 	COMMAND_Dim
.ec37	c9 20		cmp #$20			cmp 	#" "
.ec39	f0 f3		beq $ec2e			beq 	COMMAND_Dim
.ec3b	80 04		bra $ec41			bra 	_CDIMDoDim
.ec3d					_CDIMExit:
.ec3d	60		rts				rts
.ec3e					_CDIMSyntax:
.ec3e	4c 62 e1	jmp $e162			jmp 	SyntaxError
.ec41					_CDIMDoDim:
.ec41	c9 40		cmp #$40			cmp 	#"@"						; check it is @A-Z
.ec43	90 f9		bcc $ec3e			bcc 	_CDIMSyntax
.ec45	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ec47	b0 f5		bcs $ec3e			bcs 	_CDIMSyntax
.ec49	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it followed by a duplicate
.ec4b	d0 03		bne $ec50			bne 	_CDIMNoDouble
.ec4d	c8		iny				iny 								; yes, so skip it to the size.
.ec4e	09 80		ora #$80			ora 	#$80 						; and set bit 7 to indicate AA(x) e.g. 4 bytes.
.ec50					_CDIMNoDouble:
.ec50	48		pha				pha 								; save array 'name'
.ec51	a2 00		ldx #$00			ldx 	#0 							; count it bottom stack level.
.ec53	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel
.ec56	ee 00 04	inc $0400			inc 	evalStack+0 				; add extra element
.ec59	d0 03		bne $ec5e			bne 	_CDIMAlloc
.ec5b	ee 01 04	inc $0401			inc 	evalStack+1
.ec5e					_CDIMAlloc:
.ec5e	68		pla				pla 								; get bit 7
.ec5f	48		pha				pha
.ec60	10 0c		bpl $ec6e			bpl 	_CDIMNotWord 				; if not set, then A(x) not AA(x) so use byte size.
.ec62	0e 00 04	asl $0400			asl 	evalStack+0 				; shift left x 2
.ec65	2e 01 04	rol $0401			rol 	evalStack+1
.ec68	0e 00 04	asl $0400			asl 	evalStack+0 				; won't bother about the upper 16 bits.
.ec6b	2e 01 04	rol $0401			rol 	evalStack+1
.ec6e					_CDIMNotWord:
.ec6e	68		pla				pla 								; variable back
.ec6f	29 1f		and #$1f			and 	#$1F 						; lower 5 bits
.ec71	0a		asl a				asl 	a 							; x 4 now index into variable.
.ec72	0a		asl a				asl 	a
.ec73	aa		tax				tax
.ec74	a5 22		lda $22				lda 	zLowMemory 					; copy low memory into variable
.ec76	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.ec79	a5 23		lda $23				lda 	zLowMemory+1
.ec7b	9d 01 20	sta $2001,x			sta 	FixedVariables+1,x
.ec7e	a9 00		lda #$00			lda 	#0 							; zero upper 2 bytes
.ec80	9d 02 20	sta $2002,x			sta 	FixedVariables+2,x
.ec83	9d 03 20	sta $2003,x			sta 	FixedVariables+3,x
.ec86	18		clc				clc
.ec87	a5 22		lda $22				lda 	zLowMemory
.ec89	6d 00 04	adc $0400			adc 	evalStack+0
.ec8c	85 22		sta $22				sta 	zLowMemory
.ec8e	a5 23		lda $23				lda 	zLowMemory+1
.ec90	6d 01 04	adc $0401			adc 	evalStack+1
.ec93	85 23		sta $23				sta 	zLowMemory+1
.ec95	b0 0f		bcs $eca6			bcs 	_CDIMMemory					; out of memory ?
.ec97	ad be 20	lda $20be			lda 	HighMemory
.ec9a	38		sec				sec
.ec9b	e5 22		sbc $22				sbc 	zLowMemory
.ec9d	ad bf 20	lda $20bf			lda 	HighMemory+1
.eca0	e5 23		sbc $23				sbc 	zLowMemory+1
.eca2	90 02		bcc $eca6			bcc 	_CDIMMemory
.eca4	80 88		bra $ec2e			bra 	Command_DIM 				; go back try another.
.eca6					_CDIMMemory:
.eca6	20 72 e1	jsr $e172			jsr 	ReportError
>eca9	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",$00
>ecb1	45 4d 4f 52 59 00

;******  Return to file: basic.asm


;******  Processing file: commands/dountil.asm

.ecb7					COMMAND_Do:
.ecb7	a9 9f		lda #$9f			lda 	#KW_DO						; push position with a DO token.
.ecb9	20 d7 ec	jsr $ecd7			jsr 	CDOPushPosOnStack
.ecbc	60		rts				rts
.ecbd					COMMAND_Until:
.ecbd	a9 9f		lda #$9f			lda 	#KW_DO 						; check TOS is a Do.
.ecbf	20 15 ed	jsr $ed15			jsr 	CDOCheckTopStack
.ecc2	a2 00		ldx #$00			ldx 	#0 							; evaluate the test
.ecc4	20 14 e2	jsr $e214			jsr 	EvaluateBase
.ecc7	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check if zero
.ecca	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.eccd	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ecd0	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ecd3	f0 2a		beq $ecff			beq 	CDOPullPosOffStack 			; zero, restore the position.
.ecd5	80 1e		bra $ecf5			bra 	CDOThrowPosOffStack			; non-zero chuck it.
.ecd7					CDOPushPosOnStack:
.ecd7	ae cb 20	ldx $20cb			ldx 	basicStackIndex
.ecda	48		pha				pha
.ecdb	98		tya				tya
.ecdc	9d 01 02	sta $0201,x			sta 	BasicStack+1,x 				; +1 	Y Position
.ecdf	a5 20		lda $20				lda 	zCurrentLine
.ece1	9d 02 02	sta $0202,x			sta 	BasicStack+2,x 				; +2 	low of pos
.ece4	a5 21		lda $21				lda 	zCurrentLine+1
.ece6	9d 03 02	sta $0203,x			sta 	BasicStack+3,x 				; +3 	high of pos
.ece9	68		pla				pla
.ecea	9d 04 02	sta $0204,x			sta 	BasicStack+4,x 				; +4 	token on stack
.eced	e8		inx				inx
.ecee	e8		inx				inx
.ecef	e8		inx				inx
.ecf0	e8		inx				inx 								; always points to TOS.
.ecf1	8e cb 20	stx $20cb			stx 	basicStackIndex
.ecf4	60		rts				rts
.ecf5					CDOThrowPosOffStack:
.ecf5	ad cb 20	lda $20cb			lda 	basicStackIndex
.ecf8	38		sec				sec
.ecf9	e9 04		sbc #$04			sbc 	#4
.ecfb	8d cb 20	sta $20cb			sta 	basicStackIndex
.ecfe	60		rts				rts
.ecff					CDOPullPosOffStack:
.ecff	ae cb 20	ldx $20cb			ldx 	basicStackIndex
.ed02	ca		dex				dex
.ed03	ca		dex				dex
.ed04	ca		dex				dex
.ed05	ca		dex				dex
.ed06	bd 01 02	lda $0201,x			lda 	BasicStack+1,x 					; get position back.
.ed09	a8		tay				tay
.ed0a	bd 02 02	lda $0202,x			lda 	BasicStack+2,x
.ed0d	85 20		sta $20				sta 	zCurrentLine
.ed0f	bd 03 02	lda $0203,x			lda 	BasicStack+3,x
.ed12	85 21		sta $21				sta 	zCurrentLine+1
.ed14	60		rts				rts
.ed15					CDOCheckTopStack:
.ed15	ae cb 20	ldx $20cb			ldx 	basicStackIndex 			; if match
.ed18	dd 00 02	cmp $0200,x			cmp 	BasicStack+0,x
.ed1b	d0 01		bne $ed1e			bne 	_CDOCTSError
.ed1d	60		rts				rts
.ed1e					_CDOCTSError:
.ed1e	20 72 e1	jsr $e172			jsr 	ReportError
>ed21	53 54 52 55 43 54 55 52				.text 	"STRUCTURE MIXED",$00
>ed29	45 20 4d 49 58 45 44 00

;******  Return to file: basic.asm


;******  Processing file: commands/goto.asm

.ed31					COMMAND_Goto:
.ed31	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.ed33	20 14 e2	jsr $e214			jsr 	EvaluateBase
.ed36					CMDGoto:
.ed36	20 5b ed	jsr $ed5b			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.ed39	a5 28		lda $28				lda 	zTargetAddr 				; new line
.ed3b	85 20		sta $20				sta 	zCurrentLine
.ed3d	a5 29		lda $29				lda 	zTargetAddr+1
.ed3f	85 21		sta $21				sta 	zCurrentLine+1
.ed41	a0 03		ldy #$03			ldy 	#3
.ed43	60		rts				rts
.ed44					COMMAND_Gosub:
.ed44	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.ed46	20 14 e2	jsr $e214			jsr 	EvaluateBase
.ed49	a9 a3		lda #$a3			lda 	#KW_GOSUB
.ed4b	20 d7 ec	jsr $ecd7			jsr 	CDOPushPosOnStack 			; save return address on stack.
.ed4e	80 e6		bra $ed36			bra 	CMDGoto
.ed50					COMMAND_Return:
.ed50	a9 a3		lda #$a3			lda 	#KW_GOSUB 					; check GOSUB on BASIC Stack.
.ed52	20 15 ed	jsr $ed15			jsr 	CDOCheckTopStack
.ed55	20 ff ec	jsr $ecff			jsr 	CDOPullPosOffStack 			; restore
.ed58	4c f5 ec	jmp $ecf5			jmp 	CDOThrowPosOffStack 		; and drop it.
.ed5b					FindProgramLine:
.ed5b	ad 02 04	lda $0402			lda 	evalStack+2 				; check in range 0-65535
.ed5e	0d 03 04	ora $0403			ora 	evalStack+3
.ed61	d0 2e		bne $ed91			bne		_FPLFail
.ed63	a9 00		lda #$00			lda 	#BasicProgram & 255 		; start of code
.ed65	85 28		sta $28				sta 	zTargetAddr
.ed67	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ed69	85 29		sta $29				sta 	zTargetAddr+1
.ed6b					_FPLLoop:
.ed6b	a0 00		ldy #$00			ldy 	#0 							; reached end
.ed6d	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ed6f	f0 20		beq $ed91			beq 	_FPLFail
.ed71	c8		iny				iny 								; check line numbers
.ed72	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ed74	cd 00 04	cmp $0400			cmp 	evalStack+0
.ed77	d0 09		bne $ed82			bne 	_FPLNext
.ed79	c8		iny				iny
.ed7a	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ed7c	cd 01 04	cmp $0401			cmp 	evalStack+1
.ed7f	d0 01		bne $ed82			bne 	_FPLNext
.ed81	60		rts				rts
.ed82					_FPLNext:
.ed82	a0 00		ldy #$00			ldy 	#0 							; go to next
.ed84	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ed86	18		clc				clc
.ed87	65 28		adc $28				adc 	zTargetAddr
.ed89	85 28		sta $28				sta 	zTargetAddr
.ed8b	90 de		bcc $ed6b			bcc 	_FPLLoop
.ed8d	e6 29		inc $29				inc 	zTargetAddr+1
.ed8f	80 da		bra $ed6b			bra 	_FPLLoop
.ed91					_FPLFail:
.ed91	20 72 e1	jsr $e172			jsr 	ReportError
>ed94	4c 49 4e 45 20 4e 4f 54				.text 	"LINE NOT FOUND",$00
>ed9c	20 46 4f 55 4e 44 00

;******  Return to file: basic.asm


;******  Processing file: commands/if.asm

.eda3					COMMAND_IF:
.eda3	a2 00		ldx #$00			ldx 	#0 							; do test
.eda5	20 14 e2	jsr $e214			jsr 	EvaluateBase
.eda8	ad 00 04	lda $0400			lda 	evalStack+0 				; check if test 0
.edab	0d 01 04	ora $0401			ora 	evalStack+1
.edae	0d 02 04	ora $0402			ora 	evalStack+2
.edb1	0d 03 04	ora $0403			ora 	evalStack+3
.edb4	f0 01		beq $edb7			beq 	_CIFSkip 					; if not, then skip to ELSE token or EOL.
.edb6					_CIFExit:
.edb6	60		rts				rts
.edb7					_CIFSkip:
.edb7	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; found EOL ?
.edb9	f0 fb		beq $edb6			beq 	_CIFExit
.edbb	c8		iny				iny 								; is it ELSE
.edbc	c9 a0		cmp #$a0			cmp 	#KW_ELSE
.edbe	d0 f7		bne $edb7			bne 	_CIFSkip 					; no, keep going
.edc0	60		rts				rts
.edc1					COMMAND_THEN:
.edc1	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; find first non space
.edc3	c8		iny				iny
.edc4	c9 20		cmp #$20			cmp 	#" "
.edc6	f0 f9		beq $edc1			beq 	COMMAND_THEN
.edc8	88		dey				dey
.edc9	c9 30		cmp #$30			cmp 	#"0" 						; THEN x is THEN GOTO x
.edcb	90 07		bcc $edd4			bcc 	_CTHNoBranch
.edcd	c9 3a		cmp #$3a			cmp 	#"9"+1
.edcf	b0 03		bcs $edd4			bcs 	_CTHNoBranch
.edd1	4c 31 ed	jmp $ed31			jmp 	Command_GOTO 				; so do the GOTO code.
.edd4					_CTHNoBranch:
.edd4	60		rts				rts
.edd5					COMMAND_ELSE:
.edd5	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.edd7	c8		iny				iny
.edd8	c9 00		cmp #$00			cmp 	#0
.edda	d0 f9		bne $edd5			bne 	COMMAND_ELSE
.eddc	88		dey				dey
.eddd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.edde					COMMAND_Let:
.edde	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ede0	f0 58		beq $ee3a			beq 	_CLESyntax
.ede2	c8		iny				iny
.ede3	c9 20		cmp #$20			cmp 	#32
.ede5	f0 f7		beq $edde			beq 	COMMAND_Let
.ede7	88		dey				dey
.ede8	c9 96		cmp #$96			cmp 	#KW_QUESTION				; check for first being indirect.
.edea	f0 51		beq $ee3d			beq 	_CLEIndirect 				; e.g. !x = 42
.edec	c9 80		cmp #$80			cmp 	#KW_PLING
.edee	f0 4d		beq $ee3d			beq 	_CLEIndirect
.edf0	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.edf2	f0 49		beq $ee3d			beq 	_CLEIndirect
.edf4	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.edf6	20 27 e4	jsr $e427			jsr 	VARReference 				; get a variable reference.
.edf9	a5 24		lda $24				lda 	zTemp1 						; copy into target addr
.edfb	85 28		sta $28				sta 	zTargetAddr
.edfd	a5 25		lda $25				lda 	zTemp1+1
.edff	85 29		sta $29				sta 	zTargetAddr+1
.ee01	a5 26		lda $26				lda 	zTemp1+2
.ee03	85 2a		sta $2a				sta 	zTargetAddr+2
.ee05	a5 27		lda $27				lda 	zTemp1+3
.ee07	85 2b		sta $2b				sta 	zTargetAddr+3
.ee09					_CLEGetBinLHSOp:
.ee09	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ee0b	f0 2d		beq $ee3a			beq 	_CLESyntax
.ee0d	c8		iny				iny
.ee0e	c9 20		cmp #$20			cmp 	#' '
.ee10	f0 f7		beq $ee09			beq 	_CLEGetBinLHSOp
.ee12	88		dey				dey
.ee13	c9 96		cmp #$96			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ee15	f0 45		beq $ee5c			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ee17	c9 80		cmp #$80			cmp 	#KW_PLING
.ee19	f0 41		beq $ee5c			beq 	_CLEBinaryLHTerm
.ee1b	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ee1d	f0 3d		beq $ee5c			beq 	_CLEBinaryLHTerm
.ee1f	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ee21					_CLEWriteToAddress:
.ee21	48		pha				pha 								; save write-type.
.ee22	a9 93		lda #$93			lda 	#KW_EQUAL 					; check for '=' sign.
.ee24	20 b8 e1	jsr $e1b8			jsr 	CheckNextCharacter
.ee27	20 14 e2	jsr $e214			jsr 	EvaluateBase 				; evaluate the RHS.
.ee2a	68		pla				pla
.ee2b	c9 80		cmp #$80			cmp 	#KW_PLING
.ee2d	f0 6f		beq $ee9e			beq 	_CLEWordWrite
.ee2f	c9 96		cmp #$96			cmp 	#KW_QUESTION
.ee31	f0 60		beq $ee93			beq 	_CLEByteWrite
.ee33	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ee35					_ErrorInternal:
.ee35	d0 fe		bne $ee35			bne 	_ErrorInternal
.ee37	4c bb ee	jmp $eebb			jmp 	_CLEStringWrite
.ee3a					_CLESyntax:
.ee3a	4c 62 e1	jmp $e162			jmp 	SyntaxError
.ee3d					_CLEIndirect:
.ee3d	48		pha				pha 								; save operator on stack
.ee3e	c8		iny				iny									; advance over cursor
.ee3f	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ee41	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel
.ee44	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.ee47	85 28		sta $28				sta 	zTargetAddr+0
.ee49	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee4c	85 29		sta $29				sta 	zTargetAddr+1
.ee4e	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ee51	85 2a		sta $2a				sta 	zTargetAddr+2
.ee53	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ee56	85 2b		sta $2b				sta 	zTargetAddr+3
.ee58	68		pla				pla 								; restore operator.
.ee59	4c 21 ee	jmp $ee21			jmp 	_CLEWriteToAddress
.ee5c					_CLEBinaryLHTerm:
.ee5c	48		pha				pha 								; save operator on stack
.ee5d	c8		iny				iny 								; skip over it.
.ee5e	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ee60	20 10 e2	jsr $e210			jsr 	EvaluateAtomCurrentLevel
.ee63	a5 28		lda $28				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.ee65	85 24		sta $24				sta 	zTemp1 						; a four byte address.....
.ee67	a5 29		lda $29				lda 	zTargetAddr+1
.ee69	85 25		sta $25				sta 	zTemp1+1 					; we only worry about 4 byte value
.ee6b	5a		phy				phy 								; save Y
.ee6c	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.ee6d	a0 00		ldy #$00			ldy 	#0
.ee6f	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee71	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.ee74	85 28		sta $28				sta 	zTargetAddr+0
.ee76	c8		iny				iny
.ee77	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee79	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.ee7c	85 29		sta $29				sta 	zTargetAddr+1
.ee7e	c8		iny				iny
.ee7f	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee81	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.ee84	85 2a		sta $2a				sta 	zTargetAddr+2
.ee86	c8		iny				iny
.ee87	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee89	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.ee8c	85 2b		sta $2b				sta 	zTargetAddr+3
.ee8e	7a		ply				ply 								; restore Y
.ee8f	68		pla				pla 								; restore the operator.
.ee90	4c 21 ee	jmp $ee21			jmp 	_CLEWriteToAddress
.ee93					_CLEByteWrite:
.ee93	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ee96	5a		phy				phy 								; write the byte preserving Y
.ee97	a0 00		ldy #$00			ldy 	#0
.ee99	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee9b	7a		ply				ply
.ee9c	60		rts				rts
.ee9d					_CLEByteWriteExt:
.ee9d	60		rts				rts
.ee9e					_CLEWordWrite:
.ee9e	5a		phy				phy
.ee9f	a0 00		ldy #$00			ldy 	#0
.eea1	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.eea4	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eea6	c8		iny				iny
.eea7	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eeaa	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eeac	c8		iny				iny
.eead	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eeb0	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eeb2	c8		iny				iny
.eeb3	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eeb6	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eeb8	7a		ply				ply 								; restore Y
.eeb9	60		rts				rts
.eeba					_CLEWordWriteExt:
.eeba	60		rts				rts
.eebb					_CLEStringWrite:
.eebb	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.eebe	85 24		sta $24				sta 	zTemp1
.eec0	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eec3	85 25		sta $25				sta 	zTemp1+1
.eec5	5a		phy				phy
.eec6	a0 00		ldy #$00			ldy 	#0
.eec8					_CLEStringCopy:
.eec8	b1 24		lda ($24),y			lda 	(zTemp1),y
.eeca	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eecc	c9 00		cmp #$00			cmp 	#0
.eece	f0 16		beq $eee6			beq	 	_CLEStringWritten
.eed0	c8		iny				iny
.eed1	d0 f5		bne $eec8			bne 	_CLEStringCopy
.eed3	20 72 e1	jsr $e172			jsr 	ReportError
>eed6	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>eede	4e 47 20 43 4f 50 59 00
.eee6					_CLEStringWritten:
.eee6	7a		ply				ply
.eee7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.eee8					COMMAND_List:
.eee8	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look first non space
.eeea	c8		iny				iny
.eeeb	c9 20		cmp #$20			cmp 	#' '
.eeed	f0 f9		beq $eee8			beq 	COMMAND_List
.eeef	88		dey				dey
.eef0	c9 30		cmp #$30			cmp 	#"0" 						; not digit, list all
.eef2	90 0e		bcc $ef02			bcc 	_CLIAll
.eef4	c9 3a		cmp #$3a			cmp 	#"9"+1
.eef6	b0 0a		bcs $ef02			bcs 	_CLIAll
.eef8	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.eefa	20 14 e2	jsr $e214			jsr 	EvaluateBase
.eefd	20 5b ed	jsr $ed5b			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.ef00	80 09		bra $ef0b			bra 	_CLIMain 					; list it.
.ef02					_CLIAll:
.ef02	5a		phy				phy
.ef03	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.ef05	85 28		sta $28				sta 	zTargetAddr
.ef07	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ef09	85 29		sta $29				sta 	zTargetAddr+1
.ef0b					_CLIMain:
.ef0b	a9 10		lda #$10			lda 	#16 						; print 16 lines
.ef0d	85 2a		sta $2a				sta 	zTargetAddr+2
.ef0f					_CLLILoop:
.ef0f	a0 00		ldy #$00			ldy 	#0
.ef11	b1 28		lda ($28),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.ef13	f0 14		beq $ef29			beq 	_CLLIExit
.ef15	20 2d ef	jsr $ef2d			jsr 	CLIOneLine 					; list one line.
.ef18	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.ef1a	18		clc				clc
.ef1b	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef1d	65 28		adc $28				adc 	zTargetAddr
.ef1f	85 28		sta $28				sta 	zTargetAddr
.ef21	90 02		bcc $ef25			bcc 	_CLLINoCarry
.ef23	e6 29		inc $29				inc 	zTargetAddr+1
.ef25					_CLLINoCarry:
.ef25	c6 2a		dec $2a				dec 	zTargetAddr+2 				; done all of them ?
.ef27	d0 e6		bne $ef0f			bne 	_CLLILoop
.ef29					_CLLIExit:
.ef29	7a		ply				ply
.ef2a	4c 23 f2	jmp $f223			jmp 	WarmStart
.ef2d					CLIOneLine:
.ef2d	a0 01		ldy #$01			ldy 	#1 							; get line#
.ef2f	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef31	8d 00 04	sta $0400			sta 	evalStack+0
.ef34	c8		iny				iny
.ef35	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef37	8d 01 04	sta $0401			sta 	evalStack+1
.ef3a	a9 00		lda #$00			lda 	#0
.ef3c	aa		tax				tax
.ef3d	8d 02 04	sta $0402			sta 	evalStack+2
.ef40	8d 03 04	sta $0403			sta 	evalStack+3
.ef43	20 1b f1	jsr $f11b			jsr 	CPRPrintInteger 			; print line#
.ef46	a9 20		lda #$20			lda 	#32
.ef48	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.ef4b	a0 03		ldy #$03			ldy 	#3 							; where to start
.ef4d					_CLIOutput:
.ef4d	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef4f	c8		iny				iny
.ef50	09 00		ora #$00			ora 	#0
.ef52	f0 0c		beq $ef60			beq 	_CLIExit
.ef54	10 05		bpl $ef5b			bpl		_CLISingle
.ef56	20 66 ef	jsr $ef66			jsr 	CLIPrintToken
.ef59	80 f2		bra $ef4d			bra 	_CLIOutput
.ef5b					_CLISingle:
.ef5b	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.ef5e	80 ed		bra $ef4d			bra 	_CLIOutput
.ef60					_CLIExit:
.ef60	a9 0d		lda #$0d			lda 	#13 						; new line.
.ef62	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.ef65	60		rts				rts
.ef66					CLIPrintToken:
.ef66	5a		phy				phy 								; save Y
.ef67	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.ef69	a8		tay				tay
.ef6a	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.ef6c					_CLIFind:
.ef6c	88		dey				dey 								; decrement counter
.ef6d	30 09		bmi $ef78			bmi 	_CLIFoundToken 				; if -ve found the token.
.ef6f					_CLISkip:
.ef6f	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.ef72	e8		inx				inx
.ef73	0a		asl a				asl		a
.ef74	90 f9		bcc $ef6f			bcc 	_CLISkip
.ef76	80 f4		bra $ef6c			bra 	_CLIFind
.ef78					_CLIFoundToken:
.ef78	7a		ply				ply
.ef79					_CLIPrintIt:
.ef79	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.ef7c	e8		inx				inx
.ef7d	48		pha				pha
.ef7e	29 7f		and #$7f			and 	#$7F
.ef80	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.ef83	68		pla				pla
.ef84	0a		asl a				asl 	a
.ef85	90 f2		bcc $ef79			bcc 	_CLIPrintIt
.ef87	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.ef88					COMMAND_Assert:
.ef88	20 14 e2	jsr $e214			jsr 	EvaluateBase 				; evaluate the expression
.ef8b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.ef8e	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ef91	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ef94	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ef97	d0 12		bne $efab			bne 	_CMDAExit
.ef99	ea		nop				nop
.ef9a	20 72 e1	jsr $e172			jsr 	ReportError
>ef9d	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>efa5	41 49 4c 45 44 00
.efab					_CMDAExit:
.efab	60		rts				rts
.efac					COMMAND_Rem:
.efac	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.efae	f0 05		beq $efb5			beq 	_CREMExit 					; End of line, then exit.
.efb0	c8		iny				iny 								; something to skip
.efb1	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; if not a colon
.efb3	d0 f7		bne $efac			bne 	COMMAND_Rem 				; keep searching
.efb5					_CREMExit:
.efb5	60		rts				rts
.efb6					COMMAND_NewExec:
.efb6	20 bc ef	jsr $efbc			jsr 	COMMAND_NewCode
.efb9	4c 23 f2	jmp $f223			jmp 	WarmStart
.efbc					COMMAND_NewCode:
.efbc	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.efbe	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.efc1	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.efc4	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.efc6	8d be 20	sta $20be			sta 	HighMemory
.efc9	a9 80		lda #$80			lda 	#endMemory >> 8
.efcb	8d bf 20	sta $20bf			sta 	HighMemory+1
.efce	60		rts				rts
.efcf					COMMAND_Clear:
.efcf	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.efd1					_CCClearVar:
.efd1	a9 00		lda #$00			lda 	#$00
.efd3	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.efd6	e8		inx				inx
.efd7	e0 6c		cpx #$6c			cpx 	#27*4
.efd9	10 f6		bpl $efd1			bpl 	_CCClearVar
.efdb	a9 00		lda #$00			lda 	#0 							; reset BASIC stack index
.efdd	8d cb 20	sta $20cb			sta 	basicStackIndex
.efe0	a9 ff		lda #$ff			lda 	#$FF 						; put invalid token on TOS, so when pulled.
.efe2	8d 00 02	sta $0200			sta 	basicStack 					; causes an error.
.efe5	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.efe7	85 22		sta $22				sta 	zLowMemory
.efe9	a9 23		lda #$23			lda 	#BasicProgram >> 8
.efeb	85 23		sta $23				sta 	zLowMemory+1
.efed					_CCFindEnd:
.efed	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.efef	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.eff1	f0 0b		beq $effe			beq 	_CCFoundEnd
.eff3	18		clc				clc 								; go to next line.
.eff4	65 22		adc $22				adc 	zLowMemory
.eff6	85 22		sta $22				sta 	zLowMemory
.eff8	90 f3		bcc $efed			bcc 	_CCFindEnd
.effa	e6 23		inc $23				inc 	zLowMemory+1
.effc	80 ef		bra $efed			bra 	_CCFindEnd
.effe					_CCFoundEnd:
.effe	e6 22		inc $22				inc 	zLowMemory 					; variables etc. start after end of program.
.f000	d0 02		bne $f004			bne 	_CCNoCarry 					; skip over zero end offset.
.f002	e6 23		inc $23				inc 	zLowMemory+1
.f004					_CCNoCarry:
.f004	60		rts				rts
.f005					COMMAND_OldExec:
.f005	20 0b f0	jsr $f00b			jsr 	COMMAND_OldCode
.f008	4c 23 f2	jmp $f223			jmp 	WarmStart
.f00b					COMMAND_OldCode:
.f00b	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.f00d	85 22		sta $22				sta 	zLowMemory
.f00f	a9 23		lda #$23			lda 	#BasicProgram >> 8
.f011	85 23		sta $23				sta 	zLowMemory+1
.f013	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.f015					_COScan:
.f015	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; look at next byte pair
.f017	c8		iny				iny
.f018	f0 0d		beq $f027			beq 	_COFail 					; can't find marker, corrupted maybe ?
.f01a	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.f01c	d0 f7		bne $f015			bne 	_COScan
.f01e	98		tya				tya 								; Y is the new offset to the next instruction
.f01f	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.f021	91 22		sta ($22),y			sta 	(zLowMemory),y
.f023	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.f026	60		rts				rts
.f027					_COFail:
.f027	20 72 e1	jsr $e172			jsr 	ReportError
>f02a	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>f032	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00
.f041					COMMAND_RST:
.f041	20 8e a0	jsr $a08e			jsr 	EXTReset
.f044	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.f045					COMMAND_Print:
.f045	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.f047	f0 29		beq $f072			beq 	_CPRExitNL 					; zero end of line.
.f049	c8		iny				iny
.f04a	c9 20		cmp #$20			cmp 	#' '
.f04c	f0 f7		beq $f045			beq 	COMMAND_Print
.f04e	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; colon, end of line
.f050	f0 20		beq $f072			beq 	_CPRExitNL
.f052	c9 8b		cmp #$8b			cmp 	#KW_COMMA 					; comma, tab
.f054	f0 0d		beq $f063			beq 	_CPRTab
.f056	c9 8f		cmp #$8f			cmp 	#KW_SEMICOLON 				; semicolon ?
.f058	d0 1e		bne $f078			bne 	_CPRNotSemicolon
.f05a	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.f05c	f0 19		beq $f077			beq 	_CPRExit
.f05e	c9 8e		cmp #$8e			cmp 	#KW_COLON
.f060	d0 e3		bne $f045			bne 	COMMAND_Print 				; if not, just go back round again
.f062	60		rts				rts
.f063	a9 09		lda #$09	_CPRTab:lda 	#9 							; print tab.
.f065	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.f068	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next.
.f06a	f0 0b		beq $f077			beq 	_CPRExit 					; exit if 0 or :
.f06c	c9 8e		cmp #$8e			cmp 	#KW_COLON
.f06e	f0 07		beq $f077			beq 	_CPRExit
.f070	80 d3		bra $f045			bra 	COMMAND_Print
.f072					_CPRExitNL:
.f072	a9 0d		lda #$0d			lda 	#13
.f074	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.f077					_CPRExit:
.f077	60		rts				rts
.f078					_CPRNotSemicolon:
.f078	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.f07a	f0 2b		beq $f0a7			beq 	_CPRNewLine 				; new line
.f07c	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.f07e	d0 2e		bne $f0ae			bne 	_CPRNotQuote
.f080					_CPRPrintText:
.f080	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.f082	f0 0a		beq $f08e			beq 	_CPRError 					; if zero no closing quote
.f084	c8		iny				iny
.f085	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.f087	f0 bc		beq $f045			beq 	COMMAND_Print 				; go round again.
.f089	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter 			; print and do next character
.f08c	80 f2		bra $f080			bra 	_CPRPrintText
.f08e					_CPRError:
.f08e	20 72 e1	jsr $e172			jsr 	ReportError
>f091	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>f099	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.f0a7					_CPRNewLine:
.f0a7	a9 0d		lda #$0d			lda 	#13
.f0a9	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.f0ac	80 97		bra $f045			bra 	COMMAND_Print
.f0ae					_CPRNotQuote:
.f0ae	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.f0b0	d0 11		bne $f0c3			bne 	_CPRNumber 					; print a number.
.f0b2	20 14 e2	jsr $e214			jsr 	EvaluateBase 				; this is the address to print.
.f0b5	5a		phy				phy
.f0b6	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.f0b9	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.f0bc	aa		tax				tax
.f0bd	20 b4 e4	jsr $e4b4			jsr 	SIOPrintString
.f0c0	7a		ply				ply
.f0c1	80 82		bra $f045			bra 	COMMAND_Print
.f0c3					_CPRNumber:
.f0c3	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.f0c5	f0 17		beq $f0de			beq 	_CPRHexadecimal
.f0c7	88		dey				dey 								; must be 1st char of expr
.f0c8	20 14 e2	jsr $e214			jsr 	EvaluateBase 				; this is the value to print.
.f0cb	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.f0ce	10 08		bpl $f0d8			bpl 	_CPRIsPositive
.f0d0	20 5f ea	jsr $ea5f			jsr 	BFUNC_NegateAlways 			; negate it
.f0d3	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.f0d5	20 e1 e4	jsr $e4e1			jsr 	SIOPrintCharacter
.f0d8					_CPRIsPositive:
.f0d8	20 1b f1	jsr $f11b			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.f0db	4c 45 f0	jmp $f045			jmp 	COMMAND_Print
.f0de					_CPRHexadecimal:
.f0de	20 14 e2	jsr $e214			jsr 	EvaluateBase 				; this is the value to print.
.f0e1	20 e7 f0	jsr $f0e7			jsr 	_CPRPrintRecHex 			; hex version of it.
.f0e4	4c 45 f0	jmp $f045			jmp 	COMMAND_Print
.f0e7					_CPRPrintRecHex:
.f0e7	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.f0ea	29 0f		and #$0f			and 	#15 						; and put on stack
.f0ec	48		pha				pha
.f0ed	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.f0ef					_CPRShiftDiv:
.f0ef	4e 03 04	lsr $0403			lsr 	evalStack+3
.f0f2	6e 02 04	ror $0402			ror 	evalStack+2
.f0f5	6e 01 04	ror $0401			ror		evalStack+1
.f0f8	6e 00 04	ror $0400			ror		evalStack+0
.f0fb	ca		dex				dex
.f0fc	d0 f1		bne $f0ef			bne 	_CPRShiftDiv
.f0fe	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.f101	0d 01 04	ora $0401			ora 	evalStack+1
.f104	0d 02 04	ora $0402			ora 	evalStack+2
.f107	0d 03 04	ora $0403			ora 	evalStack+3
.f10a	f0 03		beq $f10f			beq 	_CPRNoHexRec
.f10c	20 e7 f0	jsr $f0e7			jsr 	_CPRPrintRecHex
.f10f					_CPRNoHexRec:
.f10f	68		pla				pla 								; original remainder.
.f110	c9 0a		cmp #$0a			cmp 	#10
.f112	90 02		bcc $f116			bcc		_CPRNH2
.f114	69 06		adc #$06			adc 	#6
.f116	69 30		adc #$30	_CPRNH2:adc 	#48
.f118	4c e1 e4	jmp $e4e1			jmp 	SIOPrintCharacter
.f11b					CPRPrintInteger:
.f11b	48		pha				pha 								; save on stack.
.f11c	da		phx				phx
.f11d	5a		phy				phy
.f11e	20 25 f1	jsr $f125			jsr 	_CPRPrintRec 				; recursive print call
.f121	7a		ply				ply
.f122	fa		plx				plx
.f123	68		pla				pla
.f124	60		rts				rts
.f125					_CPRPrintRec:
.f125	a9 0a		lda #$0a			lda 	#10 						; save base
.f127	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.f12a	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.f12c	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.f12f	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.f132	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.f135	20 bc e9	jsr $e9bc			jsr 	BFUNC_Divide 				; divide by 10.
.f138	ad c0 20	lda $20c0			lda 	Temp1+0		 				; push remainder on stack
.f13b	48		pha				pha
.f13c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.f13f	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.f142	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.f145	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f148	f0 03		beq $f14d			beq 	_CPRNoRecurse
.f14a	20 25 f1	jsr $f125			jsr 	_CPRPrintRec 				; recursive print.
.f14d					_CPRNoRecurse:
.f14d	68		pla				pla
.f14e	09 30		ora #$30			ora 	#"0"
.f150	4c e1 e4	jmp $e4e1			jmp 	SIOPrintCharacter
.f153					COMMAND_CLS:
.f153	4c a6 e4	jmp $e4a6			jmp 	SIOClearScreen

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.f156					COMMAND_Run:
.f156	20 cf ef	jsr $efcf			jsr 	COMMAND_Clear 				; clear everything for a new run.
.f159	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.f15b	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.f15d	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.f15f	84 21		sty $21				sty 	zCurrentLine+1
.f161					CRUNNewLine:
.f161	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.f163	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f165	f0 78		beq $f1df			beq 	COMMAND_End 				; if zero, off end of program so stop.
.f167	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.f169					CRUNNextInstruction:
.f169	ee ca 20	inc $20ca			inc 	breakCheckCount 			; don't check every time, might be slow.
.f16c	ad ca 20	lda $20ca			lda 	breakCheckCount
.f16f	29 1f		and #$1f			and 	#$1F 						; checking once in 32.
.f171	f0 0e		beq $f181			beq 	_CRUNNoCheck
.f173	20 1a a0	jsr $a01a			jsr 	EXTCheckBreak
.f176	f0 09		beq $f181			beq 	_CRUNNoCheck
.f178	20 72 e1	jsr $e172			jsr 	ReportError
>f17b	42 52 45 41 4b 00				.text 	"BREAK",$00
.f181					_CRUNNoCheck:
.f181	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.f183	8d c5 20	sta $20c5			sta 	StringBufferPos
.f186	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.f188	f0 0b		beq $f195			beq 	CRUNNextLine 				; if zero, then end of line.
.f18a					CRUNNotEndOfLine:
.f18a	c9 20		cmp #$20			cmp 	#' '
.f18c	f0 04		beq $f192			beq 	CRUNSkipLoop
.f18e	c9 8e		cmp #$8e			cmp 	#KW_Colon 					; check for a colon first.
.f190	d0 1b		bne $f1ad			bne 	CRUNExecuteOne 				; if not that, execute the token.
.f192					CRUNSkipLoop:
.f192	c8		iny				iny		 							; if colon, skip it and loop round.
.f193	80 d4		bra $f169			bra 	CRUNNextInstruction
.f195					CRUNNextLine:
.f195	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.f197	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.f199	f0 0f		beq $f1aa			beq		CRUNWarmStart
.f19b	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.f19d	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f19f	18		clc				clc
.f1a0	65 20		adc $20				adc 	zCurrentLine
.f1a2	85 20		sta $20				sta 	zCurrentLine
.f1a4	90 bb		bcc $f161			bcc 	CRUNNewLine
.f1a6	e6 21		inc $21				inc 	zCurrentLine+1
.f1a8	80 b7		bra $f161			bra 	CRUNNewLine
.f1aa					CRUNWarmStart:
.f1aa	4c 23 f2	jmp $f223			jmp 	WarmStart
.f1ad					CRUNExecuteOne:
.f1ad	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.f1af	10 21		bpl $f1d2			bpl		_CRUNX1TryLet
.f1b1	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.f1b3	f0 1d		beq $f1d2			beq 	_CRUNX1TryLet
.f1b5	c9 80		cmp #$80			cmp 	#KW_PLING
.f1b7	f0 19		beq $f1d2			beq 	_CRUNX1TryLet
.f1b9	c9 96		cmp #$96			cmp 	#KW_QUESTION
.f1bb	f0 15		beq $f1d2			beq 	_CRUNX1TryLet
.f1bd	c8		iny				iny 								; skip over loaded token
.f1be	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.f1bf	8d c1 20	sta $20c1			sta 	Temp1+1 					; this is the low byte into the KVT
.f1c2	8a		txa				txa
.f1c3	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.f1c5	8d c2 20	sta $20c2			sta 	Temp1+2
.f1c8	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.f1ca	8d c0 20	sta $20c0			sta 	Temp1+0
.f1cd	20 c0 20	jsr $20c0			jsr 	Temp1 						; call instruction
.f1d0	80 97		bra $f169			bra 	CRUNNextInstruction 		; do next instruction.
.f1d2					_CRUNX1TryLet:
.f1d2	20 de ed	jsr $edde			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.f1d5	80 92		bra $f169			bra 	CRUNNextInstruction
.f1d7					COMMAND_Stop:
.f1d7	20 72 e1	jsr $e172			jsr 	ReportError
>f1da	53 54 4f 50 00					.text 	"STOP",$00
.f1df					COMMAND_End:
.f1df	ad 3a 23	lda $233a			lda 	StartBehaviour 				; running program
.f1e2	c9 52		cmp #$52			cmp 	#"R"
.f1e4	d0 01		bne $f1e7			bne 	_CEWarmStart
>f1e6	02						.byte 	2
.f1e7					_CEWarmStart:
.f1e7	4c 23 f2	jmp $f223			jmp 	WarmStart

;******  Return to file: basic.asm

.f1ea					Start:
.f1ea	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f1ec	9a		txs			txs
.f1ed	20 a3 e4	jsr $e4a3			jsr 	SIOInitialise 				; initialise the I/O system.
.f1f0	a2 63		ldx #$63			ldx 	#BootMsg1 & 255 			; boot text.
.f1f2	a0 f2		ldy #$f2			ldy 	#BootMsg1 >> 8
.f1f4	20 b4 e4	jsr $e4b4			jsr 	SIOPrintString
.f1f7	a2 ff		ldx #$ff			ldx 	#(endMemory-startMemory-1) & $FF
.f1f9	a0 5f		ldy #$5f			ldy 	#(endMemory-startMemory-1) >> 8
.f1fb	20 a1 e1	jsr $e1a1			jsr 	PrintWordInteger
.f1fe	a2 7a		ldx #$7a			ldx 	#BootMsg2 & 255
.f200	a0 f2		ldy #$f2			ldy 	#BootMsg2 >> 8
.f202	20 b4 e4	jsr $e4b4			jsr 	SIOPrintString
.f205	ad 3a 23	lda $233a			lda 	StartBehaviour 				; what to do ?
.f208	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.f20a	f0 14		beq $f220			beq		CommandLine
.f20c	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.f20e	f0 07		beq $f217			beq	 	RunProgram
.f210	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.f212	f0 43		beq $f257			beq 	TokeniseExec
.f214	4c 62 e1	jmp $e162			jmp		SyntaxError
.f217					RunProgram:
.f217	20 bc ef	jsr $efbc			jsr 	COMMAND_NewCode 			; do a new
.f21a	20 0b f0	jsr $f00b			jsr 	COMMAND_OldCode 			; get back the old program as we're deving.
.f21d	4c 56 f1	jmp $f156			jmp 	COMMAND_Run
.f220					CommandLine:
.f220	20 bc ef	jsr $efbc			jsr 	Command_NewCode
.f223					WarmStart:
.f223	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f225	9a		txs			txs
.f226	20 30 e5	jsr $e530			jsr 	SIOReadLine 				; read input line.
.f229	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.f22b	85 24		sta $24				sta 	zTemp1
.f22d	a9 20		lda #$20			lda 	#InputLine >> 8
.f22f	85 25		sta $25				sta 	zTemp1+1
.f231	20 a0 e6	jsr $e6a0			jsr 	TokeniseString
.f234	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.f236	85 20		sta $20				sta 	zCurrentLine
.f238	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.f23a	85 21		sta $21				sta 	zCurrentLine+1
.f23c	a0 00		ldy #$00			ldy 	#0
.f23e					_WSSkipSpace:
.f23e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f240	c8		iny				iny
.f241	c9 20		cmp #$20			cmp 	#' '
.f243	f0 f9		beq $f23e			beq 	_WSSkipSpace
.f245	88		dey				dey
.f246	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.f248	90 0a		bcc $f254			bcc 	_WSExecute
.f24a	c9 3a		cmp #$3a			cmp 	#"9"+1
.f24c	b0 06		bcs $f254			bcs 	_WSExecute
.f24e	20 75 e7	jsr $e775			jsr 	EditProgram
.f251	4c 23 f2	jmp $f223			jmp 	WarmStart
.f254					_WSExecute:
.f254	4c 69 f1	jmp $f169			jmp 	CRUNNextInstruction
.f257					TokeniseExec:
.f257	a9 00		lda #$00			lda 	#IncludeBasicCode & $FF 	; if so tokenise whatever I've put in the basic code
.f259	85 24		sta $24				sta 	zTemp1 						; area
.f25b	a9 23		lda #$23			lda 	#IncludeBasicCode >> 8
.f25d	85 25		sta $25				sta 	zTemp1+1
.f25f	20 a0 e6	jsr $e6a0			jsr 	TokeniseString
>f262	02						.byte 	2
.f263					BootMsg1:
>f263	2a 2a 2a 20 41 54 4f 4d				.text 	"*** ATOMIC BASIC ***",13,13,0
>f26b	49 43 20 42 41 53 49 43 20 2a 2a 2a 0d 0d 00
.f27a					BootMsg2:
>f27a	20 42 59 54 45 53 20 46				.text	" BYTES FREE.",13,13,0
>f282	52 45 45 2e 0d 0d 00

;******  End of listing
