
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D TARGET=2 -b -L rom.lst -o rom.bin basic.asm
; Mon Jul 29 19:41:56 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	e5 ef						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_6502.asm

>0000	00					.byte 	0
=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$0800					EXTLowMemory = $0800 						; Workspace RAM starts here
=$6000					EXTHighMemory = $6000 						; Workspace RAM ends here
=$b000					PScreen = $B000								; 1k screen RAM here
=$b800					PKeyboard = $B800							; Keyboard port.
=$b801					PBreak = $B801 								; Break key.
.a000					EXTStartPersonalise:
.a000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.a002	9a		txs			txs
.a003	20 82 a0	jsr $a082		jsr 	EXTReset 						; reset video
.a006	20 38 a0	jsr $a038		jsr 	EXTClearScreen 					; clear screen
.a009	4c e5 ef	jmp $efe5		jmp 	Start 							; start main application
.a00c					EXTReadKeyPort:
.a00c	ad 00 b8	lda $b800		lda 	PKeyboard							; read key
.a00f	09 00		ora #$00		ora 	#0
.a011	60		rts			rts
.a012					EXTRemoveKeyPressed:
.a012	48		pha			pha 										; key pressed clear queue byte.
.a013	a9 00		lda #$00		lda 	#0
.a015	8d 00 b8	sta $b800		sta 	PKeyboard
.a018	68		pla			pla
.a019	60		rts			rts
.a01a					EXTCheckBreak:
.a01a	ad 01 b8	lda $b801		lda 	PBreak
.a01d	60		rts			rts
.a01e					EXTReadScreen:
.a01e	5a		phy			phy 										; save Y
.a01f	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.a021	98		tya			tya
.a022	09 b0		ora #$b0		ora 	#PScreen>>8 						; move into screen area
.a024	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.a026	a0 00		ldy #$00		ldy 	#0
.a028	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a02a	7a		ply			ply 										; restore Y and exit.
.a02b	60		rts			rts
.a02c					EXTWriteScreen:
.a02c	5a		phy			phy
.a02d	48		pha			pha
.a02e	20 1e a0	jsr $a01e		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.a031	a0 00		ldy #$00		ldy 	#0
.a033	68		pla			pla 										; restore and write.
.a034	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a036	7a		ply			ply
.a037	60		rts			rts
.a038					EXTClearScreen:
.a038	48		pha			pha 										; save registers
.a039	da		phx			phx
.a03a	a2 00		ldx #$00		ldx 	#0
.a03c					_EXTCSLoop:
.a03c	a9 20		lda #$20		lda 	#32
.a03e	9d 00 b0	sta $b000,x		sta 	PScreen+0,x
.a041	9d 00 b1	sta $b100,x		sta 	PScreen+$100,x
.a044	9d 00 b2	sta $b200,x		sta 	PScreen+$200,x
.a047	9d 00 b3	sta $b300,x		sta 	PScreen+$300,x
.a04a	e8		inx			inx
.a04b	d0 ef		bne $a03c		bne 	_EXTCSLoop
.a04d	fa		plx			plx 										; restore
.a04e	68		pla			pla
.a04f	60		rts			rts
.a050					EXTScrollDisplay:
.a050	48		pha			pha 										; save registers
.a051	5a		phy			phy
.a052	a9 00		lda #$00		lda 	#PScreen & $FF 					; set pointer to screen
.a054	85 04		sta $04			sta 	EXTZPWork+0
.a056	a9 b0		lda #$b0		lda 	#PScreen >> 8
.a058	85 05		sta $05			sta 	EXTZPWork+1
.a05a					_EXTScroll:
.a05a	a0 28		ldy #$28		ldy 	#EXTWidth
.a05c	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a05e	a0 00		ldy #$00		ldy 	#0
.a060	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a062	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.a064	d0 02		bne $a068		bne 	_EXTNoCarry
.a066	e6 05		inc $05			inc 	EXTZPWork+1
.a068					_EXTNoCarry:
.a068	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.a06a	c9 c0		cmp #$c0		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) & $FF
.a06c	d0 ec		bne $a05a		bne 	_EXTScroll
.a06e	a5 05		lda $05			lda 	EXTZPWork+1
.a070	c9 b3		cmp #$b3		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) >> 8
.a072	d0 e6		bne $a05a		bne 	_EXTScroll
.a074	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.a076					_EXTLastLine:
.a076	a9 20		lda #$20		lda 	#32
.a078	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a07a	c8		iny			iny
.a07b	c0 28		cpy #$28		cpy 	#EXTWidth
.a07d	d0 f7		bne $a076		bne 	_EXTLastLine
.a07f	7a		ply			ply 										; restore and exit.
.a080	68		pla			pla
.a081	60		rts			rts
.a082					EXTReset:
.a082	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	5e e8					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	2d e1					.word	SyntaxError                   ; """        ($0081)
>e004	2d e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	53 e8					.word	BFUNC_String                  ; "$"        ($0083)
>e008	f3 e9					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	65 e8					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	2d e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	2d e1					.word	SyntaxError                   ; "("        ($0087)
>e010	2d e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	d4 e8					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	07 e8					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	2d e8					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	2b e9					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	2d e1					.word	SyntaxError                   ; ":"        ($008d)
>e01c	2d e1					.word	SyntaxError                   ; ";"        ($008e)
>e01e	71 ea					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	12 ea					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	4c ea					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	0f ea					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	4f ea					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	6e ea					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	57 e8					.word	BFUNC_ByteInd                 ; "?"        ($0095)
>e02c	af e8					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	29 ec					.word	COMMAND_Assert                ; "assert"   ($0097)
>e030	28 eb					.word	UNARY_Abs                     ; "abs"      ($0098)
>e032	70 ec					.word	COMMAND_Clear                 ; "clear"    ($0099)
>e034	e4 ee					.word	COMMAND_CLS                   ; "cls"      ($009a)
>e036	13 eb					.word	UNARY_Ch                      ; "ch"       ($009b)
>e038	6b ef					.word	COMMAND_Do                    ; "do"       ($009c)
>e03a	1e ec					.word	COMMAND_End                   ; "end"      ($009d)
>e03c	2d e1					.word	SyntaxError                   ; "for"      ($009e)
>e03e	2d e1					.word	SyntaxError                   ; "gosub"    ($009f)
>e040	2d e1					.word	SyntaxError                   ; "goto"     ($00a0)
>e042	2d e1					.word	SyntaxError                   ; "input"    ($00a1)
>e044	2d e1					.word	SyntaxError                   ; "if"       ($00a2)
>e046	e7 ee					.word	COMMAND_List                  ; "list"     ($00a3)
>e048	2d e1					.word	SyntaxError                   ; "link"     ($00a4)
>e04a	e2 ec					.word	COMMAND_Let                   ; "let"      ($00a5)
>e04c	d1 ea					.word	UNARY_Len                     ; "len"      ($00a6)
>e04e	2d e1					.word	SyntaxError                   ; "next"     ($00a7)
>e050	57 ec					.word	COMMAND_NewExec               ; "new"      ($00a8)
>e052	a6 ec					.word	COMMAND_OldExec               ; "old"      ($00a9)
>e054	ea ed					.word	COMMAND_Print                 ; "print"    ($00aa)
>e056	45 eb					.word	UNARY_Page                    ; "page"     ($00ab)
>e058	4d ec					.word	COMMAND_Rem                   ; "rem"      ($00ac)
>e05a	95 eb					.word	COMMAND_Run                   ; "run"      ($00ad)
>e05c	58 eb					.word	UNARY_Rnd                     ; "rnd"      ($00ae)
>e05e	16 ec					.word	COMMAND_Stop                  ; "stop"     ($00af)
>e060	2d e1					.word	SyntaxError                   ; "step"     ($00b0)
>e062	2d e1					.word	SyntaxError                   ; "then"     ($00b1)
>e064	30 eb					.word	UNARY_Top                     ; "top"      ($00b2)
>e066	2d e1					.word	SyntaxError                   ; "to"       ($00b3)
>e068	71 ef					.word	COMMAND_Until                 ; "until"    ($00b4)
>e06a	8a e8					.word	BFUNC_Or                      ; "|"        ($00b5)
>e06c	90 ea					.word	BFUNC_StringCompare           ; "~"        ($00b6)
.e06e					TokenText:
>e06e	a1					.byte $a1                             ; $0080 !
>e06f	a2					.byte $a2                             ; $0081 "
>e070	a3					.byte $a3                             ; $0082 #
>e071	a4					.byte $a4                             ; $0083 $
>e072	a5					.byte $a5                             ; $0084 %
>e073	a6					.byte $a6                             ; $0085 &
>e074	a7					.byte $a7                             ; $0086 '
>e075	a8					.byte $a8                             ; $0087 (
>e076	a9					.byte $a9                             ; $0088 )
>e077	aa					.byte $aa                             ; $0089 *
>e078	ab					.byte $ab                             ; $008a +
>e079	ad					.byte $ad                             ; $008b -
>e07a	af					.byte $af                             ; $008c /
>e07b	ba					.byte $ba                             ; $008d :
>e07c	bb					.byte $bb                             ; $008e ;
>e07d	3c bd					.byte $3c,$bd                         ; $008f <=
>e07f	3c be					.byte $3c,$be                         ; $0090 <>
>e081	bc					.byte $bc                             ; $0091 <
>e082	bd					.byte $bd                             ; $0092 =
>e083	3e bd					.byte $3e,$bd                         ; $0093 >=
>e085	be					.byte $be                             ; $0094 >
>e086	bf					.byte $bf                             ; $0095 ?
>e087	de					.byte $de                             ; $0096 ^
>e088	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0097 assert
>e08e	41 42 d3				.byte $41,$42,$d3                     ; $0098 abs
>e091	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $0099 clear
>e096	43 4c d3				.byte $43,$4c,$d3                     ; $009a cls
>e099	43 c8					.byte $43,$c8                         ; $009b ch
>e09b	44 cf					.byte $44,$cf                         ; $009c do
>e09d	45 4e c4				.byte $45,$4e,$c4                     ; $009d end
>e0a0	46 4f d2				.byte $46,$4f,$d2                     ; $009e for
>e0a3	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $009f gosub
>e0a8	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $00a0 goto
>e0ac	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a1 input
>e0b1	49 c6					.byte $49,$c6                         ; $00a2 if
>e0b3	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a3 list
>e0b7	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00a4 link
>e0bb	4c 45 d4				.byte $4c,$45,$d4                     ; $00a5 let
>e0be	4c 45 ce				.byte $4c,$45,$ce                     ; $00a6 len
>e0c1	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00a7 next
>e0c5	4e 45 d7				.byte $4e,$45,$d7                     ; $00a8 new
>e0c8	4f 4c c4				.byte $4f,$4c,$c4                     ; $00a9 old
>e0cb	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00aa print
>e0d0	50 41 47 c5				.byte $50,$41,$47,$c5                 ; $00ab page
>e0d4	52 45 cd				.byte $52,$45,$cd                     ; $00ac rem
>e0d7	52 55 ce				.byte $52,$55,$ce                     ; $00ad run
>e0da	52 4e c4				.byte $52,$4e,$c4                     ; $00ae rnd
>e0dd	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00af stop
>e0e1	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00b0 step
>e0e5	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b1 then
>e0e9	54 4f d0				.byte $54,$4f,$d0                     ; $00b2 top
>e0ec	54 cf					.byte $54,$cf                         ; $00b3 to
>e0ee	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc             ; $00b4 until
>e0f3	fc					.byte $fc                             ; $00b5 |
>e0f4	fe					.byte $fe                             ; $00b6 ~
>e0f5	00					.byte $00
.e0f6					TokenTypeInformation:
>e0f6	04					.byte $04                             ; $0080 !
>e0f7	0a					.byte $0a                             ; $0081 "
>e0f8	0a					.byte $0a                             ; $0082 #
>e0f9	04					.byte $04                             ; $0083 $
>e0fa	03					.byte $03                             ; $0084 %
>e0fb	00					.byte $00                             ; $0085 &
>e0fc	0a					.byte $0a                             ; $0086 '
>e0fd	0a					.byte $0a                             ; $0087 (
>e0fe	0a					.byte $0a                             ; $0088 )
>e0ff	03					.byte $03                             ; $0089 *
>e100	02					.byte $02                             ; $008a +
>e101	02					.byte $02                             ; $008b -
>e102	03					.byte $03                             ; $008c /
>e103	0a					.byte $0a                             ; $008d :
>e104	0a					.byte $0a                             ; $008e ;
>e105	01					.byte $01                             ; $008f <=
>e106	01					.byte $01                             ; $0090 <>
>e107	01					.byte $01                             ; $0091 <
>e108	01					.byte $01                             ; $0092 =
>e109	01					.byte $01                             ; $0093 >=
>e10a	01					.byte $01                             ; $0094 >
>e10b	04					.byte $04                             ; $0095 ?
>e10c	00					.byte $00                             ; $0096 ^
>e10d	04					.byte $04                             ; $0097 assert
>e10e	09					.byte $09                             ; $0098 abs
>e10f	04					.byte $04                             ; $0099 clear
>e110	04					.byte $04                             ; $009a cls
>e111	09					.byte $09                             ; $009b ch
>e112	04					.byte $04                             ; $009c do
>e113	04					.byte $04                             ; $009d end
>e114	04					.byte $04                             ; $009e for
>e115	04					.byte $04                             ; $009f gosub
>e116	04					.byte $04                             ; $00a0 goto
>e117	04					.byte $04                             ; $00a1 input
>e118	04					.byte $04                             ; $00a2 if
>e119	04					.byte $04                             ; $00a3 list
>e11a	04					.byte $04                             ; $00a4 link
>e11b	04					.byte $04                             ; $00a5 let
>e11c	09					.byte $09                             ; $00a6 len
>e11d	04					.byte $04                             ; $00a7 next
>e11e	04					.byte $04                             ; $00a8 new
>e11f	04					.byte $04                             ; $00a9 old
>e120	04					.byte $04                             ; $00aa print
>e121	09					.byte $09                             ; $00ab page
>e122	04					.byte $04                             ; $00ac rem
>e123	04					.byte $04                             ; $00ad run
>e124	09					.byte $09                             ; $00ae rnd
>e125	04					.byte $04                             ; $00af stop
>e126	04					.byte $04                             ; $00b0 step
>e127	04					.byte $04                             ; $00b1 then
>e128	09					.byte $09                             ; $00b2 top
>e129	04					.byte $04                             ; $00b3 to
>e12a	04					.byte $04                             ; $00b4 until
>e12b	00					.byte $00                             ; $00b5 |
>e12c	01					.byte $01                             ; $00b6 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CLS = $009a
=$009b					KW_CH = $009b
=$009c					KW_DO = $009c
=$009d					KW_END = $009d
=$009e					KW_FOR = $009e
=$009f					KW_GOSUB = $009f
=$00a0					KW_GOTO = $00a0
=$00a1					KW_INPUT = $00a1
=$00a2					KW_IF = $00a2
=$00a3					KW_LIST = $00a3
=$00a4					KW_LINK = $00a4
=$00a5					KW_LET = $00a5
=$00a6					KW_LEN = $00a6
=$00a7					KW_NEXT = $00a7
=$00a8					KW_NEW = $00a8
=$00a9					KW_OLD = $00a9
=$00aa					KW_PRINT = $00aa
=$00ab					KW_PAGE = $00ab
=$00ac					KW_REM = $00ac
=$00ad					KW_RUN = $00ad
=$00ae					KW_RND = $00ae
=$00af					KW_STOP = $00af
=$00b0					KW_STEP = $00b0
=$00b1					KW_THEN = $00b1
=$00b2					KW_TOP = $00b2
=$00b3					KW_TO = $00b3
=$00b4					KW_UNTIL = $00b4
=$00b5					KW_BAR = $00b5
=$00b6					KW_TILDE = $00b6

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e12d					SyntaxError:
.e12d	20 3d e1	jsr $e13d			jsr 	ReportError
>e130	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e138	52 52 4f 52 00
.e13d					ReportError:
.e13d	fa		plx				plx
.e13e	7a		ply				ply
.e13f	e8		inx				inx
.e140	d0 01		bne $e143			bne 	_REPrint
.e142	c8		iny				iny
.e143					_REPrint:
.e143	20 7d e4	jsr $e47d			jsr 	SIOPrintString
.e146	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e148	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e14a	f0 16		beq $e162			beq 	_RENoLineNumber
.e14c	a9 20		lda #$20			lda 	#" "
.e14e	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.e151	a9 40		lda #$40			lda 	#"@"
.e153	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.e156	a0 01		ldy #$01			ldy 	#1
.e158	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e15a	aa		tax				tax
.e15b	c8		iny				iny
.e15c	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e15e	a8		tay				tay
.e15f	20 6a e1	jsr $e16a			jsr 	PrintWordInteger
.e162					_RENoLineNumber:
.e162	a9 0d		lda #$0d			lda 	#13
.e164	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.e167	4c 1e f0	jmp $f01e			jmp 	WarmStart
.e16a					PrintWordInteger:
.e16a	8a		txa				txa
.e16b	a2 00		ldx #$00			ldx 	#0
.e16d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e170	98		tya				tya
.e171	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e174	c8		iny				iny
.e175	a9 00		lda #$00			lda 	#0
.e177	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e17a	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e17d	20 ac ee	jsr $eeac			jsr 	CPRPrintInteger
.e180	60		rts				rts
.e181					CheckNextCharacter:
.e181	8d 98 20	sta $2098			sta 	Temp1 						; save character to check
.e184					_CNCLoop:
.e184	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e186	f0 0b		beq $e193			beq 	_CNCFail 					; end of line, so no character
.e188	c8		iny				iny
.e189	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e18b	f0 f7		beq $e184			beq 	_CNCLoop
.e18d	cd 98 20	cmp $2098			cmp 	Temp1 						; fail if not what was wanted
.e190	d0 01		bne $e193			bne 	_CNCFail
.e192	60		rts				rts
.e193					_CNCFail:
.e193	20 3d e1	jsr $e13d			jsr 	ReportError
>e196	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e19e	54 4f 4b 45 4e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e1a4							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0024					zTemp1:			.word 	?					; temporary vars
>0026					zTemp2:			.word 	?
>0028					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>2096					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>2098					Temp1:			.dword	?					; 4 byte temporary stores.
>209c					SignCount:		.byte 	? 					; count of signs in divide.
>209d					StringBufferPos:.byte 	? 					; next free slot in string buffer
>209e					RandomSeed 		.word 	? 					; Random Number
>20a0					xCursor 		.byte 	? 					; cursor position
>20a1					yCursor 		.byte 	?
>20a2					breakCheckCount	.byte 	?					; how often check for break.
>20a3					basicStackIndex	.byte 	? 					; index into Basic Stack.
>20a4									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e1a4					EvaluateSNError:
.e1a4	4c 2d e1	jmp $e12d			jmp 	SyntaxError
.e1a7					EvaluateMissingQuote:
.e1a7	20 3d e1	jsr $e13d			jsr 	ReportError
>e1aa	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e1b2	51 55 4f 54 45 00
.e1b8					EvaluateStringFull:
.e1b8	20 3d e1	jsr $e13d			jsr 	ReportError
>e1bb	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e1c3	55 46 46 45 52 20 46 55 4c 4c 00
.e1ce					EvaluateBadHex:
.e1ce	20 3d e1	jsr $e13d			jsr 	ReportError
>e1d1	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e1d9					EvaluateAtomCurrentLevel:
.e1d9	a9 07		lda #$07			lda 	#7
.e1db	80 04		bra $e1e1			bra 	EvaluateAtPrecedenceLevel
.e1dd					EvaluateBase:
.e1dd	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e1df					EvaluateBaseCurrentLevel:
.e1df	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e1e1					EvaluateAtPrecedenceLevel:
.e1e1	48		pha				pha 								; save precedence level
.e1e2	a9 00		lda #$00			lda 	#0 							; zero the result.
.e1e4	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1e7	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1ea	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e1ed	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e1f0					_EVALSkipSpace1:
.e1f0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e1f2	f0 b0		beq $e1a4			beq 	EvaluateSNError 			; end of line, without token.
.e1f4	c8		iny				iny
.e1f5	c9 20		cmp #$20			cmp 	#32
.e1f7	f0 f7		beq $e1f0			beq 	_EVALSkipSpace1
.e1f9	88		dey				dey 								; points at the token.
.e1fa	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e1fc	f0 14		beq $e212			beq 	_EVALString  				; if so load in a constant string
.e1fe	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e200	f0 36		beq $e238			beq 	_EVALHexadecimal
.e202	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e204	90 04		bcc $e20a			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e206	c9 3a		cmp #$3a			cmp 	#'9'+1
.e208	90 03		bcc $e20d			bcc 	_EVALDecimal
.e20a					_EVALGoKeywordVariable:
.e20a	4c 8f e2	jmp $e28f			jmp 	_EVALKeywordVariable
.e20d					_EVALDecimal:
.e20d	20 ec e2	jsr $e2ec			jsr 	EVALGetDecConstant 			; get decimal constant
.e210	80 34		bra $e246			bra 	_EVALGotAtom 				; got atom.
.e212					_EVALString:
.e212	da		phx				phx 								; save X on stack
.e213	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e215	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e218	ad 9d 20	lda $209d			lda 	StringBufferPos 			; X = Buffer Position.
.e21b	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e21e	aa		tax				tax 								; put in X to build the string.
.e21f	c8		iny				iny 								; skip over opening quote character
.e220					_EVALStringCopy:
.e220	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e222	c8		iny				iny
.e223	f0 82		beq $e1a7			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e225	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e228	e8		inx				inx 								; and bump that pointer.
.e229	f0 8d		beq $e1b8			beq 	EvaluateStringFull 			; buffer is full.
.e22b	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e22d	d0 f1		bne $e220			bne 	_EVALStringCopy
.e22f	8e 9d 20	stx $209d			stx 	StringBufferPos 			; this is the new next free slot.
.e232	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e235	fa		plx				plx 								; restore X
.e236	80 0e		bra $e246			bra 	_EVALGotAtom 				; got the atom.
.e238					_EVALHexaDecimal
.e238	c8		iny				iny 								; skip over the '#'
.e239	5a		phy				phy 								; save Y
.e23a	20 58 e3	jsr $e358			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e23d	8c 98 20	sty $2098			sty 	Temp1 						; has Y changed ?
.e240	68		pla				pla
.e241	cd 98 20	cmp $2098			cmp 	Temp1
.e244	f0 88		beq $e1ce			beq 	EvaluateBadHex 				; if not, error.
.e246					_EVALGotAtom:
.e246					_EVALGetOperator:
.e246	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e248	c8		iny				iny 								; this should be binary operator
.e249	c9 20		cmp #$20			cmp 	#$20
.e24b	f0 f9		beq $e246			beq 	_EVALGetOperator
.e24d	88		dey				dey
.e24e	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e250	10 3b		bpl $e28d			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e252	da		phx				phx 								; save X
.e253	aa		tax				tax 								; token in X
.e254	bd 76 e0	lda $e076,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e257	8d 98 20	sta $2098			sta 	Temp1 						; save precedence in Temp1
.e25a	fa		plx				plx 								; restore X
.e25b	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e25d	b0 2e		bcs $e28d			bcs 	_EVALExitPullA
.e25f	68		pla				pla 								; get and save precedence level.
.e260	48		pha				pha
.e261	cd 98 20	cmp $2098			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e264	f0 02		beq $e268			beq 	_EVALDoCalc					; equal, do it.
.e266	b0 25		bcs $e28d			bcs 	_EVALExitPullA				; too high, then exit.
.e268					_EVALDoCalc:
.e268	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e26a	c8		iny				iny
.e26b	48		pha				pha
.e26c	da		phx				phx
.e26d	e8		inx				inx 								; work out right hand side.
.e26e	e8		inx				inx
.e26f	e8		inx				inx
.e270	e8		inx				inx
.e271	ad 98 20	lda $2098			lda 	Temp1 						; get current operator precedence level.
.e274	1a		inc a				inc 	a 							; so work it out at the next level.
.e275	20 e1 e1	jsr $e1e1			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e278	fa		plx				plx 								; fix X back.
.e279	68		pla				pla 								; get keyword
.e27a					_EVALExecuteA:
.e27a	0a		asl a				asl 	a 							; shift left, drop bit 7
.e27b	8d 99 20	sta $2099			sta 	Temp1+1						; save in Temp1.1
.e27e	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e280	8d 9a 20	sta $209a			sta 	Temp1+2 					; set at Temp1.2
.e283	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e285	8d 98 20	sta $2098			sta 	Temp1+0
.e288	20 98 20	jsr $2098			jsr 	Temp1 						; call that routine.
.e28b	80 b9		bra $e246			bra 	_EVALGotAtom 				; and loop back again.
.e28d					_EVALExitPullA:
.e28d	68		pla				pla 								; restore precedence.
.e28e	60		rts				rts
.e28f					_EVALKeywordVariable:
.e28f	09 00		ora #$00			ora 	#0 							; check bit 7
.e291	10 0f		bpl $e2a2			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e293	da		phx				phx
.e294	aa		tax				tax
.e295	bd 76 e0	lda $e076,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e298	fa		plx				plx
.e299	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e29b	d0 05		bne $e2a2			bne 	_EVALNotUnaryFunction
.e29d	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e29f	c8		iny				iny 								; consume it
.e2a0	80 d8		bra $e27a			bra 	_EVALExecuteA 				; execute TOS.
.e2a2					_EVALNotUnaryFunction:
.e2a2	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e2a4	10 3d		bpl $e2e3			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e2a6	c9 8b		cmp #$8b			cmp 	#KW_MINUS 					; check negation
.e2a8	f0 0f		beq $e2b9			beq 	_EVALUnaryNegation
.e2aa	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e2ac	d0 14		bne $e2c2			bne		_EVALCheckUnaryOperator
.e2ae	c8		iny				iny 								; skip left bracket.
.e2af	20 df e1	jsr $e1df			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e2b2	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e2b4	20 81 e1	jsr $e181			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e2b7	80 8d		bra $e246			bra 	_EVALGotAtom
.e2b9					_EVALUnaryNegation:
.e2b9	c8		iny				iny 								; skip over the - sign.
.e2ba	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e2bd	20 ce e9	jsr $e9ce			jsr 	BFUNC_NegateAlways 			; negate it.
.e2c0	80 84		bra $e246			bra 	_EVALGotAtom
.e2c2					_EVALCheckUnaryOperator:
.e2c2	48		pha				pha 								; save indirection operator.
.e2c3	c8		iny				iny 								; skip over the operator
.e2c4	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e2c7	68		pla				pla 								; restore the operator
.e2c8	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e2ca	f0 0e		beq $e2da			beq 	_EVALGoGotAtom
.e2cc	c9 95		cmp #$95			cmp 	#KW_QUESTION				; byte indirection
.e2ce	f0 07		beq $e2d7			beq 	_EVALByteRead
.e2d0	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e2d2	f0 09		beq $e2dd			beq 	_EVALWordRead
.e2d4	4c 2d e1	jmp $e12d			jmp 	SyntaxError 				; give up.
.e2d7					_EVALByteRead:
.e2d7	20 97 e3	jsr $e397			jsr 	EVALReadByteIndirect
.e2da					_EVALGoGotAtom:
.e2da	4c 46 e2	jmp $e246			jmp 	_EVALGotAtom
.e2dd					_EVALWordRead:
.e2dd	20 c0 e3	jsr $e3c0			jsr 	EVALReadWordIndirect
.e2e0	4c 46 e2	jmp $e246			jmp 	_EVALGotAtom
.e2e3					_EVALCheckVariable:
.e2e3	20 f0 e3	jsr $e3f0			jsr 	VARReference 				; get variable reference to ZTemp1
.e2e6	20 d4 e3	jsr $e3d4			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e2e9	4c 46 e2	jmp $e246			jmp 	_EVALGotAtom 				; and go round.
.e2ec					EVALGetDecConstant:
.e2ec	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e2ee	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e2f0	90 04		bcc $e2f6			bcc 	_EVGDExit
.e2f2	c9 3a		cmp #$3a			cmp 	#'9'+1
.e2f4	90 01		bcc $e2f7			bcc 	_EVGDValue 					; if so has legal value
.e2f6					_EVGDExit:
.e2f6	60		rts				rts
.e2f7					_EVGDValue:
.e2f7	48		pha				pha 								; save value, Y on stack
.e2f8	5a		phy				phy
.e2f9	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e2fb	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e2fe	48		pha				pha
.e2ff	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e302	48		pha				pha
.e303	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e306	48		pha				pha
.e307	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e30a	48		pha				pha
.e30b					_EVGDLoop:
.e30b	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e30e	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e311	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e314	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e317	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e319	d0 1d		bne $e338			bne 	_EVGDNoAdd
.e31b	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e31c	68		pla				pla
.e31d	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e320	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e323	68		pla				pla
.e324	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e327	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e32a	68		pla				pla
.e32b	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e32e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e331	68		pla				pla
.e332	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e335	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e338					_EVGDNoAdd:
.e338	88		dey				dey
.e339	d0 d0		bne $e30b			bne 	_EVGDLoop
.e33b	7a		ply				ply 								; restore YA
.e33c	68		pla				pla
.e33d	c8		iny				iny 								; next character
.e33e	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e340	18		clc				clc
.e341	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e344	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e347	90 a3		bcc $e2ec			bcc 	EVALGetDecConstant 			; propogate constant through
.e349	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e34c	d0 9e		bne $e2ec			bne 	EVALGetDecConstant
.e34e	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e351	d0 99		bne $e2ec			bne 	EVALGetDecConstant
.e353	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e356	80 94		bra $e2ec			bra 	EVALGetDecConstant 			; go back and try again.
.e358					EVALGetHexConstant:
.e358	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e35a	20 8c e3	jsr $e38c			jsr 	EVALToUpper 				; make upper case
.e35d	38		sec				sec
.e35e	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e360	90 0a		bcc $e36c			bcc 	_EVGHExit 					; exit if CC
.e362	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e364	90 07		bcc $e36d			bcc 	_EVGHValue
.e366	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e368	c9 10		cmp #$10			cmp 	#15+1
.e36a	90 01		bcc $e36d			bcc 	_EVGHValue
.e36c					_EVGHExit:
.e36c	60		rts				rts
.e36d					_EVGHValue:
.e36d	5a		phy				phy 								; save Y and new digit.
.e36e	48		pha				pha
.e36f	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e371					_EVGHRotate:
.e371	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e374	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e377	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e37a	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e37d	88		dey				dey
.e37e	d0 f1		bne $e371			bne 	_EVGHRotate
.e380	68		pla				pla 								; restore digit and X
.e381	7a		ply				ply
.e382	c8		iny				iny 								; next character
.e383	18		clc				clc
.e384	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e387	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e38a	80 cc		bra $e358			bra 	EVALGetHexConstant 			; go back and try again.
.e38c					EVALToUpper:
.e38c	c9 61		cmp #$61			cmp 	#'a'
.e38e	90 06		bcc $e396			bcc 	_EVTUExit
.e390	c9 7b		cmp #$7b			cmp 	#'z'+1
.e392	b0 02		bcs $e396			bcs 	_EVTUExit
.e394	49 20		eor #$20			eor 	#32
.e396					_EVTUExit:
.e396	60		rts				rts
.e397					EVALReadByteIndirect:
.e397	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e39a	85 24		sta $24				sta 	zTemp1
.e39c	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e39f	85 25		sta $25				sta 	zTemp1+1
.e3a1	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3a4	85 26		sta $26				sta 	zTemp1+2
.e3a6	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3a9	85 27		sta $27				sta 	zTemp1+3
.e3ab	5a		phy				phy
.e3ac	a0 00		ldy #$00			ldy 	#0 							; read byte
.e3ae	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3b0	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3b3	7a		ply				ply
.e3b4	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e3b6	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3b9	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3bc	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3bf	60		rts				rts
.e3c0					EVALReadWordIndirect:
.e3c0	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3c3	85 24		sta $24				sta 	zTemp1
.e3c5	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3c8	85 25		sta $25				sta 	zTemp1+1
.e3ca	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3cd	85 26		sta $26				sta 	zTemp1+2
.e3cf	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3d2	85 27		sta $27				sta 	zTemp1+3
.e3d4					EVALReadWordIndirectZTemp:
.e3d4	5a		phy				phy
.e3d5	a0 00		ldy #$00			ldy 	#0 							; read word
.e3d7	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3d9	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3dc	c8		iny				iny
.e3dd	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3df	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3e2	c8		iny				iny
.e3e3	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3e5	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3e8	c8		iny				iny
.e3e9	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3eb	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3ee	7a		ply				ply
.e3ef	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e3f0					VARReference:
.e3f0	38		sec				sec 								; check range @-Z there
.e3f1	c9 40		cmp #$40			cmp 	#'@'
.e3f3	90 04		bcc $e3f9			bcc 	_VARRError
.e3f5	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e3f7	90 03		bcc $e3fc			bcc 	_VARROkay
.e3f9					_VARRError:
.e3f9	4c 2d e1	jmp $e12d			jmp		SyntaxError
.e3fc					_VARROkay:
.e3fc	c8		iny				iny 								; consume the variable.
.e3fd	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e3ff	f0 1b		beq $e41c			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e401	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e403	88		dey				dey 								; point back to the first character
.e404	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e406	f0 14		beq $e41c			beq 	_VARArrayAccess
.e408	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e40a	c8		iny				iny
.e40b	29 1f		and #$1f			and		#31 						; mask out
.e40d	0a		asl a				asl 	a 							; x 4
.e40e	0a		asl a				asl 	a
.e40f	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e411	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e413	85 25		sta $25				sta 	zTemp1+1
.e415	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e417	85 26		sta $26				sta 	zTemp1+2
.e419	85 27		sta $27				sta 	zTemp1+3 					; return with address set.
.e41b	60		rts				rts
.e41c					_VARArrayAccess:
.e41c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e41e	c8		iny				iny
.e41f	29 1f		and #$1f			and 	#31 						; mask it off
.e421	48		pha				pha 								; save on the stack.
.e422	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e425	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e428	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e42b	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e42e	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e431	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e434	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e437	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e43a	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e43d	68		pla				pla 								; put address in zTemp1
.e43e	0a		asl a				asl 	a 							; x 4
.e43f	0a		asl a				asl 	a
.e440	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e442	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e444	85 25		sta $25				sta 	zTemp1+1
.e446	5a		phy				phy
.e447	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e449	b1 24		lda ($24),y			lda 	(zTemp1),y
.e44b	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e44e	48		pha				pha 								; save first result as we need the indirection.
.e44f	c8		iny				iny 								; 2nd byte
.e450	b1 24		lda ($24),y			lda 	(zTemp1),y
.e452	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e455	85 25		sta $25				sta 	zTemp1+1
.e457	68		pla				pla 								; save the low byte.
.e458	85 24		sta $24				sta 	zTemp1+0
.e45a	a9 00		lda #$00			lda 	#0
.e45c	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e45f	85 26		sta $26				sta 	zTemp1+2
.e461	a9 00		lda #$00			lda 	#0
.e463	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e466	85 27		sta $27				sta 	zTemp1+3
.e468	7a		ply				ply 								; restore Y, address setup
.e469	60		rts				rts
.e46a	80 fe		bra $e46a	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e46c					SIOInitialise:
.e46c	20 82 a0	jsr $a082			jsr 	EXTReset 					; reset video
.e46f					SIOClearScreen:
.e46f	20 38 a0	jsr $a038			jsr 	EXTClearScreen 				; clear screen
.e472					SIOHomeCursor:
.e472	48		pha				pha 								; home cursor
.e473	a9 00		lda #$00			lda 	#0
.e475	8d a0 20	sta $20a0			sta 	xCursor
.e478	8d a1 20	sta $20a1			sta 	yCursor
.e47b	68		pla				pla
.e47c	60		rts				rts
.e47d					SIOPrintString:
.e47d	48		pha				pha 								; save registers
.e47e	da		phx				phx
.e47f	5a		phy				phy
.e480	86 26		stx $26				stx 	zTemp2 						; set up indirect pointer
.e482	84 27		sty $27				sty 	zTemp2+1
.e484	a0 00		ldy #$00			ldy 	#0
.e486					_SIOPSLoop:
.e486	b1 26		lda ($26),y			lda 	(zTemp2),y 					; read next, exit if 0
.e488	f0 1c		beq $e4a6			beq 	_SIOPSExit
.e48a	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter 			; print and bump
.e48d	c8		iny				iny
.e48e	d0 f6		bne $e486			bne 	_SIOPSLoop
.e490	20 3d e1	jsr $e13d			jsr 	ReportError
>e493	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e49b	4e 47 20 50 52 49 4e 54 45 44 00
.e4a6					_SIOPSExit:
.e4a6	7a		ply				ply 								; restore and exit.
.e4a7	fa		plx				plx
.e4a8	68		pla				pla
.e4a9	60		rts				rts
.e4aa					SIOPrintCharacter:
.e4aa	48		pha				pha 								; save AXY
.e4ab	da		phx				phx
.e4ac	5a		phy				phy
.e4ad	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e4af	f0 12		beq $e4c3			beq 	_SIOPReturn
.e4b1	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor 				; load cursor position in.
.e4b4	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e4b6	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen 				; write character out.
.e4b9	ee a0 20	inc $20a0			inc 	xCursor 					; move right
.e4bc	ad a0 20	lda $20a0			lda 	xCursor 					; reached the RHS
.e4bf	c9 28		cmp #$28			cmp 	#EXTWidth
.e4c1	90 15		bcc $e4d8			bcc 	_SIOPExit
.e4c3					_SIOPReturn:
.e4c3	a9 00		lda #$00			lda 	#0 							; zero x
.e4c5	8d a0 20	sta $20a0			sta 	xCursor
.e4c8	ee a1 20	inc $20a1			inc 	yCursor 					; go down
.e4cb	ad a1 20	lda $20a1			lda 	yCursor
.e4ce	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e4d0	90 06		bcc $e4d8			bcc 	_SIOPExit
.e4d2	20 50 a0	jsr $a050			jsr 	EXTScrollDisplay 			; scroll display up
.e4d5	ce a1 20	dec $20a1			dec 	yCursor 					; cursor on bottom line.
.e4d8					_SIOPExit:
.e4d8	7a		ply				ply 								; restore and exit.
.e4d9	fa		plx				plx
.e4da	68		pla				pla
.e4db	60		rts				rts
.e4dc					SIOGetKey:
.e4dc	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort 				; wait for a key
.e4df	f0 fb		beq $e4dc			beq 	SIOGetKey
.e4e1	20 8c e3	jsr $e38c			jsr 	EVALToUpper 				; capitalise it.
.e4e4	4c 12 a0	jmp $a012			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e4e7					SIOReadLine:
.e4e7	48		pha				pha 								; save registers
.e4e8	da		phx				phx
.e4e9	5a		phy				phy
.e4ea					_SIORLoop:
.e4ea	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor 				; cursor in XY
.e4ed	20 1e a0	jsr $a01e			jsr 	EXTReadScreen 				; read the display.
.e4f0	48		pha				pha 								; save on stack.
.e4f1	a9 66		lda #$66			lda 	#102 						; write cursor out
.e4f3	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e4f6	20 dc e4	jsr $e4dc			jsr 	SIOGetKey
.e4f9	aa		tax				tax 								; save in X
.e4fa	68		pla				pla 								; old character
.e4fb	da		phx				phx 								; save key pressed
.e4fc	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor 				; cursor in XY
.e4ff	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e502	68		pla				pla
.e503	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e505	f0 29		beq $e530			beq 	_SIOCursorLeft
.e507	c9 13		cmp #$13			cmp 	#"S"-64
.e509	f0 49		beq $e554			beq 	_SIOCursorDown
.e50b	c9 04		cmp #$04			cmp 	#"D"-64
.e50d	f0 2d		beq $e53c			beq 	_SIOCursorRight
.e50f	c9 17		cmp #$17			cmp 	#"W"-64
.e511	f0 35		beq $e548			beq 	_SIOCursorUp
.e513	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e515	f0 49		beq $e560			beq 	_SIOClearScreen
.e517	c9 08		cmp #$08			cmp 	#"H"-64
.e519	f0 4a		beq $e565			beq 	_SIOBackspace
.e51b	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e51d	f0 0e		beq $e52d			beq 	_SIOGoReturn
.e51f	c9 20		cmp #$20			cmp 	#32 						; any control
.e521	90 c7		bcc $e4ea			bcc 	_SIORLoop
.e523	48		pha				pha
.e524	20 a5 e5	jsr $e5a5			jsr 	_SIOInsert 					; insert a space for new character
.e527	68		pla				pla
.e528	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter 			; print character in A
.e52b	80 bd		bra $e4ea			bra 	_SIORLoop
.e52d					_SIOGoReturn:
.e52d	4c d0 e5	jmp $e5d0			jmp 	_SIOReturn
.e530					_SIOCursorLeft:
.e530	ce a0 20	dec $20a0			dec 	xCursor
.e533	10 b5		bpl $e4ea			bpl 	_SIORLoop
.e535	a9 27		lda #$27			lda 	#EXTWidth-1
.e537					_SIOWXLoop:
.e537	8d a0 20	sta $20a0			sta 	xCursor
.e53a	80 ae		bra $e4ea			bra 	_SIORLoop
.e53c					_SIOCursorRight:
.e53c	ee a0 20	inc $20a0			inc 	xCursor
.e53f	ad a0 20	lda $20a0			lda 	xCursor
.e542	49 28		eor #$28			eor 	#EXTWidth
.e544	d0 a4		bne $e4ea			bne 	_SIORLoop
.e546	80 ef		bra $e537			bra 	_SIOWXLoop
.e548					_SIOCursorUp:
.e548	ce a1 20	dec $20a1			dec 	yCursor
.e54b	10 9d		bpl $e4ea			bpl 	_SIORLoop
.e54d	a9 18		lda #$18			lda 	#EXTHeight-1
.e54f					_SIOWYLoop:
.e54f	8d a1 20	sta $20a1			sta 	yCursor
.e552	80 96		bra $e4ea			bra 	_SIORLoop
.e554					_SIOCursorDown:
.e554	ee a1 20	inc $20a1			inc 	yCursor
.e557	ad a1 20	lda $20a1			lda 	yCursor
.e55a	49 19		eor #$19			eor 	#EXTHeight
.e55c	d0 8c		bne $e4ea			bne 	_SIORLoop
.e55e	80 ef		bra $e54f			bra 	_SIOWYLoop
.e560					_SIOClearScreen:
.e560	20 6f e4	jsr $e46f			jsr 	SIOClearScreen
.e563	80 85		bra $e4ea			bra 	_SIORLoop
.e565					_SIOBackspace:
.e565	ad a0 20	lda $20a0			lda 	xCursor 					; backspace possible ?
.e568	f0 80		beq $e4ea			beq 	_SIORLoop 					; start of line, no.
.e56a	48		pha				pha 								; save position.
.e56b	c9 27		cmp #$27			cmp 	#EXTWidth-1 				; not required
.e56d	f0 1c		beq $e58b			beq 	_SIONoShift
.e56f					_SIOShift2:
.e56f	ee a0 20	inc $20a0			inc 	xCursor 					; copy character backward
.e572	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e575	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e578	ce a0 20	dec $20a0			dec 	xCursor
.e57b	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e57e	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e581	ee a0 20	inc $20a0			inc 	xCursor
.e584	ad a0 20	lda $20a0			lda 	xCursor
.e587	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e589	d0 e4		bne $e56f			bne 	_SIOShift2
.e58b					_SIONoShift:
.e58b	a9 27		lda #$27			lda 	#EXTWidth-1 				; space on far end.
.e58d	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e590	a9 20		lda #$20			lda 	#32
.e592	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e595	68		pla				pla 								; restore cursor, back one.
.e596	3a		dec a				dec 	a
.e597	8d a0 20	sta $20a0			sta 	xCursor
.e59a	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor 				; overwrite
.e59d	a9 20		lda #$20			lda 	#32
.e59f	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5a2	4c ea e4	jmp $e4ea			jmp	 	_SIORLoop
.e5a5					_SIOInsert:
.e5a5	ad a0 20	lda $20a0			lda 	xCursor 					; at far right, nothing to do.
.e5a8	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e5aa	f0 23		beq $e5cf			beq 	_SIOIExit
.e5ac	85 26		sta $26				sta 	zTemp2 						; save in temporary workspace.
.e5ae	a9 27		lda #$27			lda 	#EXTWidth-1 				; cursor at far right.
.e5b0	8d a0 20	sta $20a0			sta 	xCursor
.e5b3					_SIOShift:
.e5b3	ce a0 20	dec $20a0			dec 	xCursor 					; copy character forward
.e5b6	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e5b9	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5bc	ee a0 20	inc $20a0			inc 	xCursor
.e5bf	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e5c2	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5c5	ce a0 20	dec $20a0			dec 	xCursor
.e5c8	ad a0 20	lda $20a0			lda 	xCursor						; until shifted line to this point.
.e5cb	c5 26		cmp $26				cmp 	zTemp2
.e5cd	d0 e4		bne $e5b3			bne 	_SIOShift
.e5cf					_SIOIExit:
.e5cf	60		rts				rts
.e5d0					_SIOReturn:
.e5d0	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e5d2	8d a0 20	sta $20a0			sta 	xCursor
.e5d5					_SIOCopy:
.e5d5	20 0a e6	jsr $e60a			jsr 	SIOLoadCursor
.e5d8	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5db	49 20		eor #$20			eor 	#$20
.e5dd	18		clc				clc
.e5de	69 20		adc #$20			adc 	#$20
.e5e0	ae a0 20	ldx $20a0			ldx 	xCursor
.e5e3	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e5e6	ee a0 20	inc $20a0			inc 	xCursor
.e5e9	ad a0 20	lda $20a0			lda 	xCursor
.e5ec	c9 28		cmp #$28			cmp 	#EXTWidth
.e5ee	d0 e5		bne $e5d5			bne 	_SIOCopy
.e5f0	aa		tax				tax 								; X contains width
.e5f1					_SIOStrip:
.e5f1	ca		dex				dex									; back one
.e5f2	30 07		bmi $e5fb			bmi		_SIOFound 					; if -ve gone too far
.e5f4	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e5f7	c9 20		cmp #$20			cmp 	#' '
.e5f9	f0 f6		beq $e5f1			beq 	_SIOStrip
.e5fb					_SIOFound:
.e5fb	e8		inx				inx
.e5fc	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e5fe	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e601	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e603	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.e606	7a		ply				ply
.e607	fa		plx				plx
.e608	68		pla				pla
.e609	60		rts				rts
.e60a					SIOLoadCursor:
.e60a	48		pha				pha
.e60b	ad a1 20	lda $20a1			lda 	yCursor  					; Y Position
.e60e	0a		asl a				asl 	a 							; x 2 	(80)
.e60f	0a		asl a				asl 	a 							; x 2 	(160)
.e610	6d a1 20	adc $20a1			adc 	yCursor 					; x 5 	(200) (CC)
.e613	85 24		sta $24				sta 	zTemp1
.e615	a9 00		lda #$00			lda 	#0
.e617	85 25		sta $25				sta 	zTemp1+1
.e619	06 24		asl $24				asl 	zTemp1						; x 10
.e61b	26 25		rol $25				rol 	zTemp1+1
.e61d	06 24		asl $24				asl 	zTemp1						; x 20
.e61f	26 25		rol $25				rol 	zTemp1+1
.e621	06 24		asl $24				asl 	zTemp1						; x 40
.e623	26 25		rol $25				rol 	zTemp1+1 					; (CC)
.e625	a5 24		lda $24				lda 	zTemp1 						; add X
.e627	6d a0 20	adc $20a0			adc 	xCursor
.e62a	aa		tax				tax
.e62b	a5 25		lda $25				lda 	zTemp1+1
.e62d	69 00		adc #$00			adc 	#0
.e62f	a8		tay				tay
.e630	68		pla				pla 								; restore and exit
.e631	60		rts				rts
.e632					SIOPrintHex:
.e632	48		pha				pha
.e633	48		pha				pha
.e634	a9 20		lda #$20			lda 	#32
.e636	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.e639	68		pla				pla
.e63a	48		pha				pha
.e63b	4a		lsr a				lsr 	a
.e63c	4a		lsr a				lsr 	a
.e63d	4a		lsr a				lsr 	a
.e63e	4a		lsr a				lsr 	a
.e63f	20 48 e6	jsr $e648			jsr 	_SIOPHex
.e642	68		pla				pla
.e643	20 48 e6	jsr $e648			jsr 	_SIOPHex
.e646	68		pla				pla
.e647	60		rts				rts
.e648					_SIOPHex:
.e648	29 0f		and #$0f			and 	#15
.e64a	c9 0a		cmp #$0a			cmp 	#10
.e64c	90 02		bcc $e650			bcc 	_SIOPHex2
.e64e	69 06		adc #$06			adc 	#6
.e650					_SIOPHex2:
.e650	69 30		adc #$30			adc 	#48
.e652	4c aa e4	jmp $e4aa			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e655					TokeniseString:
.e655	a0 00		ldy #$00			ldy 	#0							; source
.e657	a2 00		ldx #$00			ldx 	#0 							; target
.e659					_TokLoop:
.e659	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get first
.e65b	f0 5d		beq $e6ba			beq 	_TokExit 					; End, exit.
.e65d	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e65f	f0 35		beq $e696			beq 	_TokCopy1
.e661	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e663	f0 3a		beq $e69f			beq 	_TokCopyString
.e665	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e667	90 22		bcc $e68b			bcc 	_TokPunctuation
.e669	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e66b	90 29		bcc $e696			bcc 	_TokCopy1
.e66d	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e66f	90 1a		bcc $e68b			bcc 	_TokPunctuation
.e671	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e673	b0 16		bcs $e68b			bcs 	_TokPunctuation
.e675					_TokWord:
.e675	20 c0 e6	jsr $e6c0			jsr 	TokeniseSearch 				; search for tokenised word.
.e678	b0 16		bcs $e690			bcs 	_TokFound 					; if successful, copy it out.
.e67a					_TokSkip:
.e67a	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e67c	c9 41		cmp #$41			cmp 	#"A"
.e67e	90 d9		bcc $e659			bcc 	_TokLoop
.e680	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e682	b0 d5		bcs $e659			bcs 	_TokLoop
.e684	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e687	e8		inx				inx
.e688	c8		iny				iny
.e689	80 ef		bra $e67a			bra 	_TokSkip
.e68b					_TokPunctuation:
.e68b	20 c0 e6	jsr $e6c0			jsr 	TokeniseSearch 				; find it.
.e68e	90 06		bcc $e696			bcc 	_TokCopy1 					; if found, just copy 1 character
.e690					_TokFound:
.e690	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e693	e8		inx				inx 								; advance target ; source is already advanced.
.e694	80 c3		bra $e659			bra 	_TokLoop 					; do the next character.
.e696					_TokCopy1:
.e696	b1 24		lda ($24),y			lda 	(zTemp1),y
.e698	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e69b	e8		inx				inx
.e69c	c8		iny				iny
.e69d	80 ba		bra $e659			bra 	_TokLoop
.e69f					_TokCopyString:
.e69f	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e6a1	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6a4	e8		inx				inx 								; skip buffer and first quote.
.e6a5	c8		iny				iny
.e6a6					_TokCSLoop:
.e6a6	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get next character
.e6a8	f0 10		beq $e6ba			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e6aa	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e6ad	e8		inx				inx 								; advance both.
.e6ae	c8		iny				iny
.e6af	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e6b1	d0 f3		bne $e6a6			bne 	_TokCSLoop
.e6b3	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e6b5	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e6b8	80 9f		bra $e659			bra 	_TokLoop
.e6ba					_TokExit:
.e6ba	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e6bc	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6bf	60		rts				rts
.e6c0					TokeniseSearch:
.e6c0	48		pha				pha 								; save AXY
.e6c1	da		phx				phx
.e6c2	5a		phy				phy
.e6c3	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e6c5	85 26		sta $26				sta 	zTemp2
.e6c7	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e6c9	bd 6e e0	lda $e06e,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e6cc	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e6ce	d1 24		cmp ($24),y			cmp 	(zTemp1),y 					; do the characters match.
.e6d0	f0 13		beq $e6e5			beq 	_TSTryFullMatch 			; if so, try the full match.
.e6d2					_TSGotoNext:
.e6d2	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; read it
.e6d5	e8		inx				inx 								; bump index
.e6d6	0a		asl a				asl 	a 							; shift into C
.e6d7	90 f9		bcc $e6d2			bcc 	_TSGotoNext 				; keep going until read the end character
.e6d9	e6 26		inc $26				inc 	zTemp2 						; bump the current token pointer.
.e6db	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; look at the first character of the next token
.e6de	d0 e9		bne $e6c9			bne 	_TSNext 					; if non-zero, go to the next.
.e6e0					_TSFail:
.e6e0	7a		ply				ply 								; fail.
.e6e1	fa		plx				plx
.e6e2	68		pla				pla
.e6e3	18		clc				clc 				 				; return with carry clear.
.e6e4	60		rts				rts
.e6e5					_TSTryFullMatch:
.e6e5	da		phx				phx									; save X and Y.
.e6e6	5a		phy				phy
.e6e7					_TSFullMatch:
.e6e7	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; compare the 7 bits.
.e6ea	29 7f		and #$7f			and 	#$7F
.e6ec	d1 24		cmp ($24),y			cmp 	(zTemp1),y
.e6ee	d0 15		bne $e705			bne 	_TSFullFail 				; different, this one doesn't match.
.e6f0	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.e6f3	e8		inx				inx 								; advance to next character
.e6f4	c8		iny				iny
.e6f5	0a		asl a				asl 	a 							; bit 7 of token text in C
.e6f6	90 ef		bcc $e6e7			bcc 	_TSFullMatch
.e6f8	84 27		sty $27				sty 	zTemp2+1 					; save the Y after last
.e6fa	68		pla				pla 								; so we don't restore Y
.e6fb	68		pla				pla 								; or X from the full test.
.e6fc	7a		ply				ply 								; restore original Y and X and A
.e6fd	fa		plx				plx
.e6fe	68		pla				pla
.e6ff	a5 26		lda $26				lda 	zTemp2 						; and return token ID in A
.e701	a4 27		ldy $27				ldy 	zTemp2+1 					; Y after the tokenised text.
.e703	38		sec				sec 								; with carry set.
.e704	60		rts				rts
.e705					_TSFullFail:
.e705	7a		ply				ply 								; restore Y and X
.e706	fa		plx				plx
.e707	80 c9		bra $e6d2			bra 	_TSGotoNext 				; and go to the next token to test.
.e709					TokeniseTest:
.e709	a9 15		lda #$15			lda 	#TTString & $FF
.e70b	85 24		sta $24				sta 	zTemp1
.e70d	a9 e7		lda #$e7			lda 	#TTString >> 8
.e70f	85 25		sta $25				sta 	zTemp1+1
.e711	20 55 e6	jsr $e655			jsr 	TokeniseString
.e714	ea		nop				nop
.e715					TTString:
>e715	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e71d	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: general/editor.asm

.e72a					EditProgram:
.e72a	a2 00		ldx #$00			ldx 	#0
.e72c	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; get the line number
.e72f	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; upper bytes must be zero
.e732	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e735	d0 38		bne $e76f			bne 	_EPBadLine
.e737	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; lower bytes must be non-zero
.e73a	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e73d	f0 30		beq $e76f			beq 	_EPBadLine
.e73f	5a		phy				phy 								; save position
.e740	20 7b e7	jsr $e77b			jsr 	EDFindLine 					; locate the line.
.e743	90 12		bcc $e757			bcc 	_EPNotFound 				; skip delete if not found.
.e745	a5 24		lda $24				lda 	zTemp1 						; save the target address, as we will
.e747	48		pha				pha 								; insert the line, if done, at the same
.e748	a5 25		lda $25				lda 	zTemp1+1 					; place
.e74a	48		pha				pha
.e74b	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; clear all vars, make sure zLowMemory is right.
.e74e	20 b2 e7	jsr $e7b2			jsr 	EDDeleteLine 				; delete the line at zTemp1
.e751	68		pla				pla 								; restore the target address.
.e752	85 25		sta $25				sta 	zTemp1+1
.e754	68		pla				pla
.e755	85 24		sta $24				sta 	zTemp1
.e757					_EPNotFound
.e757	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e75a	7a		ply				ply 								; get pointer back
.e75b					_EPSkipSpaces:
.e75b	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get character
.e75d	f0 0d		beq $e76c			beq 	_EPGoWarmStart 				; EOL, just delete, so warm start.
.e75f	c8		iny				iny
.e760	c9 20		cmp #$20			cmp 	#32
.e762	f0 f7		beq $e75b			beq 	_EPSkipSpaces
.e764	88		dey				dey
.e765	ea		nop				nop
.e766	20 d2 e7	jsr $e7d2			jsr 	EDInsertLine 				; insert the line.
.e769	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e76c					_EPGoWarmStart:
.e76c	4c 1e f0	jmp $f01e			jmp 	WarmStart
.e76f					_EPBadLine:
.e76f	20 3d e1	jsr $e13d			jsr 	ReportError
>e772	42 41 44 20 4c 49 4e 45				.text 	"BAD LINE",$00
>e77a	00
.e77b					EDFindLine:
.e77b	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set zTemp1
.e77d	85 24		sta $24				sta 	zTemp1
.e77f	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e781	85 25		sta $25				sta 	zTemp1+1
.e783					_EDFLLoop:
.e783	a0 00		ldy #$00			ldy 	#0 							; reached the end
.e785	b1 24		lda ($24),y			lda 	(zTemp1),y
.e787	f0 25		beq $e7ae			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.e789	c8		iny				iny
.e78a	38		sec				sec
.e78b	ad 00 04	lda $0400			lda 	evalStack+0					; subtract the current from the target
.e78e	f1 24		sbc ($24),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.e790	aa		tax				tax	 								; this will return 10.
.e791	ad 01 04	lda $0401			lda 	evalStack+1
.e794	c8		iny				iny
.e795	f1 24		sbc ($24),y			sbc 	(zTemp1),y
.e797	90 15		bcc $e7ae			bcc 	_EDFLFail					; if target < current then failed.
.e799	d0 04		bne $e79f			bne 	_EDFLNext 					; if non-zero then goto next
.e79b	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.e79d	f0 11		beq $e7b0			beq 	_EDFLFound
.e79f					_EDFLNext:
.e79f	a0 00		ldy #$00			ldy 	#0 							; get offset
.e7a1	18		clc				clc
.e7a2	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7a4	65 24		adc $24				adc 	zTemp1 						; add to pointer
.e7a6	85 24		sta $24				sta 	zTemp1
.e7a8	90 d9		bcc $e783			bcc 	_EDFLLoop
.e7aa	e6 25		inc $25				inc 	zTemp1+1 					; carry out.
.e7ac	80 d5		bra $e783			bra 	_EDFLLoop
.e7ae					_EDFLFail:
.e7ae	18		clc				clc
.e7af	60		rts				rts
.e7b0					_EDFLFound:
.e7b0	38		sec				sec
.e7b1	60		rts				rts
.e7b2					EDDeleteLine:
.e7b2	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.e7b4	a2 00		ldx #$00			ldx 	#0
.e7b6	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7b8	a8		tay				tay 								; put in Y
.e7b9					_EDDelLoop:
.e7b9	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get it
.e7bb	81 24		sta ($24,x)			sta 	(zTemp1,x) 					; write it.
.e7bd	a5 24		lda $24				lda 	zTemp1 						; check if pointer has reached the end of
.e7bf	c5 22		cmp $22				cmp		zLowMemory 					; low memory. We will have copied down an
.e7c1	d0 06		bne $e7c9			bne 	_EDDelNext 					; extra pile of stuff - technically should
.e7c3	a5 25		lda $25				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.e7c5	c5 23		cmp $23				cmp 	zLowMemory+1				; doesn't really matter.
.e7c7	f0 08		beq $e7d1			beq		_EDDelExit
.e7c9					_EDDelNext:
.e7c9	e6 24		inc $24				inc 	zTemp1 						; go to next byte.
.e7cb	d0 ec		bne $e7b9			bne 	_EDDelLoop
.e7cd	e6 25		inc $25				inc 	zTemp1+1
.e7cf	80 e8		bra $e7b9			bra 	_EDDelLoop
.e7d1					_EDDelExit:
.e7d1	60		rts				rts
.e7d2					EDInsertLine:
.e7d2	ea		nop				nop
.e7d3	98		tya				tya 								; make zCurrentLine point to the actual new line.
.e7d4	18		clc				clc
.e7d5	65 20		adc $20				adc 	zCurrentLine
.e7d7	85 20		sta $20				sta 	zCurrentLine
.e7d9	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.e7db					_EDGetLength:
.e7db	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e7dd	c8		iny				iny
.e7de	c9 00		cmp #$00			cmp 	#0
.e7e0	d0 f9		bne $e7db			bne 	_EDGetLength
.e7e2	88		dey				dey 								; fix up.
.e7e3	5a		phy				phy 								; save on stack.
.e7e4	98		tya				tya
.e7e5	18		clc				clc
.e7e6	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.e7e8	a8		tay				tay 								; in Y
.e7e9	a2 00		ldx #$00			ldx 	#0
.e7eb					_EDInsLoop:
.e7eb	a1 22		lda ($22,x)			lda 	(zLowMemory,x)				; copy it up
.e7ed	91 22		sta ($22),y			sta 	(zLowMemory),y
.e7ef	a5 22		lda $22				lda 	zLowMemory 					; reached the insert point (zTemp1)
.e7f1	c5 24		cmp $24				cmp 	zTemp1
.e7f3	d0 06		bne $e7fb			bne 	_EDINextShift
.e7f5	a5 23		lda $23				lda 	zLowMemory+1
.e7f7	c5 25		cmp $25				cmp 	zTemp1+1
.e7f9	f0 0a		beq $e805			beq 	_EDIShiftOver
.e7fb					_EDINextShift:
.e7fb	a5 22		lda $22				lda 	zLowMemory 					; decrement the copy pointer.
.e7fd	d0 02		bne $e801			bne 	_EDINoBorrow
.e7ff	c6 23		dec $23				dec 	zLowMemory+1
.e801					_EDINoBorrow:
.e801	c6 22		dec $22				dec 	zLowMemory
.e803	80 e6		bra $e7eb			bra 	_EDInsLoop
.e805					_EDIShiftOver:
.e805	ea		nop				nop
.e806	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e807					BFUNC_Add:
.e807	18		clc				clc
.e808	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e80b	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e80e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e811	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e814	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e817	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e81a	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e81d	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e820	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e823	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e826	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e829	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e82c	60		rts				rts
.e82d					BFUNC_Subtract:
.e82d	38		sec				sec
.e82e	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e831	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e834	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e837	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e83a	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e83d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e840	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e843	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e846	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e849	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e84c	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e84f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e852	60		rts				rts
.e853					BFUNC_String:
.e853	20 07 e8	jsr $e807			jsr 	BFUNC_Add
.e856	60		rts				rts
.e857					BFUNC_ByteInd:
.e857	20 07 e8	jsr $e807			jsr 	BFUNC_Add
.e85a	20 97 e3	jsr $e397			jsr 	EVALReadByteIndirect
.e85d	60		rts				rts
.e85e					BFUNC_WordInd:
.e85e	20 07 e8	jsr $e807			jsr 	BFUNC_Add
.e861	20 c0 e3	jsr $e3c0			jsr 	EVALReadWordIndirect
.e864	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e865					BFUNC_And:
.e865	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e868	3d 04 04	and $0404,x			and 	evalStack+4,x
.e86b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e86e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e871	3d 05 04	and $0405,x			and 	evalStack+5,x
.e874	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e877	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e87a	3d 06 04	and $0406,x			and 	evalStack+6,x
.e87d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e880	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e883	3d 07 04	and $0407,x			and 	evalStack+7,x
.e886	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e889	60		rts				rts
.e88a					BFUNC_Or:
.e88a	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e88d	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e890	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e893	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e896	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e899	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e89c	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e89f	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e8a2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8a5	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8a8	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e8ab	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8ae	60		rts				rts
.e8af					BFUNC_Xor:
.e8af	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8b2	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e8b5	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8b8	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8bb	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e8be	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8c1	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8c4	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e8c7	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8ca	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8cd	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e8d0	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8d3	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e8d4					BFUNC_Multiply:
.e8d4	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e8d7	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e8da	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8dd	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e8e0	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8e3	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e8e6	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8e9	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e8ec	a9 00		lda #$00			lda 	#0
.e8ee	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e8f1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8f4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8f7	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8fa					_BFMMultiply:
.e8fa	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e8fd	29 01		and #$01			and 	#1
.e8ff	f0 03		beq $e904			beq 	_BFMNoAdd
.e901	20 07 e8	jsr $e807			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e904					_BFMNoAdd:
.e904	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e907	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e90a	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e90d	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e910	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e913	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e916	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e919	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e91c	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e91f	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e922	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e925	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e928	d0 d0		bne $e8fa			bne 	_BFMMultiply
.e92a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e92b					BFUNC_Divide:
.e92b	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e92e	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e931	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e934	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e937	d0 14		bne $e94d			bne 	_BFDOkay
.e939	20 3d e1	jsr $e13d			jsr 	ReportError
>e93c	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>e944	20 42 59 20 5a 45 52 4f 00
.e94d					_BFDOkay:
.e94d	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e94f	8d 98 20	sta $2098			sta 	Temp1 						; Q/Dividend/Left in +0
.e952	8d 99 20	sta $2099			sta 	Temp1+1 					; M/Divisor/Right in +4
.e955	8d 9a 20	sta $209a			sta 	Temp1+2
.e958	8d 9b 20	sta $209b			sta 	Temp1+3
.e95b	8d 9c 20	sta $209c			sta 	SignCount 					; Count of signs.
.e95e	20 c9 e9	jsr $e9c9			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e961	da		phx				phx
.e962	e8		inx				inx
.e963	e8		inx				inx
.e964	e8		inx				inx
.e965	e8		inx				inx
.e966	20 c9 e9	jsr $e9c9			jsr 	BFUNC_Negate
.e969	fa		plx				plx
.e96a	5a		phy				phy 								; Y is the counter
.e96b	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e96d					_BFDLoop:
.e96d	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e970	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e973	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e976	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e979	2e 98 20	rol $2098			rol 	Temp1
.e97c	2e 99 20	rol $2099			rol 	Temp1+1
.e97f	2e 9a 20	rol $209a			rol 	Temp1+2
.e982	2e 9b 20	rol $209b			rol 	Temp1+3
.e985	38		sec				sec
.e986	ad 98 20	lda $2098			lda 	Temp1+0 					; Calculate A-M on stack.
.e989	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e98c	48		pha				pha
.e98d	ad 99 20	lda $2099			lda 	Temp1+1
.e990	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e993	48		pha				pha
.e994	ad 9a 20	lda $209a			lda 	Temp1+2
.e997	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e99a	48		pha				pha
.e99b	ad 9b 20	lda $209b			lda 	Temp1+3
.e99e	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e9a1	90 19		bcc $e9bc			bcc 	_BFDNoAdd
.e9a3	8d 9b 20	sta $209b			sta 	Temp1+3 					; update A
.e9a6	68		pla				pla
.e9a7	8d 9a 20	sta $209a			sta 	Temp1+2
.e9aa	68		pla				pla
.e9ab	8d 99 20	sta $2099			sta 	Temp1+1
.e9ae	68		pla				pla
.e9af	8d 98 20	sta $2098			sta 	Temp1+0
.e9b2	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.e9b5	09 01		ora #$01			ora 	#1
.e9b7	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e9ba	80 03		bra $e9bf			bra 	_BFDNext
.e9bc					_BFDNoAdd:
.e9bc	68		pla				pla 								; Throw away the intermediate calculations
.e9bd	68		pla				pla
.e9be	68		pla				pla
.e9bf					_BFDNext:
.e9bf	88		dey				dey
.e9c0	d0 ab		bne $e96d			bne 	_BFDLoop
.e9c2	7a		ply				ply 								; restore Y and exit
.e9c3	4e 9c 20	lsr $209c			lsr 	SignCount 					; if sign count odd,
.e9c6	b0 06		bcs $e9ce			bcs		BFUNC_NegateAlways 			; negate the result
.e9c8	60		rts				rts
.e9c9					BFUNC_Negate:
.e9c9	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e9cc	10 24		bpl $e9f2			bpl 	BFNExit
.e9ce					BFUNC_NegateAlways:
.e9ce	38		sec				sec
.e9cf	a9 00		lda #$00			lda 	#0
.e9d1	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.e9d4	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e9d7	a9 00		lda #$00			lda 	#0
.e9d9	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.e9dc	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e9df	a9 00		lda #$00			lda 	#0
.e9e1	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.e9e4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e9e7	a9 00		lda #$00			lda 	#0
.e9e9	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.e9ec	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e9ef	ee 9c 20	inc $209c			inc 	SignCount
.e9f2					BFNExit:
.e9f2	60		rts				rts
.e9f3					BFUNC_Modulus:
.e9f3	20 2b e9	jsr $e92b			jsr 	BFUNC_Divide 				; start with division.
.e9f6	ad 98 20	lda $2098			lda 	Temp1+0 					; copy remainder
.e9f9	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e9fc	ad 99 20	lda $2099			lda 	Temp1+1
.e9ff	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea02	ad 9a 20	lda $209a			lda 	Temp1+2
.ea05	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea08	ad 9b 20	lda $209b			lda 	Temp1+3
.ea0b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea0e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.ea0f					BFUNC_Equals:
.ea0f	18		clc				clc
.ea10	80 01		bra $ea13			bra 	BFUNC_EqualCheck
.ea12					BFUNC_NotEquals:
.ea12	38		sec				sec
.ea13					BFUNC_EqualCheck:
.ea13	08		php				php									; save invert flag
.ea14	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.ea17	cd 04 04	cmp $0404			cmp 	evalStack+4
.ea1a	d0 1c		bne $ea38			bne 	COMP_Fail
.ea1c	ad 01 04	lda $0401			lda 	evalStack+1
.ea1f	cd 05 04	cmp $0405			cmp 	evalStack+5
.ea22	d0 14		bne $ea38			bne 	COMP_Fail
.ea24	ad 02 04	lda $0402			lda 	evalStack+2
.ea27	cd 06 04	cmp $0406			cmp 	evalStack+6
.ea2a	d0 0c		bne $ea38			bne 	COMP_Fail
.ea2c	ad 03 04	lda $0403			lda 	evalStack+3
.ea2f	cd 07 04	cmp $0407			cmp 	evalStack+7
.ea32	d0 04		bne $ea38			bne 	COMP_Fail
.ea34					COMP_Succeed:
.ea34	a9 ff		lda #$ff			lda 	#$FF
.ea36	80 02		bra $ea3a			bra 	COMP_SetResult
.ea38					COMP_Fail:
.ea38	a9 00		lda #$00			lda 	#0 							; here return 0
.ea3a					COMP_SetResult:
.ea3a	28		plp				plp 								; but if CS
.ea3b	90 02		bcc $ea3f			bcc 	COMP_Accept
.ea3d	49 ff		eor #$ff			eor 	#$FF 						; invert that
.ea3f					COMP_Accept:
.ea3f	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.ea42	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea45	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea48	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea4b	60		rts				rts
.ea4c					BFUNC_Less:
.ea4c	18		clc				clc
.ea4d	80 01		bra $ea50			bra 	BFUNC_LessCheck
.ea4f					BFUNC_GreaterEqual:
.ea4f	38		sec				sec
.ea50					BFUNC_LessCheck:
.ea50	08		php				php
.ea51	38		sec				sec
.ea52	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.ea55	ed 04 04	sbc $0404			sbc 	evalStack+4
.ea58	ad 01 04	lda $0401			lda 	evalStack+1
.ea5b	ed 05 04	sbc $0405			sbc 	evalStack+5
.ea5e	ad 02 04	lda $0402			lda 	evalStack+2
.ea61	ed 06 04	sbc $0406			sbc 	evalStack+6
.ea64	ad 03 04	lda $0403			lda 	evalStack+3
.ea67	ed 07 04	sbc $0407			sbc 	evalStack+7
.ea6a	30 c8		bmi $ea34			bmi 	COMP_Succeed
.ea6c	80 ca		bra $ea38			bra 	COMP_Fail
.ea6e					BFUNC_Greater:
.ea6e	18		clc				clc
.ea6f	80 01		bra $ea72			bra 	BFUNC_GreaterCheck
.ea71					BFUNC_LessEqual:
.ea71	38		sec				sec
.ea72					BFUNC_GreaterCheck:
.ea72	08		php				php
.ea73	38		sec				sec
.ea74	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.ea77	ed 00 04	sbc $0400			sbc 	evalStack+0
.ea7a	ad 05 04	lda $0405			lda 	evalStack+5
.ea7d	ed 01 04	sbc $0401			sbc 	evalStack+1
.ea80	ad 06 04	lda $0406			lda 	evalStack+6
.ea83	ed 02 04	sbc $0402			sbc 	evalStack+2
.ea86	ad 07 04	lda $0407			lda 	evalStack+7
.ea89	ed 03 04	sbc $0403			sbc 	evalStack+3
.ea8c	30 a6		bmi $ea34			bmi 	COMP_Succeed
.ea8e	80 a8		bra $ea38			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.ea90					BFUNC_StringCompare:
.ea90	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.ea93	85 24		sta $24				sta 	zTemp1
.ea95	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ea98	85 25		sta $25				sta 	zTemp1+1
.ea9a	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.ea9d	85 26		sta $26				sta 	zTemp2
.ea9f	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.eaa2	85 27		sta $27				sta 	zTemp2+1
.eaa4	5a		phy				phy
.eaa5	a0 00		ldy #$00			ldy 	#0
.eaa7					_BFSCLoop:
.eaa7	b1 24		lda ($24),y			lda 	(zTemp1),y 					; comparison
.eaa9	38		sec				sec
.eaaa	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.eaac	d0 15		bne $eac3			bne		_BFSCDifferent 				; return different result.
.eaae	c8		iny				iny
.eaaf	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.eab1	d0 f4		bne $eaa7			bne 	_BFSCLoop
.eab3	7a		ply				ply
.eab4	a9 00		lda #$00			lda 	#0
.eab6					_BFSCSetAll:
.eab6	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eab9	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eabc	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eabf	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eac2	60		rts				rts
.eac3					_BFSCDifferent:
.eac3	7a		ply				ply
.eac4	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.eac6	90 ee		bcc $eab6			bcc 	_BFSCSetAll
.eac8	a9 00		lda #$00			lda 	#0 							; set all zero
.eaca	20 b6 ea	jsr $eab6			jsr 	_BFSCSetAll
.eacd	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.ead0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.ead1					UNARY_Len:
.ead1	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.ead4	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.ead7	85 24		sta $24				sta 	zTemp1
.ead9	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eadc	85 25		sta $25				sta 	zTemp1+1
.eade	5a		phy				phy
.eadf	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.eae1					_ULGetLength:
.eae1	b1 24		lda ($24),y			lda 	(zTemp1),y 					; read character
.eae3	f0 1d		beq $eb02			beq 	_ULFoundEOL 				; found end of line.
.eae5	c8		iny				iny
.eae6	d0 f9		bne $eae1			bne 	_ULGetLength 				; scan 256 only.
.eae8	20 3d e1	jsr $e13d			jsr 	ReportError
>eaeb	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>eaf3	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.eb02					_ULFoundEOL:
.eb02	98		tya				tya 								; length in A, restore Y
.eb03	7a		ply				ply
.eb04					UNARY_ReturnByte:
.eb04	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb07	a9 00		lda #$00			lda 	#0 							; clear the rests
.eb09	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb0c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb0f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb12	60		rts				rts
.eb13					UNARY_Ch:
.eb13	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb16	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb19	85 24		sta $24				sta 	zTemp1
.eb1b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb1e	85 25		sta $25				sta 	zTemp1+1
.eb20	5a		phy				phy
.eb21	a0 00		ldy #$00			ldy 	#0 							; now get first character
.eb23	b1 24		lda ($24),y			lda 	(zTemp1),y
.eb25	7a		ply				ply
.eb26	80 dc		bra $eb04			bra 	UNARY_ReturnByte 			; return that byte.
.eb28					UNARY_Abs:
.eb28	ea		nop				nop
.eb29	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb2c	20 c9 e9	jsr $e9c9			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.eb2f	60		rts				rts
.eb30					UNARY_Top:
.eb30	ad 96 20	lda $2096			lda 	highMemory
.eb33	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb36	ad 97 20	lda $2097			lda 	highMemory+1
.eb39	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb3c	a9 00		lda #$00			lda 	#0
.eb3e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb41	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb44	60		rts				rts
.eb45					UNARY_Page:
.eb45	a9 00		lda #$00			lda 	#BasicProgram & $FF
.eb47	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb4a	a9 23		lda #$23			lda 	#BasicProgram >> 8
.eb4c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb4f	a9 00		lda #$00			lda 	#0
.eb51	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb54	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb57	60		rts				rts
.eb58					UNARY_Rnd:
.eb58	20 63 eb	jsr $eb63			jsr 	Random16 					; call 16 bit RNG twice
.eb5b	e8		inx				inx
.eb5c	e8		inx				inx
.eb5d	20 63 eb	jsr $eb63			jsr 	Random16
.eb60	ca		dex				dex
.eb61	ca		dex				dex
.eb62	60		rts				rts
.eb63					Random16:
.eb63	ad 9e 20	lda $209e			lda 	RandomSeed 					; initialise if nonzero
.eb66	0d 9f 20	ora $209f			ora 	RandomSeed+1
.eb69	d0 0d		bne $eb78			bne 	_R16_NoInit
.eb6b	ee 9e 20	inc $209e			inc 	RandomSeed 					; by setting low to 1
.eb6e	5a		phy				phy
.eb6f	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.eb71					_R16_Setup:
.eb71	20 63 eb	jsr $eb63			jsr 	Random16
.eb74	88		dey				dey
.eb75	d0 fa		bne $eb71			bne 	_R16_Setup
.eb77	7a		ply				ply
.eb78					_R16_NoInit:
.eb78	4e 9f 20	lsr $209f			lsr 	RandomSeed+1				; shift seed right
.eb7b	6e 9e 20	ror $209e			ror 	RandomSeed
.eb7e	90 08		bcc $eb88			bcc 	_R16_NoXor
.eb80	ad 9f 20	lda $209f			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.eb83	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.eb85	8d 9f 20	sta $209f			sta 	RandomSeed+1
.eb88					_R16_NoXor:
.eb88	ad 9e 20	lda $209e			lda 	RandomSeed					; copy result to evaluate stack.
.eb8b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb8e	ad 9f 20	lda $209f			lda 	RandomSeed+1
.eb91	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb94	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.eb95					COMMAND_Run:
.eb95	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; clear everything for a new run.
.eb98	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.eb9a	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.eb9c	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.eb9e	84 21		sty $21				sty 	zCurrentLine+1
.eba0					CRUNNewLine:
.eba0	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.eba2	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.eba4	f0 78		beq $ec1e			beq 	COMMAND_End 				; if zero, off end of program so stop.
.eba6	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.eba8					CRUNNextInstruction:
.eba8	ee a2 20	inc $20a2			inc 	breakCheckCount 			; don't check every time, might be slow.
.ebab	ad a2 20	lda $20a2			lda 	breakCheckCount
.ebae	29 1f		and #$1f			and 	#$1F 						; checking once in 32.
.ebb0	f0 0e		beq $ebc0			beq 	_CRUNNoCheck
.ebb2	20 1a a0	jsr $a01a			jsr 	EXTCheckBreak
.ebb5	f0 09		beq $ebc0			beq 	_CRUNNoCheck
.ebb7	20 3d e1	jsr $e13d			jsr 	ReportError
>ebba	42 52 45 41 4b 00				.text 	"BREAK",$00
.ebc0					_CRUNNoCheck:
.ebc0	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.ebc2	8d 9d 20	sta $209d			sta 	StringBufferPos
.ebc5	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.ebc7	f0 0b		beq $ebd4			beq 	CRUNNextLine 				; if zero, then end of line.
.ebc9					CRUNNotEndOfLine:
.ebc9	c9 20		cmp #$20			cmp 	#' '
.ebcb	f0 04		beq $ebd1			beq 	CRUNSkipLoop
.ebcd	c9 8d		cmp #$8d			cmp 	#KW_Colon 					; check for a colon first.
.ebcf	d0 1b		bne $ebec			bne 	CRUNExecuteOne 				; if not that, execute the token.
.ebd1					CRUNSkipLoop:
.ebd1	c8		iny				iny		 							; if colon, skip it and loop round.
.ebd2	80 d4		bra $eba8			bra 	CRUNNextInstruction
.ebd4					CRUNNextLine:
.ebd4	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.ebd6	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.ebd8	f0 0f		beq $ebe9			beq		CRUNWarmStart
.ebda	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.ebdc	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ebde	18		clc				clc
.ebdf	65 20		adc $20				adc 	zCurrentLine
.ebe1	85 20		sta $20				sta 	zCurrentLine
.ebe3	90 bb		bcc $eba0			bcc 	CRUNNewLine
.ebe5	e6 21		inc $21				inc 	zCurrentLine+1
.ebe7	80 b7		bra $eba0			bra 	CRUNNewLine
.ebe9					CRUNWarmStart:
.ebe9	4c 1e f0	jmp $f01e			jmp 	WarmStart
.ebec					CRUNExecuteOne:
.ebec	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.ebee	10 21		bpl $ec11			bpl		_CRUNX1TryLet
.ebf0	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.ebf2	f0 1d		beq $ec11			beq 	_CRUNX1TryLet
.ebf4	c9 80		cmp #$80			cmp 	#KW_PLING
.ebf6	f0 19		beq $ec11			beq 	_CRUNX1TryLet
.ebf8	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ebfa	f0 15		beq $ec11			beq 	_CRUNX1TryLet
.ebfc	c8		iny				iny 								; skip over loaded token
.ebfd	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.ebfe	8d 99 20	sta $2099			sta 	Temp1+1 					; this is the low byte into the KVT
.ec01	8a		txa				txa
.ec02	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.ec04	8d 9a 20	sta $209a			sta 	Temp1+2
.ec07	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.ec09	8d 98 20	sta $2098			sta 	Temp1+0
.ec0c	20 98 20	jsr $2098			jsr 	Temp1 						; call instruction
.ec0f	80 97		bra $eba8			bra 	CRUNNextInstruction 		; do next instruction.
.ec11					_CRUNX1TryLet:
.ec11	20 e2 ec	jsr $ece2			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.ec14	80 92		bra $eba8			bra 	CRUNNextInstruction
.ec16					COMMAND_Stop:
.ec16	20 3d e1	jsr $e13d			jsr 	ReportError
>ec19	53 54 4f 50 00					.text 	"STOP",$00
.ec1e					COMMAND_End:
.ec1e	ad 51 23	lda $2351			lda 	StartBehaviour 				; running program
.ec21	c9 52		cmp #$52			cmp 	#"R"
.ec23	d0 01		bne $ec26			bne 	_CEWarmStart
>ec25	02						.byte 	2
.ec26					_CEWarmStart:
.ec26	4c 1e f0	jmp $f01e			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.ec29					COMMAND_Assert:
.ec29	20 dd e1	jsr $e1dd			jsr 	EvaluateBase 				; evaluate the expression
.ec2c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.ec2f	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ec32	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ec35	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ec38	d0 12		bne $ec4c			bne 	_CMDAExit
.ec3a	ea		nop				nop
.ec3b	20 3d e1	jsr $e13d			jsr 	ReportError
>ec3e	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>ec46	41 49 4c 45 44 00
.ec4c					_CMDAExit:
.ec4c	60		rts				rts
.ec4d					COMMAND_Rem:
.ec4d	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.ec4f	f0 05		beq $ec56			beq 	_CREMExit 					; End of line, then exit.
.ec51	c8		iny				iny 								; something to skip
.ec52	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; if not a colon
.ec54	d0 f7		bne $ec4d			bne 	COMMAND_Rem 				; keep searching
.ec56					_CREMExit:
.ec56	60		rts				rts
.ec57					COMMAND_NewExec:
.ec57	20 5d ec	jsr $ec5d			jsr 	COMMAND_NewCode
.ec5a	4c 1e f0	jmp $f01e			jmp 	WarmStart
.ec5d					COMMAND_NewCode:
.ec5d	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.ec5f	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.ec62	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.ec65	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.ec67	8d 96 20	sta $2096			sta 	HighMemory
.ec6a	a9 80		lda #$80			lda 	#endMemory >> 8
.ec6c	8d 97 20	sta $2097			sta 	HighMemory+1
.ec6f	60		rts				rts
.ec70					COMMAND_Clear:
.ec70	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.ec72					_CCClearVar:
.ec72	a9 00		lda #$00			lda 	#$00
.ec74	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.ec77	e8		inx				inx
.ec78	e0 6c		cpx #$6c			cpx 	#27*4
.ec7a	10 f6		bpl $ec72			bpl 	_CCClearVar
.ec7c	a9 00		lda #$00			lda 	#0 							; reset BASIC stack index
.ec7e	8d a3 20	sta $20a3			sta 	basicStackIndex
.ec81	a9 ff		lda #$ff			lda 	#$FF 						; put invalid token on TOS, so when pulled.
.ec83	8d 00 02	sta $0200			sta 	basicStack 					; causes an error.
.ec86	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.ec88	85 22		sta $22				sta 	zLowMemory
.ec8a	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ec8c	85 23		sta $23				sta 	zLowMemory+1
.ec8e					_CCFindEnd:
.ec8e	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.ec90	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.ec92	f0 0b		beq $ec9f			beq 	_CCFoundEnd
.ec94	18		clc				clc 								; go to next line.
.ec95	65 22		adc $22				adc 	zLowMemory
.ec97	85 22		sta $22				sta 	zLowMemory
.ec99	90 f3		bcc $ec8e			bcc 	_CCFindEnd
.ec9b	e6 23		inc $23				inc 	zLowMemory+1
.ec9d	80 ef		bra $ec8e			bra 	_CCFindEnd
.ec9f					_CCFoundEnd:
.ec9f	e6 22		inc $22				inc 	zLowMemory 					; variables etc. start after end of program.
.eca1	d0 02		bne $eca5			bne 	_CCNoCarry 					; skip over zero end offset.
.eca3	e6 23		inc $23				inc 	zLowMemory+1
.eca5					_CCNoCarry:
.eca5	60		rts				rts
.eca6					COMMAND_OldExec:
.eca6	20 ac ec	jsr $ecac			jsr 	COMMAND_OldCode
.eca9	4c 1e f0	jmp $f01e			jmp 	WarmStart
.ecac					COMMAND_OldCode:
.ecac	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.ecae	85 22		sta $22				sta 	zLowMemory
.ecb0	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ecb2	85 23		sta $23				sta 	zLowMemory+1
.ecb4	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.ecb6					_COScan:
.ecb6	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; look at next byte pair
.ecb8	c8		iny				iny
.ecb9	f0 0d		beq $ecc8			beq 	_COFail 					; can't find marker, corrupted maybe ?
.ecbb	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.ecbd	d0 f7		bne $ecb6			bne 	_COScan
.ecbf	98		tya				tya 								; Y is the new offset to the next instruction
.ecc0	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.ecc2	91 22		sta ($22),y			sta 	(zLowMemory),y
.ecc4	20 70 ec	jsr $ec70			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.ecc7	60		rts				rts
.ecc8					_COFail:
.ecc8	20 3d e1	jsr $e13d			jsr 	ReportError
>eccb	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>ecd3	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ece2					COMMAND_Let:
.ece2	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ece4	f0 58		beq $ed3e			beq 	_CLESyntax
.ece6	c8		iny				iny
.ece7	c9 20		cmp #$20			cmp 	#32
.ece9	f0 f7		beq $ece2			beq 	COMMAND_Let
.eceb	88		dey				dey
.ecec	c9 95		cmp #$95			cmp 	#KW_QUESTION				; check for first being indirect.
.ecee	f0 51		beq $ed41			beq 	_CLEIndirect 				; e.g. !x = 42
.ecf0	c9 80		cmp #$80			cmp 	#KW_PLING
.ecf2	f0 4d		beq $ed41			beq 	_CLEIndirect
.ecf4	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ecf6	f0 49		beq $ed41			beq 	_CLEIndirect
.ecf8	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ecfa	20 f0 e3	jsr $e3f0			jsr 	VARReference 				; get a variable reference.
.ecfd	a5 24		lda $24				lda 	zTemp1 						; copy into target addr
.ecff	85 28		sta $28				sta 	zTargetAddr
.ed01	a5 25		lda $25				lda 	zTemp1+1
.ed03	85 29		sta $29				sta 	zTargetAddr+1
.ed05	a5 26		lda $26				lda 	zTemp1+2
.ed07	85 2a		sta $2a				sta 	zTargetAddr+2
.ed09	a5 27		lda $27				lda 	zTemp1+3
.ed0b	85 2b		sta $2b				sta 	zTargetAddr+3
.ed0d					_CLEGetBinLHSOp:
.ed0d	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ed0f	f0 2d		beq $ed3e			beq 	_CLESyntax
.ed11	c8		iny				iny
.ed12	c9 20		cmp #$20			cmp 	#' '
.ed14	f0 f7		beq $ed0d			beq 	_CLEGetBinLHSOp
.ed16	88		dey				dey
.ed17	c9 95		cmp #$95			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ed19	f0 45		beq $ed60			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ed1b	c9 80		cmp #$80			cmp 	#KW_PLING
.ed1d	f0 41		beq $ed60			beq 	_CLEBinaryLHTerm
.ed1f	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed21	f0 3d		beq $ed60			beq 	_CLEBinaryLHTerm
.ed23	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ed25					_CLEWriteToAddress:
.ed25	48		pha				pha 								; save write-type.
.ed26	a9 92		lda #$92			lda 	#KW_EQUAL 					; check for '=' sign.
.ed28	20 81 e1	jsr $e181			jsr 	CheckNextCharacter
.ed2b	20 dd e1	jsr $e1dd			jsr 	EvaluateBase 				; evaluate the RHS.
.ed2e	68		pla				pla
.ed2f	c9 80		cmp #$80			cmp 	#KW_PLING
.ed31	f0 6e		beq $eda1			beq 	_CLEWordWrite
.ed33	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ed35	f0 60		beq $ed97			beq 	_CLEByteWrite
.ed37	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed39					_ErrorInternal:
.ed39	d0 fe		bne $ed39			bne 	_ErrorInternal
.ed3b	4c bd ed	jmp $edbd			jmp 	_CLEStringWrite
.ed3e					_CLESyntax:
.ed3e	4c 2d e1	jmp $e12d			jmp 	SyntaxError
.ed41					_CLEIndirect:
.ed41	48		pha				pha 								; save operator on stack
.ed42	c8		iny				iny									; advance over cursor
.ed43	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ed45	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel
.ed48	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.ed4b	85 28		sta $28				sta 	zTargetAddr+0
.ed4d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ed50	85 29		sta $29				sta 	zTargetAddr+1
.ed52	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ed55	85 2a		sta $2a				sta 	zTargetAddr+2
.ed57	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ed5a	85 2b		sta $2b				sta 	zTargetAddr+3
.ed5c	68		pla				pla 								; restore operator.
.ed5d	4c 25 ed	jmp $ed25			jmp 	_CLEWriteToAddress
.ed60					_CLEBinaryLHTerm:
.ed60	48		pha				pha 								; save operator on stack
.ed61	c8		iny				iny 								; skip over it.
.ed62	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ed64	20 d9 e1	jsr $e1d9			jsr 	EvaluateAtomCurrentLevel
.ed67	a5 28		lda $28				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.ed69	85 24		sta $24				sta 	zTemp1 						; a four byte address.....
.ed6b	a5 29		lda $29				lda 	zTargetAddr+1
.ed6d	85 25		sta $25				sta 	zTemp1+1 					; we only worry about 4 byte value
.ed6f	5a		phy				phy 								; save Y
.ed70	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.ed71	a0 00		ldy #$00			ldy 	#0
.ed73	b1 24		lda ($24),y			lda 	(zTemp1),y
.ed75	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.ed78	85 28		sta $28				sta 	zTargetAddr+0
.ed7a	c8		iny				iny
.ed7b	b1 24		lda ($24),y			lda 	(zTemp1),y
.ed7d	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.ed80	85 29		sta $29				sta 	zTargetAddr+1
.ed82	c8		iny				iny
.ed83	b1 24		lda ($24),y			lda 	(zTemp1),y
.ed85	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.ed88	85 2a		sta $2a				sta 	zTargetAddr+2
.ed8a	c8		iny				iny
.ed8b	b1 24		lda ($24),y			lda 	(zTemp1),y
.ed8d	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.ed90	85 2b		sta $2b				sta 	zTargetAddr+3
.ed92	7a		ply				ply 								; restore Y
.ed93	68		pla				pla 								; restore the operator.
.ed94	4c 25 ed	jmp $ed25			jmp 	_CLEWriteToAddress
.ed97					_CLEByteWrite:
.ed97	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ed9a	5a		phy				phy 								; write the byte preserving Y
.ed9b	a0 00		ldy #$00			ldy 	#0
.ed9d	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ed9f	7a		ply				ply
.eda0	60		rts				rts
.eda1					_CLEWordWrite:
.eda1	5a		phy				phy
.eda2	a0 00		ldy #$00			ldy 	#0
.eda4	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.eda7	91 28		sta ($28),y			sta 	(zTargetAddr),y
.eda9	c8		iny				iny
.edaa	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.edad	91 28		sta ($28),y			sta 	(zTargetAddr),y
.edaf	c8		iny				iny
.edb0	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.edb3	91 28		sta ($28),y			sta 	(zTargetAddr),y
.edb5	c8		iny				iny
.edb6	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.edb9	91 28		sta ($28),y			sta 	(zTargetAddr),y
.edbb	7a		ply				ply 								; restore Y
.edbc	60		rts				rts
.edbd					_CLEStringWrite:
.edbd	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.edc0	85 24		sta $24				sta 	zTemp1
.edc2	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.edc5	85 25		sta $25				sta 	zTemp1+1
.edc7	5a		phy				phy
.edc8	a0 00		ldy #$00			ldy 	#0
.edca					_CLEStringCopy:
.edca	b1 24		lda ($24),y			lda 	(zTemp1),y
.edcc	91 28		sta ($28),y			sta 	(zTargetAddr),y
.edce	c9 00		cmp #$00			cmp 	#0
.edd0	f0 16		beq $ede8			beq	 	_CLEStringWritten
.edd2	c8		iny				iny
.edd3	d0 f5		bne $edca			bne 	_CLEStringCopy
.edd5	20 3d e1	jsr $e13d			jsr 	ReportError
>edd8	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>ede0	4e 47 20 43 4f 50 59 00
.ede8					_CLEStringWritten:
.ede8	7a		ply				ply
.ede9	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.edea					COMMAND_Print:
.edea	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.edec	f0 15		beq $ee03			beq 	_CPRExitNL 					; zero end of line.
.edee	c8		iny				iny
.edef	c9 20		cmp #$20			cmp 	#' '
.edf1	f0 f7		beq $edea			beq 	COMMAND_Print
.edf3	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; colon, end of line
.edf5	f0 0c		beq $ee03			beq 	_CPRExitNL
.edf7	c9 8e		cmp #$8e			cmp 	#KW_SEMICOLON 				; semicolon ?
.edf9	d0 0e		bne $ee09			bne 	_CPRNotSemicolon
.edfb	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.edfd	f0 09		beq $ee08			beq 	_CPRExit
.edff	c9 8d		cmp #$8d			cmp 	#KW_COLON
.ee01	d0 e7		bne $edea			bne 	COMMAND_Print 				; if not, just go back round again
.ee03					_CPRExitNL:
.ee03	a9 0d		lda #$0d			lda 	#13
.ee05	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ee08					_CPRExit:
.ee08	60		rts				rts
.ee09					_CPRNotSemicolon:
.ee09	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.ee0b	f0 2b		beq $ee38			beq 	_CPRNewLine 				; new line
.ee0d	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.ee0f	d0 2e		bne $ee3f			bne 	_CPRNotQuote
.ee11					_CPRPrintText:
.ee11	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.ee13	f0 0a		beq $ee1f			beq 	_CPRError 					; if zero no closing quote
.ee15	c8		iny				iny
.ee16	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.ee18	f0 d0		beq $edea			beq 	COMMAND_Print 				; go round again.
.ee1a	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter 			; print and do next character
.ee1d	80 f2		bra $ee11			bra 	_CPRPrintText
.ee1f					_CPRError:
.ee1f	20 3d e1	jsr $e13d			jsr 	ReportError
>ee22	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>ee2a	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.ee38					_CPRNewLine:
.ee38	a9 0d		lda #$0d			lda 	#13
.ee3a	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ee3d	80 ab		bra $edea			bra 	COMMAND_Print
.ee3f					_CPRNotQuote:
.ee3f	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.ee41	d0 11		bne $ee54			bne 	_CPRNumber 					; print a number.
.ee43	20 dd e1	jsr $e1dd			jsr 	EvaluateBase 				; this is the address to print.
.ee46	5a		phy				phy
.ee47	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.ee4a	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ee4d	aa		tax				tax
.ee4e	20 7d e4	jsr $e47d			jsr 	SIOPrintString
.ee51	7a		ply				ply
.ee52	80 96		bra $edea			bra 	COMMAND_Print
.ee54					_CPRNumber:
.ee54	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.ee56	f0 17		beq $ee6f			beq 	_CPRHexadecimal
.ee58	88		dey				dey 								; must be 1st char of expr
.ee59	20 dd e1	jsr $e1dd			jsr 	EvaluateBase 				; this is the value to print.
.ee5c	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.ee5f	10 08		bpl $ee69			bpl 	_CPRIsPositive
.ee61	20 ce e9	jsr $e9ce			jsr 	BFUNC_NegateAlways 			; negate it
.ee64	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.ee66	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ee69					_CPRIsPositive:
.ee69	20 ac ee	jsr $eeac			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.ee6c	4c ea ed	jmp $edea			jmp 	COMMAND_Print
.ee6f					_CPRHexadecimal:
.ee6f	20 dd e1	jsr $e1dd			jsr 	EvaluateBase 				; this is the value to print.
.ee72	20 78 ee	jsr $ee78			jsr 	_CPRPrintRecHex 			; hex version of it.
.ee75	4c ea ed	jmp $edea			jmp 	COMMAND_Print
.ee78					_CPRPrintRecHex:
.ee78	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.ee7b	29 0f		and #$0f			and 	#15 						; and put on stack
.ee7d	48		pha				pha
.ee7e	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.ee80					_CPRShiftDiv:
.ee80	4e 03 04	lsr $0403			lsr 	evalStack+3
.ee83	6e 02 04	ror $0402			ror 	evalStack+2
.ee86	6e 01 04	ror $0401			ror		evalStack+1
.ee89	6e 00 04	ror $0400			ror		evalStack+0
.ee8c	ca		dex				dex
.ee8d	d0 f1		bne $ee80			bne 	_CPRShiftDiv
.ee8f	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.ee92	0d 01 04	ora $0401			ora 	evalStack+1
.ee95	0d 02 04	ora $0402			ora 	evalStack+2
.ee98	0d 03 04	ora $0403			ora 	evalStack+3
.ee9b	f0 03		beq $eea0			beq 	_CPRNoHexRec
.ee9d	20 78 ee	jsr $ee78			jsr 	_CPRPrintRecHex
.eea0					_CPRNoHexRec:
.eea0	68		pla				pla 								; original remainder.
.eea1	c9 0a		cmp #$0a			cmp 	#10
.eea3	90 02		bcc $eea7			bcc		_CPRNH2
.eea5	69 06		adc #$06			adc 	#6
.eea7	69 30		adc #$30	_CPRNH2:adc 	#48
.eea9	4c aa e4	jmp $e4aa			jmp 	SIOPrintCharacter
.eeac					CPRPrintInteger:
.eeac	48		pha				pha 								; save on stack.
.eead	da		phx				phx
.eeae	5a		phy				phy
.eeaf	20 b6 ee	jsr $eeb6			jsr 	_CPRPrintRec 				; recursive print call
.eeb2	7a		ply				ply
.eeb3	fa		plx				plx
.eeb4	68		pla				pla
.eeb5	60		rts				rts
.eeb6					_CPRPrintRec:
.eeb6	a9 0a		lda #$0a			lda 	#10 						; save base
.eeb8	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.eebb	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.eebd	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.eec0	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.eec3	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.eec6	20 2b e9	jsr $e92b			jsr 	BFUNC_Divide 				; divide by 10.
.eec9	ad 98 20	lda $2098			lda 	Temp1+0		 				; push remainder on stack
.eecc	48		pha				pha
.eecd	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.eed0	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.eed3	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.eed6	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.eed9	f0 03		beq $eede			beq 	_CPRNoRecurse
.eedb	20 b6 ee	jsr $eeb6			jsr 	_CPRPrintRec 				; recursive print.
.eede					_CPRNoRecurse:
.eede	68		pla				pla
.eedf	09 30		ora #$30			ora 	#"0"
.eee1	4c aa e4	jmp $e4aa			jmp 	SIOPrintCharacter
.eee4					COMMAND_CLS:
.eee4	4c 6f e4	jmp $e46f			jmp 	SIOClearScreen

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.eee7					COMMAND_List:
.eee7	5a		phy				phy
.eee8	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.eeea	85 28		sta $28				sta 	zTargetAddr
.eeec	a9 23		lda #$23			lda 	#BasicProgram >> 8
.eeee	85 29		sta $29				sta 	zTargetAddr+1
.eef0	a9 10		lda #$10			lda 	#16 						; print 16 lines
.eef2	85 2a		sta $2a				sta 	zTargetAddr+2
.eef4					_CLLILoop:
.eef4	a0 00		ldy #$00			ldy 	#0
.eef6	b1 28		lda ($28),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.eef8	f0 14		beq $ef0e			beq 	_CLLIExit
.eefa	20 10 ef	jsr $ef10			jsr 	CLIOneLine 					; list one line.
.eefd	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.eeff	18		clc				clc
.ef00	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef02	65 28		adc $28				adc 	zTargetAddr
.ef04	85 28		sta $28				sta 	zTargetAddr
.ef06	90 02		bcc $ef0a			bcc 	_CLLINoCarry
.ef08	e6 29		inc $29				inc 	zTargetAddr+1
.ef0a					_CLLINoCarry:
.ef0a	c6 2a		dec $2a				dec 	zTargetAddr+2 				; done all of them ?
.ef0c	d0 e6		bne $eef4			bne 	_CLLILoop
.ef0e					_CLLIExit:
.ef0e	7a		ply				ply
.ef0f	60		rts				rts
.ef10					CLIOneLine:
.ef10	a0 01		ldy #$01			ldy 	#1 							; get line#
.ef12	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef14	8d 00 04	sta $0400			sta 	evalStack+0
.ef17	c8		iny				iny
.ef18	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef1a	8d 01 04	sta $0401			sta 	evalStack+1
.ef1d	a9 00		lda #$00			lda 	#0
.ef1f	aa		tax				tax
.ef20	8d 02 04	sta $0402			sta 	evalStack+2
.ef23	8d 03 04	sta $0403			sta 	evalStack+3
.ef26	20 ac ee	jsr $eeac			jsr 	CPRPrintInteger 			; print line#
.ef29	a9 20		lda #$20			lda 	#32
.ef2b	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ef2e	a0 03		ldy #$03			ldy 	#3 							; where to start
.ef30					_CLIOutput:
.ef30	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef32	c8		iny				iny
.ef33	09 00		ora #$00			ora 	#0
.ef35	f0 0c		beq $ef43			beq 	_CLIExit
.ef37	10 05		bpl $ef3e			bpl		_CLISingle
.ef39	20 49 ef	jsr $ef49			jsr 	CLIPrintToken
.ef3c	80 f2		bra $ef30			bra 	_CLIOutput
.ef3e					_CLISingle:
.ef3e	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ef41	80 ed		bra $ef30			bra 	_CLIOutput
.ef43					_CLIExit:
.ef43	a9 0d		lda #$0d			lda 	#13 						; new line.
.ef45	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ef48	60		rts				rts
.ef49					CLIPrintToken:
.ef49	5a		phy				phy 								; save Y
.ef4a	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.ef4c	a8		tay				tay
.ef4d	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.ef4f					_CLIFind:
.ef4f	88		dey				dey 								; decrement counter
.ef50	30 09		bmi $ef5b			bmi 	_CLIFoundToken 				; if -ve found the token.
.ef52					_CLISkip:
.ef52	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.ef55	e8		inx				inx
.ef56	0a		asl a				asl		a
.ef57	90 f9		bcc $ef52			bcc 	_CLISkip
.ef59	80 f4		bra $ef4f			bra 	_CLIFind
.ef5b					_CLIFoundToken:
.ef5b	7a		ply				ply
.ef5c					_CLIPrintIt:
.ef5c	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.ef5f	e8		inx				inx
.ef60	48		pha				pha
.ef61	29 7f		and #$7f			and 	#$7F
.ef63	20 aa e4	jsr $e4aa			jsr 	SIOPrintCharacter
.ef66	68		pla				pla
.ef67	0a		asl a				asl 	a
.ef68	90 f2		bcc $ef5c			bcc 	_CLIPrintIt
.ef6a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/dountil.asm

.ef6b					COMMAND_Do:
.ef6b	a9 9c		lda #$9c			lda 	#KW_DO						; push position with a DO token.
.ef6d	20 8b ef	jsr $ef8b			jsr 	CDOPushPosOnStack
.ef70	60		rts				rts
.ef71					COMMAND_Until:
.ef71	a9 9c		lda #$9c			lda 	#KW_DO 						; check TOS is a Do.
.ef73	20 c9 ef	jsr $efc9			jsr 	CDOCheckTopStack
.ef76	a2 00		ldx #$00			ldx 	#0 							; evaluate the test
.ef78	20 dd e1	jsr $e1dd			jsr 	EvaluateBase
.ef7b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check if zero
.ef7e	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ef81	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ef84	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ef87	f0 2a		beq $efb3			beq 	CDOPullPosOffStack 			; zero, restore the position.
.ef89	80 1e		bra $efa9			bra 	CDOThrowPosOffStack			; non-zero chuck it.
.ef8b					CDOPushPosOnStack:
.ef8b	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.ef8e	48		pha				pha
.ef8f	98		tya				tya
.ef90	9d 01 02	sta $0201,x			sta 	BasicStack+1,x 				; +1 	Y Position
.ef93	a5 20		lda $20				lda 	zCurrentLine
.ef95	9d 02 02	sta $0202,x			sta 	BasicStack+2,x 				; +2 	low of pos
.ef98	a5 21		lda $21				lda 	zCurrentLine+1
.ef9a	9d 03 02	sta $0203,x			sta 	BasicStack+3,x 				; +3 	high of pos
.ef9d	68		pla				pla
.ef9e	9d 04 02	sta $0204,x			sta 	BasicStack+4,x 				; +4 	token on stack
.efa1	e8		inx				inx
.efa2	e8		inx				inx
.efa3	e8		inx				inx
.efa4	e8		inx				inx 								; always points to TOS.
.efa5	8e a3 20	stx $20a3			stx 	basicStackIndex
.efa8	60		rts				rts
.efa9					CDOThrowPosOffStack:
.efa9	ad a3 20	lda $20a3			lda 	basicStackIndex
.efac	38		sec				sec
.efad	e9 04		sbc #$04			sbc 	#4
.efaf	8d a3 20	sta $20a3			sta 	basicStackIndex
.efb2	60		rts				rts
.efb3					CDOPullPosOffStack:
.efb3	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.efb6	ca		dex				dex
.efb7	ca		dex				dex
.efb8	ca		dex				dex
.efb9	ca		dex				dex
.efba	bd 01 02	lda $0201,x			lda 	BasicStack+1,x 					; get position back.
.efbd	a8		tay				tay
.efbe	bd 02 02	lda $0202,x			lda 	BasicStack+2,x
.efc1	85 20		sta $20				sta 	zCurrentLine
.efc3	bd 03 02	lda $0203,x			lda 	BasicStack+3,x
.efc6	85 21		sta $21				sta 	zCurrentLine+1
.efc8	60		rts				rts
.efc9					CDOCheckTopStack:
.efc9	ae a3 20	ldx $20a3			ldx 	basicStackIndex 			; if match
.efcc	dd 00 02	cmp $0200,x			cmp 	BasicStack+0,x
.efcf	d0 01		bne $efd2			bne 	_CDOCTSError
.efd1	60		rts				rts
.efd2					_CDOCTSError:
.efd2	20 3d e1	jsr $e13d			jsr 	ReportError
>efd5	53 54 52 55 43 54 55 52				.text 	"STRUCTURE MIXED",$00
>efdd	45 20 4d 49 58 45 44 00

;******  Return to file: basic.asm

.efe5					Start:
.efe5	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.efe7	9a		txs			txs
.efe8	20 6c e4	jsr $e46c			jsr 	SIOInitialise 				; initialise the I/O system.
.efeb	a2 5e		ldx #$5e			ldx 	#BootMsg1 & 255 			; boot text.
.efed	a0 f0		ldy #$f0			ldy 	#BootMsg1 >> 8
.efef	20 7d e4	jsr $e47d			jsr 	SIOPrintString
.eff2	a2 ff		ldx #$ff			ldx 	#(endMemory-startMemory-1) & $FF
.eff4	a0 5f		ldy #$5f			ldy 	#(endMemory-startMemory-1) >> 8
.eff6	20 6a e1	jsr $e16a			jsr 	PrintWordInteger
.eff9	a2 75		ldx #$75			ldx 	#BootMsg2 & 255
.effb	a0 f0		ldy #$f0			ldy 	#BootMsg2 >> 8
.effd	20 7d e4	jsr $e47d			jsr 	SIOPrintString
.f000	ad 51 23	lda $2351			lda 	StartBehaviour 				; what to do ?
.f003	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.f005	f0 14		beq $f01b			beq		CommandLine
.f007	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.f009	f0 07		beq $f012			beq	 	RunProgram
.f00b	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.f00d	f0 43		beq $f052			beq 	TokeniseExec
.f00f	4c 2d e1	jmp $e12d			jmp		SyntaxError
.f012					RunProgram:
.f012	20 5d ec	jsr $ec5d			jsr 	COMMAND_NewCode 			; do a new
.f015	20 ac ec	jsr $ecac			jsr 	COMMAND_OldCode 			; get back the old program as we're deving.
.f018	4c 95 eb	jmp $eb95			jmp 	COMMAND_Run
.f01b					CommandLine:
.f01b	20 5d ec	jsr $ec5d			jsr 	Command_NewCode
.f01e					WarmStart:
.f01e	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f020	9a		txs			txs
.f021	20 e7 e4	jsr $e4e7			jsr 	SIOReadLine 				; read input line.
.f024	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.f026	85 24		sta $24				sta 	zTemp1
.f028	a9 20		lda #$20			lda 	#InputLine >> 8
.f02a	85 25		sta $25				sta 	zTemp1+1
.f02c	20 55 e6	jsr $e655			jsr 	TokeniseString
.f02f	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.f031	85 20		sta $20				sta 	zCurrentLine
.f033	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.f035	85 21		sta $21				sta 	zCurrentLine+1
.f037	a0 00		ldy #$00			ldy 	#0
.f039					_WSSkipSpace:
.f039	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f03b	c8		iny				iny
.f03c	c9 20		cmp #$20			cmp 	#' '
.f03e	f0 f9		beq $f039			beq 	_WSSkipSpace
.f040	88		dey				dey
.f041	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.f043	90 0a		bcc $f04f			bcc 	_WSExecute
.f045	c9 3a		cmp #$3a			cmp 	#"9"+1
.f047	b0 06		bcs $f04f			bcs 	_WSExecute
.f049	20 2a e7	jsr $e72a			jsr 	EditProgram
.f04c	4c 1e f0	jmp $f01e			jmp 	WarmStart
.f04f					_WSExecute:
.f04f	4c a8 eb	jmp $eba8			jmp 	CRUNNextInstruction
.f052					TokeniseExec:
.f052	a9 00		lda #$00			lda 	#BasicCode & $FF 			; if so tokenise whatever I've put in the basic code
.f054	85 24		sta $24				sta 	zTemp1 						; area
.f056	a9 23		lda #$23			lda 	#BasicCode >> 8
.f058	85 25		sta $25				sta 	zTemp1+1
.f05a	20 55 e6	jsr $e655			jsr 	TokeniseString
>f05d	02						.byte 	2
.f05e					BootMsg1:
>f05e	2a 2a 2a 20 41 54 4f 4d				.text 	"*** ATOMIC BASIC ***",13,13,0
>f066	49 43 20 42 41 53 49 43 20 2a 2a 2a 0d 0d 00
.f075					BootMsg2:
>f075	20 42 59 54 45 53 20 46				.text	" BYTES FREE.",13,13,0
>f07d	52 45 45 2e 0d 0d 00
.2300					BasicCode:

;******  Processing file: include/basic_generated.inc

>2300	0b 64 00 41 20 92 20 30			.byte $0b,$64,$00,$41,$20,$92,$20,$30,$8d,$9c,$00,$09,$2c,$01,$58,$20,$92,$20,$30,$00,$25,$2d,$01,$9c,$8d,$58,$20,$92,$20,$58,$20,$8a,$20,$31,$8d,$aa,$20,$41,$81,$20,$81,$58,$81,$20,$81,$41,$89,$58,$8d,$b4,$20,$58,$20,$92,$20,$35,$00,$17,$2e,$01,$41,$20,$92,$20,$41,$20,$8a,$20,$31,$8d,$b4,$20,$41,$20,$92,$20,$33,$8d,$af,$00,$00
>2308	8d 9c 00 09 2c 01 58 20 92 20 30 00 25 2d 01 9c
>2318	8d 58 20 92 20 58 20 8a 20 31 8d aa 20 41 81 20
>2328	81 58 81 20 81 41 89 58 8d b4 20 58 20 92 20 35
>2338	00 17 2e 01 41 20 92 20 41 20 8a 20 31 8d b4 20
>2348	41 20 92 20 33 8d af 00 00
.2351					StartBehaviour:
>2351	52					.text "R"

;******  Return to file: basic.asm


;******  End of listing
