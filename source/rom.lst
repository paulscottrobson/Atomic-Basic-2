
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass --m4510 -D TARGET=1 -b -L rom.lst -o rom.bin basic.asm
; Fri Jul 26 22:20:09 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					TARGET=1

;******  Processing input file: basic.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	00 b0						.word 	EXTStartPersonalise
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for EXT (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20
=$2000							startMemory = $2000
=$4000							endMemory   = $4000
=$200							basicStack  = $200
=$400							evalStack   = $400

;******  Processing file: personalities/personality_mega65.asm

=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$2000					EXTLowMemory = $2000 						; Workspace RAM starts here
=$8000					EXTHighMemory = $8000 						; Workspace RAM ends here
=$1000					EXTScreen = $1000							; 2k screen RAM here
=$800					EXTCharSet = $800							; 2k character set (0-7F) here
>0000	00 00					.word 	0 								; forces it to be a 64k ROM (at least)
.a000					EXTCBMFont:
>a000	3c 66 6e 6e 60 62 3c 00			.binary "c64-chargen.rom"
>a008	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>a018	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>a028	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>a038	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>a048	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>a058	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>a068	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>a078	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>a088	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>a098	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>a0a8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>a0b8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>a0c8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>a0d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a0e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a0f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a108	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a118	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a128	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a138	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a148	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a158	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a168	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a178	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a188	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a198	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a1a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a1b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a1c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a1d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a1e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a1f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>a208	08 1c 3e 7f 7f 1c 3e 00 18 18 18 18 18 18 18 18
>a218	00 00 00 ff ff 00 00 00 00 00 ff ff 00 00 00 00
>a228	00 ff ff 00 00 00 00 00 00 00 00 00 ff ff 00 00
>a238	30 30 30 30 30 30 30 30 0c 0c 0c 0c 0c 0c 0c 0c
>a248	00 00 00 e0 f0 38 18 18 18 18 1c 0f 07 00 00 00
>a258	18 18 38 f0 e0 00 00 00 c0 c0 c0 c0 c0 c0 ff ff
>a268	c0 e0 70 38 1c 0e 07 03 03 07 0e 1c 38 70 e0 c0
>a278	ff ff c0 c0 c0 c0 c0 c0 ff ff 03 03 03 03 03 03
>a288	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 ff ff 00
>a298	36 7f 7f 7f 3e 1c 08 00 60 60 60 60 60 60 60 60
>a2a8	00 00 00 07 0f 1c 18 18 c3 e7 7e 3c 3c 7e e7 c3
>a2b8	00 3c 7e 66 66 7e 3c 00 18 18 66 66 18 18 3c 00
>a2c8	06 06 06 06 06 06 06 06 08 1c 3e 7f 3e 1c 08 00
>a2d8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>a2e8	18 18 18 18 18 18 18 18 00 00 03 3e 76 36 36 00
>a2f8	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a308	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a318	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a328	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>a338	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>a348	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a358	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>a368	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>a378	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>a388	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>a398	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>a3a8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a3b8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a3c8	00 00 00 00 00 ff ff ff 03 03 03 03 03 03 ff ff
>a3d8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a3e8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a3f8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>a408	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>a418	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>a428	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>a438	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>a448	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>a458	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>a468	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>a478	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>a488	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>a498	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>a4a8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>a4b8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>a4c8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>a4d8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>a4e8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>a4f8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>a508	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>a518	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>a528	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>a538	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>a548	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>a558	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>a568	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>a578	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>a588	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>a598	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>a5a8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>a5b8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>a5c8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>a5d8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>a5e8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>a5f8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>a608	f7 e3 c1 80 80 e3 c1 ff e7 e7 e7 e7 e7 e7 e7 e7
>a618	ff ff ff 00 00 ff ff ff ff ff 00 00 ff ff ff ff
>a628	ff 00 00 ff ff ff ff ff ff ff ff ff 00 00 ff ff
>a638	cf cf cf cf cf cf cf cf f3 f3 f3 f3 f3 f3 f3 f3
>a648	ff ff ff 1f 0f c7 e7 e7 e7 e7 e3 f0 f8 ff ff ff
>a658	e7 e7 c7 0f 1f ff ff ff 3f 3f 3f 3f 3f 3f 00 00
>a668	3f 1f 8f c7 e3 f1 f8 fc fc f8 f1 e3 c7 8f 1f 3f
>a678	00 00 3f 3f 3f 3f 3f 3f 00 00 fc fc fc fc fc fc
>a688	ff c3 81 81 81 81 c3 ff ff ff ff ff ff 00 00 ff
>a698	c9 80 80 80 c1 e3 f7 ff 9f 9f 9f 9f 9f 9f 9f 9f
>a6a8	ff ff ff f8 f0 e3 e7 e7 3c 18 81 c3 c3 81 18 3c
>a6b8	ff c3 81 99 99 81 c3 ff e7 e7 99 99 e7 e7 c3 ff
>a6c8	f9 f9 f9 f9 f9 f9 f9 f9 f7 e3 c1 80 c1 e3 f7 ff
>a6d8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>a6e8	e7 e7 e7 e7 e7 e7 e7 e7 ff ff fc c1 89 c9 c9 ff
>a6f8	00 80 c0 e0 f0 f8 fc fe ff ff ff ff ff ff ff ff
>a708	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>a718	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>a728	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>a738	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>a748	00 01 03 07 0f 1f 3f 7f fc fc fc fc fc fc fc fc
>a758	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>a768	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>a778	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>a788	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>a798	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>a7a8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>a7b8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>a7c8	ff ff ff ff ff 00 00 00 fc fc fc fc fc fc 00 00
>a7d8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>a7e8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>a7f8	0f 0f 0f 0f f0 f0 f0 f0 3c 66 6e 6e 60 62 3c 00
>a808	00 00 3c 06 3e 66 3e 00 00 60 60 7c 66 66 7c 00
>a818	00 00 3c 60 60 60 3c 00 00 06 06 3e 66 66 3e 00
>a828	00 00 3c 66 7e 60 3c 00 00 0e 18 3e 18 18 18 00
>a838	00 00 3e 66 66 3e 06 7c 00 60 60 7c 66 66 66 00
>a848	00 18 00 38 18 18 3c 00 00 06 00 06 06 06 06 3c
>a858	00 60 60 6c 78 6c 66 00 00 38 18 18 18 18 3c 00
>a868	00 00 66 7f 7f 6b 63 00 00 00 7c 66 66 66 66 00
>a878	00 00 3c 66 66 66 3c 00 00 00 7c 66 66 7c 60 60
>a888	00 00 3e 66 66 3e 06 06 00 00 7c 66 60 60 60 00
>a898	00 00 3e 60 3c 06 7c 00 00 18 7e 18 18 18 0e 00
>a8a8	00 00 66 66 66 66 3e 00 00 00 66 66 66 3c 18 00
>a8b8	00 00 63 6b 7f 3e 36 00 00 00 66 3c 18 3c 66 00
>a8c8	00 00 66 66 66 3e 0c 78 00 00 7e 0c 18 30 7e 00
>a8d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a8e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a8f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a908	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a918	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a928	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a938	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a948	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a958	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a968	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a978	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a988	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a998	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a9a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a9b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a9c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a9d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a9e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a9f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>aa08	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>aa18	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>aa28	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>aa38	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>aa48	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>aa58	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>aa68	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>aa78	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>aa88	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>aa98	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>aaa8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>aab8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>aac8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>aad8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>aae8	18 18 18 18 18 18 18 18 33 33 cc cc 33 33 cc cc
>aaf8	33 99 cc 66 33 99 cc 66 00 00 00 00 00 00 00 00
>ab08	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>ab18	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>ab28	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>ab38	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>ab48	cc 99 33 66 cc 99 33 66 03 03 03 03 03 03 03 03
>ab58	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>ab68	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>ab78	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>ab88	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>ab98	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>aba8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>abb8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>abc8	00 00 00 00 00 ff ff ff 01 03 06 6c 78 70 60 00
>abd8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>abe8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>abf8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>ac08	ff ff c3 f9 c1 99 c1 ff ff 9f 9f 83 99 99 83 ff
>ac18	ff ff c3 9f 9f 9f c3 ff ff f9 f9 c1 99 99 c1 ff
>ac28	ff ff c3 99 81 9f c3 ff ff f1 e7 c1 e7 e7 e7 ff
>ac38	ff ff c1 99 99 c1 f9 83 ff 9f 9f 83 99 99 99 ff
>ac48	ff e7 ff c7 e7 e7 c3 ff ff f9 ff f9 f9 f9 f9 c3
>ac58	ff 9f 9f 93 87 93 99 ff ff c7 e7 e7 e7 e7 c3 ff
>ac68	ff ff 99 80 80 94 9c ff ff ff 83 99 99 99 99 ff
>ac78	ff ff c3 99 99 99 c3 ff ff ff 83 99 99 83 9f 9f
>ac88	ff ff c1 99 99 c1 f9 f9 ff ff 83 99 9f 9f 9f ff
>ac98	ff ff c1 9f c3 f9 83 ff ff e7 81 e7 e7 e7 f1 ff
>aca8	ff ff 99 99 99 99 c1 ff ff ff 99 99 99 c3 e7 ff
>acb8	ff ff 9c 94 80 c1 c9 ff ff ff 99 c3 e7 c3 99 ff
>acc8	ff ff 99 99 99 c1 f3 87 ff ff 81 f3 e7 cf 81 ff
>acd8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>ace8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>acf8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>ad08	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>ad18	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>ad28	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>ad38	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>ad48	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>ad58	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>ad68	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>ad78	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>ad88	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>ad98	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>ada8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>adb8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>adc8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>add8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>ade8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>adf8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>ae08	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>ae18	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>ae28	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>ae38	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>ae48	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>ae58	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>ae68	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>ae78	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>ae88	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>ae98	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>aea8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>aeb8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>aec8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>aed8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>aee8	e7 e7 e7 e7 e7 e7 e7 e7 cc cc 33 33 cc cc 33 33
>aef8	cc 66 33 99 cc 66 33 99 ff ff ff ff ff ff ff ff
>af08	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>af18	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>af28	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>af38	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>af48	33 66 cc 99 33 66 cc 99 fc fc fc fc fc fc fc fc
>af58	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>af68	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>af78	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>af88	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>af98	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>afa8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>afb8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>afc8	ff ff ff ff ff 00 00 00 fe fc f9 93 87 8f 9f ff
>afd8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>afe8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>aff8	0f 0f 0f 0f f0 f0 f0 f0
.b000					EXTStartPersonalise:
.b000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.b002	9a		txs			txs
.b003	20 99 b0	jsr $b099		jsr 	EXTReset 						; reset video
.b006	20 49 b0	jsr $b049		jsr 	EXTClearScreen 					; clear screen
.b009	4c e9 e5	jmp $e5e9		jmp 	Start 							; start main application
.b00c					EXTReadKey:
.b00c	db		phz			phz
.b00d	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to read keyboard.
.b00f	85 07		sta $07			sta 	EXTZPWork+3
.b011	a9 fd		lda #$fd		lda 	#$FD
.b013	85 06		sta $06			sta 	EXTZPWork+2
.b015	a9 36		lda #$36		lda 	#$36
.b017	85 05		sta $05			sta 	EXTZPWork+1
.b019	a9 10		lda #$10		lda 	#$10
.b01b	85 04		sta $04			sta 	EXTZPWork+0
.b01d	a3 00		ldz #$00		ldz 	#0
.b01f	ea		nop			nop 									; read keyboard
.b020	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b022	f0 06		beq $b02a		beq 	_EXTRKExit
.b024	48		pha			pha 									; save key
.b025	6b		tza			tza 									; reset input
.b026	ea		nop			nop
.b027	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b029	68		pla			pla 									; restore/return value
.b02a					_EXTRKExit:
.b02a	fb		plz			plz
.b02b	09 00		ora #$00		ora 	#0 								; set Z
.b02d	60		rts			rts
.b02e					EXTReadScreen:
.b02e	5a		phy			phy 										; save Y
.b02f	8a		txa			txa 										; multiply XY by 2
.b030	85 04		sta $04			sta 	EXTZPWork							; into EXTZPWork
.b032	98		tya			tya
.b033	09 10		ora #$10		ora 	#EXTScreen>>8 						; move into screen area
.b035	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.b037	a0 00		ldy #$00		ldy 	#0
.b039	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b03b	7a		ply			ply 										; restore Y and exit.
.b03c	60		rts			rts
.b03d					EXTWriteScreen:
.b03d	5a		phy			phy
.b03e	48		pha			pha
.b03f	20 2e b0	jsr $b02e		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.b042	a0 00		ldy #$00		ldy 	#0
.b044	68		pla			pla 										; restore and write.
.b045	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b047	7a		ply			ply
.b048	60		rts			rts
.b049					EXTClearScreen:
.b049	48		pha			pha 										; save registers
.b04a	5a		phy			phy
.b04b	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set up pointer
.b04d	85 04		sta $04			sta 	EXTZPWork
.b04f	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b051	85 05		sta $05			sta 	EXTZPWork+1
.b053	a0 00		ldy #$00		ldy 	#0
.b055					_EXTCSLoop:
.b055	a9 20		lda #$20		lda 	#32
.b057	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b059	c8		iny			iny
.b05a	d0 f9		bne $b055		bne 	_EXTCSLoop
.b05c	e6 05		inc $05			inc 	EXTZPWork+1 						; next screen page
.b05e	a5 05		lda $05			lda 	EXTZPWork+1
.b060	c9 18		cmp #$18		cmp 	#(EXTScreen>>8)+8 					; done 2k ?
.b062	d0 f1		bne $b055		bne 	_EXTCSLoop
.b064	7a		ply			ply 										; restore
.b065	68		pla			pla
.b066	60		rts			rts
.b067					EXTScrollDisplay:
.b067	48		pha			pha 										; save registers
.b068	5a		phy			phy
.b069	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set pointer to screen
.b06b	85 04		sta $04			sta 	EXTZPWork+0
.b06d	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b06f	85 05		sta $05			sta 	EXTZPWork+1
.b071					_EXTScroll:
.b071	a0 28		ldy #$28		ldy 	#EXTWidth 							; x 2 because of two byte format.
.b073	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b075	a0 00		ldy #$00		ldy 	#0
.b077	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b079	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.b07b	d0 02		bne $b07f		bne 	_EXTNoCarry
.b07d	e6 05		inc $05			inc 	EXTZPWork+1
.b07f					_EXTNoCarry:
.b07f	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.b081	c9 c0		cmp #$c0		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) & $FF
.b083	d0 ec		bne $b071		bne 	_EXTScroll
.b085	a5 05		lda $05			lda 	EXTZPWork+1
.b087	c9 13		cmp #$13		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) >> 8
.b089	d0 e6		bne $b071		bne 	_EXTScroll
.b08b	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.b08d					_EXTLastLine:
.b08d	a9 20		lda #$20		lda 	#32
.b08f	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b091	c8		iny			iny
.b092	c0 28		cpy #$28		cpy 	#EXTWidth
.b094	d0 f7		bne $b08d		bne 	_EXTLastLine
.b096	7a		ply			ply 										; restore and exit.
.b097	68		pla			pla
.b098	60		rts			rts
.b099					EXTReset:
.b099	48		pha			pha 									; save registers
.b09a	da		phx			phx
.b09b	5a		phy			phy
.b09c	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to video system.
.b09e	85 07		sta $07			sta 	EXTZPWork+3
.b0a0	a9 fd		lda #$fd		lda 	#$FD
.b0a2	85 06		sta $06			sta 	EXTZPWork+2
.b0a4	a9 30		lda #$30		lda 	#$30
.b0a6	85 05		sta $05			sta 	EXTZPWork+1
.b0a8	a9 00		lda #$00		lda 	#$00
.b0aa	85 04		sta $04			sta 	EXTZPWork+0
.b0ac	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0ae	a9 47		lda #$47		lda 	#$47
.b0b0	ea		nop			nop
.b0b1	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0b3	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0b5	a9 53		lda #$53		lda 	#$53
.b0b7	ea		nop			nop
.b0b8	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0ba	a3 30		ldz #$30		ldz 	#$30 							; address already set up
.b0bc	a9 40		lda #$40		lda 	#$40
.b0be	ea		nop			nop
.b0bf	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0c1	a3 31		ldz #$31		ldz 	#$31 							; address already set up
.b0c3	a9 40		lda #$40		lda 	#$40
.b0c5	ea		nop			nop
.b0c6	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0c8	ad 31 d0	lda $d031		lda $d031	; VIC-III Control Register B
.b0cb	29 40		and #$40		and #$40	; bit-6 is 4mhz
.b0cd	8d 31 d0	sta $d031		sta $d031
.b0d0	a3 20		ldz #$20		ldz 	#$20 							; address already set up
.b0d2	a9 00		lda #$00		lda 	#0
.b0d4	ea		nop			nop
.b0d5	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0d7	a3 21		ldz #$21		ldz 	#$21 							; address already set up
.b0d9	a9 00		lda #$00		lda 	#0
.b0db	ea		nop			nop
.b0dc	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0de	a3 6f		ldz #$6f		ldz 	#$6F 							; address already set up
.b0e0	a9 80		lda #$80		lda 	#$80
.b0e2	ea		nop			nop
.b0e3	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0e5	ad 66 d0	lda $d066		lda $d066
.b0e8	29 7f		and #$7f		and #$7F
.b0ea	8d 66 d0	sta $d066		sta $d066
.b0ed	a3 6a		ldz #$6a		ldz 	#$6A 							; address already set up
.b0ef	a9 00		lda #$00		lda 	#$00
.b0f1	ea		nop			nop
.b0f2	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0f4	a3 6b		ldz #$6b		ldz 	#$6B 							; address already set up
.b0f6	a9 00		lda #$00		lda 	#$00
.b0f8	ea		nop			nop
.b0f9	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0fb	a3 78		ldz #$78		ldz 	#$78 							; address already set up
.b0fd	a9 00		lda #$00		lda 	#$00
.b0ff	ea		nop			nop
.b100	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b102	a3 5f		ldz #$5f		ldz 	#$5F 							; address already set up
.b104	a9 00		lda #$00		lda 	#$00
.b106	ea		nop			nop
.b107	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b109	a3 5a		ldz #$5a		ldz 	#$5A 							; address already set up
.b10b	a9 78		lda #$78		lda 	#$78
.b10d	ea		nop			nop
.b10e	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b110	a3 5d		ldz #$5d		ldz 	#$5D 							; address already set up
.b112	a9 c0		lda #$c0		lda 	#$C0
.b114	ea		nop			nop
.b115	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b117	a3 5c		ldz #$5c		ldz 	#$5C 							; address already set up
.b119	a9 50		lda #$50		lda 	#80
.b11b	ea		nop			nop
.b11c	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b11e	a9 ff		lda #$ff		lda #$ff
.b120	8d 01 dd	sta $dd01		sta $DD01
.b123	8d 00 dd	sta $dd00		sta $DD00
.b126	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b128	a9 14		lda #$14		lda 	#$14
.b12a	ea		nop			nop
.b12b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b12d	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b12f	a9 1b		lda #$1b		lda 	#$1B
.b131	ea		nop			nop
.b132	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b134	a3 16		ldz #$16		ldz 	#$16 							; address already set up
.b136	a9 c8		lda #$c8		lda 	#$C8
.b138	ea		nop			nop
.b139	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b13b	a3 c5		ldz #$c5		ldz 	#$C5 							; address already set up
.b13d	a9 54		lda #$54		lda 	#$54
.b13f	ea		nop			nop
.b140	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b142	a3 58		ldz #$58		ldz 	#$58 							; address already set up
.b144	a9 50		lda #$50		lda 	#80
.b146	ea		nop			nop
.b147	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b149	a3 59		ldz #$59		ldz 	#$59 							; address already set up
.b14b	a9 00		lda #$00		lda 	#0
.b14d	ea		nop			nop
.b14e	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b150	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b152	a9 42		lda #$42		lda 	#$42
.b154	ea		nop			nop
.b155	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b157	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b159	a9 1b		lda #$1b		lda 	#$1B
.b15b	ea		nop			nop
.b15c	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b15e	a9 00		lda #$00		lda 	#$00							; colour RAM at $1F800-1FFFF (2kb)
.b160	85 07		sta $07			sta 	EXTZPWork+3
.b162	a9 01		lda #$01		lda 	#$01
.b164	85 06		sta $06			sta 	EXTZPWork+2
.b166	a9 f8		lda #$f8		lda 	#$F8
.b168	85 05		sta $05			sta 	EXTZPWork+1
.b16a	a9 00		lda #$00		lda 	#$00
.b16c	85 04		sta $04			sta 	EXTZPWork+0
.b16e	a3 00		ldz #$00		ldz 	#0
.b170					_EXTClearColorRam:
.b170	a9 08		lda #$08		lda 	#8 								; fill that with this colour.
.b172	ea		nop			nop
.b173	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b175	3b		dez			dez
.b176	d0 f8		bne $b170		bne 	_EXTClearColorRam
.b178	e6 05		inc $05			inc 	EXTZPWork+1
.b17a	d0 f4		bne $b170		bne 	_EXTClearColorRam
.b17c	a2 00		ldx #$00		ldx 	#0 								; copy PET Font into memory.
.b17e					_EXTCopyCBMFont:
.b17e	bd 00 a0	lda $a000,x		lda 	EXTCBMFont,x
.b181	9d 00 08	sta $0800,x		sta 	EXTCharSet,x
.b184	bd 00 a1	lda $a100,x		lda 	EXTCBMFont+$100,x
.b187	9d 00 09	sta $0900,x		sta 	EXTCharSet+$100,x
.b18a	bd 00 a2	lda $a200,x		lda 	EXTCBMFont+$200,x
.b18d	9d 00 0a	sta $0a00,x		sta 	EXTCharSet+$200,x
.b190	bd 00 a3	lda $a300,x		lda 	EXTCBMFont+$300,x
.b193	9d 00 0b	sta $0b00,x		sta 	EXTCharSet+$300,x
.b196	ca		dex			dex
.b197	d0 e5		bne $b17e		bne 	_EXTCopyCBMFont
.b199	7a		ply			ply 									; restore and exit.
.b19a	fa		plx			plx
.b19b	68		pla			pla
.b19c	60		rts			rts

;******  Return to file: basic.asm


;******  Processing file: personalities/personality_io.asm

.b19d					IOInitialise:
.b19d	20 99 b0	jsr $b099			jsr 	EXTReset 					; reset display.
.b1a0	20 49 b0	jsr $b049			jsr 	EXTClearScreen 				; clear screen.
.b1a3	48		pha				pha
.b1a4	a9 00		lda #$00			lda 	#00 						; home cursor
.b1a6	85 08		sta $08				sta 	IOCursorX
.b1a8	85 09		sta $09				sta 	IOCursorY
.b1aa	68		pla				pla
.b1ab	60		rts				rts
.b1ac					IOPrintChar:
.b1ac	48		pha				pha 								; save registers
.b1ad	da		phx				phx
.b1ae	5a		phy				phy
.b1af	29 7f		and #$7f			and 	#$7F 						; bits 0-6 only
.b1b1	20 ff b1	jsr $b1ff			jsr 	IOUpperCase 				; convert to upper case.
.b1b4	c9 0d		cmp #$0d			cmp 	#13 						; new line ?
.b1b6	f0 16		beq $b1ce			beq 	_IOPCNewLine
.b1b8	c9 20		cmp #$20			cmp 	#32 						; not printable.
.b1ba	90 23		bcc $b1df			bcc 	_IOPCExit
.b1bc	48		pha				pha 								; print at cursor
.b1bd	20 0b b2	jsr $b20b			jsr 	IOGetCursorXY
.b1c0	68		pla				pla
.b1c1	29 3f		and #$3f			and 	#$3F 						; 6 Bit ASCII
.b1c3	20 3d b0	jsr $b03d			jsr 	EXTWriteScreen
.b1c6	e6 08		inc $08				inc 	IOCursorX 					; move left.
.b1c8	a5 08		lda $08				lda 	IOCursorX
.b1ca	c9 28		cmp #$28			cmp		#EXTWidth 					; will be zero if at RHS
.b1cc	d0 11		bne $b1df			bne 	_IOPCExit 					; exit otherwise
.b1ce					_IOPCNewLine:
.b1ce	a9 00		lda #$00			lda 	#0 							; go down and to lhs
.b1d0	85 08		sta $08				sta 	IOCursorX
.b1d2	e6 09		inc $09				inc 	IOCursorY
.b1d4	a5 09		lda $09				lda 	IOCursorY 					; off bottom
.b1d6	c9 19		cmp #$19			cmp 	#EXTHeight
.b1d8	90 05		bcc $b1df			bcc 	_IOPCExit
.b1da	20 67 b0	jsr $b067			jsr 	EXTScrollDisplay 			; scroll
.b1dd	c6 09		dec $09				dec 	IOCursorY 					; fix up.
.b1df					_IOPCExit:
.b1df	7a		ply				ply
.b1e0	fa		plx				plx
.b1e1	68		pla				pla
.b1e2	60		rts				rts
.b1e3					IOReadKey:
.b1e3	da		phx				phx 								; save XY
.b1e4	5a		phy				phy
.b1e5	20 0b b2	jsr $b20b			jsr 	IOGetCursorXY 				; show prompt
.b1e8	a9 1d		lda #$1d			lda 	#$1D
.b1ea	20 3d b0	jsr $b03d			jsr  	EXTWriteScreen
.b1ed					_IORKWait:
.b1ed	20 0c b0	jsr $b00c			jsr 	EXTReadKey
.b1f0	f0 fb		beq $b1ed			beq 	_IORKWait
.b1f2	48		pha				pha 								; clear prompt
.b1f3	20 0b b2	jsr $b20b			jsr 	IOGetCursorXY
.b1f6	a9 20		lda #$20			lda 	#" "
.b1f8	20 3d b0	jsr $b03d			jsr  	EXTWriteScreen
.b1fb	68		pla				pla
.b1fc	7a		ply				ply 								; restore and exit.
.b1fd	fa		plx				plx
.b1fe	60		rts				rts
.b1ff					IOUpperCase:
.b1ff	c9 61		cmp #$61			cmp 	#"a"
.b201	90 07		bcc $b20a			bcc 	_IOUCExit
.b203	c9 7b		cmp #$7b			cmp 	#"z"+1
.b205	b0 03		bcs $b20a			bcs 	_IOUCExit
.b207	38		sec				sec
.b208	e9 20		sbc #$20			sbc 	#32
.b20a					_IOUCExit:
.b20a	60		rts				rts
.b20b					IOGetCursorXY:
.b20b	48		pha				pha
.b20c	a5 09		lda $09				lda 	IOCursorY 					; multiply IOCursorY x 5
.b20e	0a		asl a				asl		a
.b20f	0a		asl a				asl		a 							; x 4, carry clear
.b210	65 09		adc $09				adc 	IOCursorY 					; so this will be 0..199 now
.b212	aa		tax				tax
.b213	8a		txa				txa 								; x 10
.b214	0a		asl a				asl 	a
.b215	aa		tax				tax
.b216	a9 00		lda #$00			lda 	#0
.b218	2a		rol a				rol 	a
.b219	a8		tay				tay
.b21a	8a		txa				txa 								; x 20
.b21b	0a		asl a				asl 	a
.b21c	aa		tax				tax
.b21d	98		tya				tya
.b21e	2a		rol a				rol 	a
.b21f	a8		tay				tay
.b220	8a		txa				txa 								; x 40
.b221	0a		asl a				asl 	a
.b222	aa		tax				tax
.b223	98		tya				tya
.b224	2a		rol a				rol 	a
.b225	a8		tay				tay
.b226	8a		txa				txa 								; add X to that.
.b227	18		clc				clc
.b228	65 08		adc $08				adc 	IOCursorX
.b22a	aa		tax				tax
.b22b	90 01		bcc $b22e			bcc 	_IOGCXYExit
.b22d	c8		iny				iny
.b22e					_IOGCXYExit:
.b22e	68		pla				pla
.b22f	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	09 e6					.word	SyntaxError                   ; "!"        ($0080)
>e002	09 e6					.word	SyntaxError                   ; """        ($0081)
>e004	09 e6					.word	SyntaxError                   ; "#"        ($0082)
>e006	09 e6					.word	SyntaxError                   ; "$"        ($0083)
>e008	ec e3					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	5f e2					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	09 e6					.word	SyntaxError                   ; "'"        ($0086)
>e00e	09 e6					.word	SyntaxError                   ; "("        ($0087)
>e010	09 e6					.word	SyntaxError                   ; ")"        ($0088)
>e012	ce e2					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	13 e2					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	39 e2					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	25 e3					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	09 e6					.word	SyntaxError                   ; ":"        ($008d)
>e01c	09 e6					.word	SyntaxError                   ; ";"        ($008e)
>e01e	6a e4					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	0b e4					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	45 e4					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	08 e4					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	48 e4					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	67 e4					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	09 e6					.word	SyntaxError                   ; "?"        ($0095)
>e02c	a9 e2					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	09 e6					.word	SyntaxError                   ; "assert"   ($0097)
>e030	09 e6					.word	SyntaxError                   ; "abs"      ($0098)
>e032	09 e6					.word	SyntaxError                   ; "clear"    ($0099)
>e034	09 e6					.word	SyntaxError                   ; "ch"       ($009a)
>e036	09 e6					.word	SyntaxError                   ; "do"       ($009b)
>e038	09 e6					.word	SyntaxError                   ; "else"     ($009c)
>e03a	09 e6					.word	SyntaxError                   ; "end"      ($009d)
>e03c	09 e6					.word	SyntaxError                   ; "for"      ($009e)
>e03e	09 e6					.word	SyntaxError                   ; "gosub"    ($009f)
>e040	09 e6					.word	SyntaxError                   ; "goto"     ($00a0)
>e042	09 e6					.word	SyntaxError                   ; "input"    ($00a1)
>e044	09 e6					.word	SyntaxError                   ; "if"       ($00a2)
>e046	09 e6					.word	SyntaxError                   ; "local"    ($00a3)
>e048	09 e6					.word	SyntaxError                   ; "list"     ($00a4)
>e04a	09 e6					.word	SyntaxError                   ; "loop"     ($00a5)
>e04c	09 e6					.word	SyntaxError                   ; "link"     ($00a6)
>e04e	09 e6					.word	SyntaxError                   ; "let"      ($00a7)
>e050	09 e6					.word	SyntaxError                   ; "len"      ($00a8)
>e052	09 e6					.word	SyntaxError                   ; "next"     ($00a9)
>e054	09 e6					.word	SyntaxError                   ; "new"      ($00aa)
>e056	09 e6					.word	SyntaxError                   ; "old"      ($00ab)
>e058	09 e6					.word	SyntaxError                   ; "print"    ($00ac)
>e05a	09 e6					.word	SyntaxError                   ; "rem"      ($00ad)
>e05c	09 e6					.word	SyntaxError                   ; "rnd"      ($00ae)
>e05e	09 e6					.word	SyntaxError                   ; "stop"     ($00af)
>e060	09 e6					.word	SyntaxError                   ; "step"     ($00b0)
>e062	09 e6					.word	SyntaxError                   ; "then"     ($00b1)
>e064	09 e6					.word	SyntaxError                   ; "top"      ($00b2)
>e066	09 e6					.word	SyntaxError                   ; "to"       ($00b3)
>e068	84 e2					.word	BFUNC_Or                      ; "|"        ($00b4)
>e06a	89 e4					.word	BFUNC_StringCompare           ; "~"        ($00b5)
.e06c					TokenText:
>e06c	a1					.byte $a1                             ; $0080 !
>e06d	a2					.byte $a2                             ; $0081 "
>e06e	a3					.byte $a3                             ; $0082 #
>e06f	a4					.byte $a4                             ; $0083 $
>e070	a5					.byte $a5                             ; $0084 %
>e071	a6					.byte $a6                             ; $0085 &
>e072	a7					.byte $a7                             ; $0086 '
>e073	a8					.byte $a8                             ; $0087 (
>e074	a9					.byte $a9                             ; $0088 )
>e075	aa					.byte $aa                             ; $0089 *
>e076	ab					.byte $ab                             ; $008a +
>e077	ad					.byte $ad                             ; $008b -
>e078	af					.byte $af                             ; $008c /
>e079	ba					.byte $ba                             ; $008d :
>e07a	bb					.byte $bb                             ; $008e ;
>e07b	3c bd					.byte $3c,$bd                         ; $008f <=
>e07d	3c be					.byte $3c,$be                         ; $0090 <>
>e07f	bc					.byte $bc                             ; $0091 <
>e080	bd					.byte $bd                             ; $0092 =
>e081	3e bd					.byte $3e,$bd                         ; $0093 >=
>e083	be					.byte $be                             ; $0094 >
>e084	bf					.byte $bf                             ; $0095 ?
>e085	de					.byte $de                             ; $0096 ^
>e086	61 73 73 65 72 f4			.byte $61,$73,$73,$65,$72,$f4         ; $0097 assert
>e08c	61 62 f3				.byte $61,$62,$f3                     ; $0098 abs
>e08f	63 6c 65 61 f2				.byte $63,$6c,$65,$61,$f2             ; $0099 clear
>e094	63 e8					.byte $63,$e8                         ; $009a ch
>e096	64 ef					.byte $64,$ef                         ; $009b do
>e098	65 6c 73 e5				.byte $65,$6c,$73,$e5                 ; $009c else
>e09c	65 6e e4				.byte $65,$6e,$e4                     ; $009d end
>e09f	66 6f f2				.byte $66,$6f,$f2                     ; $009e for
>e0a2	67 6f 73 75 e2				.byte $67,$6f,$73,$75,$e2             ; $009f gosub
>e0a7	67 6f 74 ef				.byte $67,$6f,$74,$ef                 ; $00a0 goto
>e0ab	69 6e 70 75 f4				.byte $69,$6e,$70,$75,$f4             ; $00a1 input
>e0b0	69 e6					.byte $69,$e6                         ; $00a2 if
>e0b2	6c 6f 63 61 ec				.byte $6c,$6f,$63,$61,$ec             ; $00a3 local
>e0b7	6c 69 73 f4				.byte $6c,$69,$73,$f4                 ; $00a4 list
>e0bb	6c 6f 6f f0				.byte $6c,$6f,$6f,$f0                 ; $00a5 loop
>e0bf	6c 69 6e eb				.byte $6c,$69,$6e,$eb                 ; $00a6 link
>e0c3	6c 65 f4				.byte $6c,$65,$f4                     ; $00a7 let
>e0c6	6c 65 ee				.byte $6c,$65,$ee                     ; $00a8 len
>e0c9	6e 65 78 f4				.byte $6e,$65,$78,$f4                 ; $00a9 next
>e0cd	6e 65 f7				.byte $6e,$65,$f7                     ; $00aa new
>e0d0	6f 6c e4				.byte $6f,$6c,$e4                     ; $00ab old
>e0d3	70 72 69 6e f4				.byte $70,$72,$69,$6e,$f4             ; $00ac print
>e0d8	72 65 ed				.byte $72,$65,$ed                     ; $00ad rem
>e0db	72 6e e4				.byte $72,$6e,$e4                     ; $00ae rnd
>e0de	73 74 6f f0				.byte $73,$74,$6f,$f0                 ; $00af stop
>e0e2	73 74 65 f0				.byte $73,$74,$65,$f0                 ; $00b0 step
>e0e6	74 68 65 ee				.byte $74,$68,$65,$ee                 ; $00b1 then
>e0ea	74 6f f0				.byte $74,$6f,$f0                     ; $00b2 top
>e0ed	74 ef					.byte $74,$ef                         ; $00b3 to
>e0ef	fc					.byte $fc                             ; $00b4 |
>e0f0	fe					.byte $fe                             ; $00b5 ~
>e0f1	00					.byte $00
.e0f2					TokenTypeInformation:
>e0f2	04					.byte $04                             ; $0080 !
>e0f3	0a					.byte $0a                             ; $0081 "
>e0f4	0a					.byte $0a                             ; $0082 #
>e0f5	04					.byte $04                             ; $0083 $
>e0f6	03					.byte $03                             ; $0084 %
>e0f7	00					.byte $00                             ; $0085 &
>e0f8	0a					.byte $0a                             ; $0086 '
>e0f9	0a					.byte $0a                             ; $0087 (
>e0fa	0a					.byte $0a                             ; $0088 )
>e0fb	03					.byte $03                             ; $0089 *
>e0fc	02					.byte $02                             ; $008a +
>e0fd	02					.byte $02                             ; $008b -
>e0fe	03					.byte $03                             ; $008c /
>e0ff	0a					.byte $0a                             ; $008d :
>e100	0a					.byte $0a                             ; $008e ;
>e101	01					.byte $01                             ; $008f <=
>e102	01					.byte $01                             ; $0090 <>
>e103	01					.byte $01                             ; $0091 <
>e104	01					.byte $01                             ; $0092 =
>e105	01					.byte $01                             ; $0093 >=
>e106	01					.byte $01                             ; $0094 >
>e107	04					.byte $04                             ; $0095 ?
>e108	00					.byte $00                             ; $0096 ^
>e109	04					.byte $04                             ; $0097 assert
>e10a	09					.byte $09                             ; $0098 abs
>e10b	04					.byte $04                             ; $0099 clear
>e10c	09					.byte $09                             ; $009a ch
>e10d	04					.byte $04                             ; $009b do
>e10e	04					.byte $04                             ; $009c else
>e10f	04					.byte $04                             ; $009d end
>e110	04					.byte $04                             ; $009e for
>e111	04					.byte $04                             ; $009f gosub
>e112	04					.byte $04                             ; $00a0 goto
>e113	04					.byte $04                             ; $00a1 input
>e114	04					.byte $04                             ; $00a2 if
>e115	04					.byte $04                             ; $00a3 local
>e116	04					.byte $04                             ; $00a4 list
>e117	04					.byte $04                             ; $00a5 loop
>e118	04					.byte $04                             ; $00a6 link
>e119	04					.byte $04                             ; $00a7 let
>e11a	09					.byte $09                             ; $00a8 len
>e11b	04					.byte $04                             ; $00a9 next
>e11c	04					.byte $04                             ; $00aa new
>e11d	04					.byte $04                             ; $00ab old
>e11e	04					.byte $04                             ; $00ac print
>e11f	04					.byte $04                             ; $00ad rem
>e120	09					.byte $09                             ; $00ae rnd
>e121	04					.byte $04                             ; $00af stop
>e122	04					.byte $04                             ; $00b0 step
>e123	04					.byte $04                             ; $00b1 then
>e124	09					.byte $09                             ; $00b2 top
>e125	04					.byte $04                             ; $00b3 to
>e126	00					.byte $00                             ; $00b4 |
>e127	01					.byte $01                             ; $00b5 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CH = $009a
=$009b					KW_DO = $009b
=$009c					KW_ELSE = $009c
=$009d					KW_END = $009d
=$009e					KW_FOR = $009e
=$009f					KW_GOSUB = $009f
=$00a0					KW_GOTO = $00a0
=$00a1					KW_INPUT = $00a1
=$00a2					KW_IF = $00a2
=$00a3					KW_LOCAL = $00a3
=$00a4					KW_LIST = $00a4
=$00a5					KW_LOOP = $00a5
=$00a6					KW_LINK = $00a6
=$00a7					KW_LET = $00a7
=$00a8					KW_LEN = $00a8
=$00a9					KW_NEXT = $00a9
=$00aa					KW_NEW = $00aa
=$00ab					KW_OLD = $00ab
=$00ac					KW_PRINT = $00ac
=$00ad					KW_REM = $00ad
=$00ae					KW_RND = $00ae
=$00af					KW_STOP = $00af
=$00b0					KW_STEP = $00b0
=$00b1					KW_THEN = $00b1
=$00b2					KW_TOP = $00b2
=$00b3					KW_TO = $00b3
=$00b4					KW_BAR = $00b4
=$00b5					KW_TILDE = $00b5

;******  Return to file: basic.asm


;******  Processing file: general/support.asm


;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e128							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zBasicStack:	.word 	? 					; stack for BASIC.
>0024					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0026					zTemp1:			.word 	?					; temporary vars
>0028					zTemp2:			.word 	?
>2000					FixedVariables:	.fill 	26*4 				; address of 26 x 4 byte fixed variables A-Z
=8					HashTableSize = 8 							; number of entries, must be a power of 2.
>2068					HashTable:		.fill	HashTableSize*2		; hash table for variable linked lists.
>2078					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>207a					Temp1:			.dword	?					; 4 byte temporary stores.
>207e					SignCount:		.byte 	? 					; count of signs in divide.
>207f									.align	256
.2100					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e128					EvaluateSNError:
.e128	4c 09 e6	jmp $e609			jmp 	SyntaxError
.e12b					EvaluateBase:
.e12b	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e12d					EvaluateBaseCurrentLevel:
.e12d	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e12f					EvaluateAtPrecedenceLevel:
.e12f	48		pha				pha 								; save precedence level
.e130	a9 00		lda #$00			lda 	#0 							; zero the top two bytes of the result
.e132	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e135	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e138	c8		iny				iny 								; get high byte of next token
.e139	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e13b	88		dey				dey
.e13c	c9 00		cmp #$00			cmp 	#0 							; is it $00 (end or string)
.e13e	f0 05		beq $e145			beq 	_EVALString
.e140	10 1e		bpl $e160			bpl 	_EVALNotString 				; if +ve it is a keyword or a constant
.e142	4c 11 e2	jmp $e211			jmp 	_EVALVariable 				; if -ve it is a variable.
.e145					_EVALString:
.e145	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the length.
.e147	f0 df		beq $e128			beq 	EvaluateSNError 			; if zero, that's an error.
.e149	18		clc				clc 								; copy currentline + Y + 2
.e14a	98		tya				tya 								; as the low bytes of the result
.e14b	69 02		adc #$02			adc 	#2
.e14d	65 20		adc $20				adc 	zCurrentLine
.e14f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e152	a5 21		lda $21				lda 	zCurrentLine+1
.e154	69 00		adc #$00			adc 	#0
.e156	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e159	98		tya				tya 								; work out offset for next.
.e15a	18		clc				clc
.e15b	71 20		adc ($20),y			adc 	(zCurrentLine),y
.e15d	a8		tay				tay
.e15e	80 5a		bra $e1ba			bra 	_EVALGotAtom 				; got the atom.
.e160					_EVALNotString:
.e160	c9 40		cmp #$40			cmp 	#$40 	 					; if $4000-$7FFF this is a constant.
.e162	b0 03		bcs $e167			bcs 	_EVALConstant
.e164	4c 0f e2	jmp $e20f			jmp	 	_EVALKeyword				; keyword, which means unary function or operator.
.e167					_EVALConstant:
.e167	29 3f		and #$3f			and 	#$3F 						; only interested in upper 6 bits (14 of word)
.e169	9d 01 04	sta $0401,x			sta 	evalStack+1,x 				; the msb
.e16c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the lsb and copy it
.e16e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e171	c8		iny				iny									; advance to next
.e172	c8		iny				iny
.e173					_EVALIntegerNext:
.e173	c8		iny				iny 								; get the MSB of the next token.
.e174	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e176	88		dey				dey
.e177	29 c0		and #$c0			and 	#$C0 						; $4000-$7FFF is 01xx xxxx
.e179	c9 40		cmp #$40			cmp 	#$40
.e17b	d0 3d		bne $e1ba			bne		_EVALGotAtom
.e17d	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; effectively, shift left 16.
.e180	9d 04 04	sta $0404,x			sta 	evalStack+4,x
.e183	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e186	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e189	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e18c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e18f	a9 00		lda #$00			lda 	#0
.e191	9d 01 04	sta $0401,x			sta 	evalStack+1,x 				; don't worry about +0, it is overwritten.
.e194	5a		phy				phy 								; rotate it right twice.
.e195	a0 02		ldy #$02			ldy 	#2
.e197					_EVALRotate:
.e197	5e 04 04	lsr $0404,x			lsr 	evalStack+4,x
.e19a	7e 03 04	ror $0403,x			ror 	evalStack+3,x
.e19d	7e 02 04	ror $0402,x			ror 	evalStack+2,x
.e1a0	7e 01 04	ror $0401,x			ror 	evalStack+1,x
.e1a3	88		dey				dey
.e1a4	d0 f1		bne $e197			bne 	_EVALRotate
.e1a6	7a		ply				ply
.e1a7	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; put the new word in.
.e1a9	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1ac	c8		iny				iny
.e1ad	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e1af	29 3f		and #$3f			and 	#$3F 						; 14 bits of word.
.e1b1	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e1b4	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1b7	c8		iny				iny
.e1b8	80 b9		bra $e173			bra 	_EVALIntegerNext 			; and check yet again.
.e1ba					_EVALGotAtom:
.e1ba	c8		iny				iny 								; get the MSB of the token
.e1bb	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; 001t tttk - we want 0010 xxxx
.e1bd	29 f0		and #$f0			and 	#$F0 						; for it to be a binary operator.
.e1bf	c9 20		cmp #$20			cmp 	#$20
.e1c1	d0 49		bne $e20c			bne 	_EVALExitDecY 				; not a binary operator, so exit, unpicking the INY.
.e1c3	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token again
.e1c5	29 0e		and #$0e			and 	#$0E 						; mask out the precedence bits
.e1c7	4a		lsr a				lsr 	a 							; now in bits 0,1,2
.e1c8	8d 7a 20	sta $207a			sta 	Temp1 						; save it.
.e1cb	68		pla				pla 								; get current precedence level
.e1cc	48		pha				pha 								; push it back again.
.e1cd	cd 7a 20	cmp $207a			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e1d0	f0 02		beq $e1d4			beq 	_EVALDoCalc					; equal, do it.
.e1d2	b0 38		bcs $e20c			bcs 	_EVALExitDecY				; too high, then exit.
.e1d4					_EVALDoCalc:
.e1d4	88		dey				dey
.e1d5	b1 20		lda ($20),y			lda 	(ZCurrentLine),y 			; low byte of operator.
.e1d7	48		pha				pha
.e1d8	c8		iny				iny
.e1d9	b1 20		lda ($20),y			lda 	(ZCurrentLine),y 			; high byte of operator
.e1db	48		pha				pha
.e1dc	c8		iny				iny 								; now points to next.
.e1dd	da		phx				phx
.e1de	e8		inx				inx 								; work out right hand side.
.e1df	e8		inx				inx
.e1e0	e8		inx				inx
.e1e1	e8		inx				inx
.e1e2	ad 7a 20	lda $207a			lda 	Temp1 						; get current operator precedence level.
.e1e5	1a		inc a				inc 	a 							; so work it out at the next level.
.e1e6	20 2f e1	jsr $e12f			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e1e9	fa		plx				plx 								; fix X back.
.e1ea	68		pla				pla 								; get keyword MSB ack
.e1eb	29 01		and #$01			and 	#1 							; ID bit
.e1ed	8d 7c 20	sta $207c			sta 	Temp1+2 					; save in Temp1.2
.e1f0	68		pla				pla 	 							; get LSB
.e1f1	0a		asl a				asl 	a 							; double it
.e1f2	2e 7c 20	rol $207c			rol 	Temp1+2 					; shift carry out from ASL into upper byte.
.e1f5	69 fe		adc #$fe			adc 	#(KeywordVectorTable-2) & $FF
.e1f7	8d 7b 20	sta $207b			sta 	Temp1+1
.e1fa	ad 7c 20	lda $207c			lda 	Temp1+2
.e1fd	69 df		adc #$df			adc 	#(KeywordVectorTable-2) >> 8
.e1ff	8d 7c 20	sta $207c			sta 	Temp1+2						; save in Temp1.1, which now has the indirect address
.e202	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e204	8d 7a 20	sta $207a			sta 	Temp1+0
.e207	20 7a 20	jsr $207a			jsr 	Temp1 						; call that routine.
.e20a	80 ae		bra $e1ba			bra 	_EVALGotAtom 				; and loop back again.
.e20c					_EVALExitDecY:
.e20c	88		dey				dey
.e20d	68		pla				pla 								; restore precedence.
.e20e					_EVALExit:
.e20e	60		rts				rts
.e20f					_EVALKeyword:
.e20f	80 fe		bra $e20f			bra 	_EVALKeyword
.e211					_EVALVariable:
.e211	80 fe		bra $e211			bra 	_EVALVariable

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e213					BFUNC_Add:
.e213	18		clc				clc
.e214	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e217	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e21a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e21d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e220	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e223	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e226	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e229	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e22c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e22f	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e232	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e235	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e238	60		rts				rts
.e239					BFUNC_Subtract:
.e239	38		sec				sec
.e23a	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e23d	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e240	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e243	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e246	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e249	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e24c	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e24f	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e252	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e255	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e258	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e25b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e25e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e25f					BFUNC_And:
.e25f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e262	3d 04 04	and $0404,x			and 	evalStack+4,x
.e265	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e268	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e26b	3d 05 04	and $0405,x			and 	evalStack+5,x
.e26e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e271	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e274	3d 06 04	and $0406,x			and 	evalStack+6,x
.e277	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e27a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e27d	3d 07 04	and $0407,x			and 	evalStack+7,x
.e280	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e283	60		rts				rts
.e284					BFUNC_Or:
.e284	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e287	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e28a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e28d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e290	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e293	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e296	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e299	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e29c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e29f	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e2a2	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e2a5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e2a8	60		rts				rts
.e2a9					BFUNC_Xor:
.e2a9	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e2ac	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e2af	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e2b2	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e2b5	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e2b8	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e2bb	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e2be	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e2c1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e2c4	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e2c7	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e2ca	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e2cd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e2ce					BFUNC_Multiply:
.e2ce	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e2d1	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e2d4	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e2d7	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e2da	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e2dd	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e2e0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e2e3	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e2e6	a9 00		lda #$00			lda 	#0
.e2e8	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e2eb	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e2ee	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e2f1	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e2f4					_BFMMultiply:
.e2f4	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e2f7	29 01		and #$01			and 	#1
.e2f9	f0 03		beq $e2fe			beq 	_BFMNoAdd
.e2fb	20 13 e2	jsr $e213			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e2fe					_BFMNoAdd:
.e2fe	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e301	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e304	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e307	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e30a	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e30d	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e310	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e313	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e316	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e319	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e31c	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e31f	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e322	d0 d0		bne $e2f4			bne 	_BFMMultiply
.e324	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e325					BFUNC_Divide:
.e325	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e328	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e32b	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e32e	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e331	d0 13		bne $e346			bne 	_BFDOkay
.e333	20 0e e6	jsr $e60e			jsr 	ReportError
>e336	44 69 76 69 73 6f 6e 20				.text 	"Divison by Zero",$00
>e33e	62 79 20 5a 65 72 6f 00
.e346					_BFDOkay:
.e346	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e348	8d 7a 20	sta $207a			sta 	Temp1 						; Q/Dividend/Left in +0
.e34b	8d 7b 20	sta $207b			sta 	Temp1+1 					; M/Divisor/Right in +4
.e34e	8d 7c 20	sta $207c			sta 	Temp1+2
.e351	8d 7d 20	sta $207d			sta 	Temp1+3
.e354	8d 7e 20	sta $207e			sta 	SignCount 					; Count of signs.
.e357	20 c2 e3	jsr $e3c2			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e35a	da		phx				phx
.e35b	e8		inx				inx
.e35c	e8		inx				inx
.e35d	e8		inx				inx
.e35e	e8		inx				inx
.e35f	20 c2 e3	jsr $e3c2			jsr 	BFUNC_Negate
.e362	fa		plx				plx
.e363	5a		phy				phy 								; Y is the counter
.e364	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e366					_BFDLoop:
.e366	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e369	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e36c	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e36f	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e372	2e 7a 20	rol $207a			rol 	Temp1
.e375	2e 7b 20	rol $207b			rol 	Temp1+1
.e378	2e 7c 20	rol $207c			rol 	Temp1+2
.e37b	2e 7d 20	rol $207d			rol 	Temp1+3
.e37e	38		sec				sec
.e37f	ad 7a 20	lda $207a			lda 	Temp1+0 					; Calculate A-M on stack.
.e382	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e385	48		pha				pha
.e386	ad 7b 20	lda $207b			lda 	Temp1+1
.e389	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e38c	48		pha				pha
.e38d	ad 7c 20	lda $207c			lda 	Temp1+2
.e390	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e393	48		pha				pha
.e394	ad 7d 20	lda $207d			lda 	Temp1+3
.e397	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e39a	90 19		bcc $e3b5			bcc 	_BFDNoAdd
.e39c	8d 7d 20	sta $207d			sta 	Temp1+3 					; update A
.e39f	68		pla				pla
.e3a0	8d 7c 20	sta $207c			sta 	Temp1+2
.e3a3	68		pla				pla
.e3a4	8d 7b 20	sta $207b			sta 	Temp1+1
.e3a7	68		pla				pla
.e3a8	8d 7a 20	sta $207a			sta 	Temp1+0
.e3ab	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.e3ae	09 01		ora #$01			ora 	#1
.e3b0	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3b3	80 03		bra $e3b8			bra 	_BFDNext
.e3b5					_BFDNoAdd:
.e3b5	68		pla				pla 								; Throw away the intermediate calculations
.e3b6	68		pla				pla
.e3b7	68		pla				pla
.e3b8					_BFDNext:
.e3b8	88		dey				dey
.e3b9	d0 ab		bne $e366			bne 	_BFDLoop
.e3bb	7a		ply				ply 								; restore Y and exit
.e3bc	4e 7e 20	lsr $207e			lsr 	SignCount 					; if sign count odd,
.e3bf	b0 06		bcs $e3c7			bcs		BFUNC_NegateAlways 			; negate the result
.e3c1	60		rts				rts
.e3c2					BFUNC_Negate:
.e3c2	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3c5	10 24		bpl $e3eb			bpl 	BFNExit
.e3c7					BFUNC_NegateAlways:
.e3c7	38		sec				sec
.e3c8	a9 00		lda #$00			lda 	#0
.e3ca	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.e3cd	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3d0	a9 00		lda #$00			lda 	#0
.e3d2	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.e3d5	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3d8	a9 00		lda #$00			lda 	#0
.e3da	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.e3dd	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3e0	a9 00		lda #$00			lda 	#0
.e3e2	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.e3e5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3e8	ee 7e 20	inc $207e			inc 	SignCount
.e3eb					BFNExit:
.e3eb	60		rts				rts
.e3ec					BFUNC_Modulus:
.e3ec	20 25 e3	jsr $e325			jsr 	BFUNC_Divide 				; start with division.
.e3ef	ad 7a 20	lda $207a			lda 	Temp1+0 					; copy remainder
.e3f2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3f5	ad 7b 20	lda $207b			lda 	Temp1+1
.e3f8	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3fb	ad 7c 20	lda $207c			lda 	Temp1+2
.e3fe	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e401	ad 7d 20	lda $207d			lda 	Temp1+3
.e404	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e407	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e408					BFUNC_Equals:
.e408	18		clc				clc
.e409	80 01		bra $e40c			bra 	BFUNC_EqualCheck
.e40b					BFUNC_NotEquals:
.e40b	38		sec				sec
.e40c					BFUNC_EqualCheck:
.e40c	08		php				php									; save invert flag
.e40d	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e410	cd 04 04	cmp $0404			cmp 	evalStack+4
.e413	d0 1c		bne $e431			bne 	COMP_Fail
.e415	ad 01 04	lda $0401			lda 	evalStack+1
.e418	cd 05 04	cmp $0405			cmp 	evalStack+5
.e41b	d0 14		bne $e431			bne 	COMP_Fail
.e41d	ad 02 04	lda $0402			lda 	evalStack+2
.e420	cd 06 04	cmp $0406			cmp 	evalStack+6
.e423	d0 0c		bne $e431			bne 	COMP_Fail
.e425	ad 03 04	lda $0403			lda 	evalStack+3
.e428	cd 07 04	cmp $0407			cmp 	evalStack+7
.e42b	d0 04		bne $e431			bne 	COMP_Fail
.e42d					COMP_Succeed:
.e42d	a9 ff		lda #$ff			lda 	#$FF
.e42f	80 02		bra $e433			bra 	COMP_SetResult
.e431					COMP_Fail:
.e431	a9 00		lda #$00			lda 	#0 							; here return 0
.e433					COMP_SetResult:
.e433	28		plp				plp 								; but if CS
.e434	90 02		bcc $e438			bcc 	COMP_Accept
.e436	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e438					COMP_Accept:
.e438	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e43b	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e43e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e441	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e444	60		rts				rts
.e445					BFUNC_Less:
.e445	18		clc				clc
.e446	80 01		bra $e449			bra 	BFUNC_LessCheck
.e448					BFUNC_GreaterEqual:
.e448	38		sec				sec
.e449					BFUNC_LessCheck:
.e449	08		php				php
.e44a	38		sec				sec
.e44b	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e44e	ed 04 04	sbc $0404			sbc 	evalStack+4
.e451	ad 01 04	lda $0401			lda 	evalStack+1
.e454	ed 05 04	sbc $0405			sbc 	evalStack+5
.e457	ad 02 04	lda $0402			lda 	evalStack+2
.e45a	ed 06 04	sbc $0406			sbc 	evalStack+6
.e45d	ad 03 04	lda $0403			lda 	evalStack+3
.e460	ed 07 04	sbc $0407			sbc 	evalStack+7
.e463	30 c8		bmi $e42d			bmi 	COMP_Succeed
.e465	80 ca		bra $e431			bra 	COMP_Fail
.e467					BFUNC_Greater:
.e467	18		clc				clc
.e468	80 01		bra $e46b			bra 	BFUNC_GreaterCheck
.e46a					BFUNC_LessEqual:
.e46a	38		sec				sec
.e46b					BFUNC_GreaterCheck:
.e46b	08		php				php
.e46c	38		sec				sec
.e46d	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.e470	ed 00 04	sbc $0400			sbc 	evalStack+0
.e473	ad 05 04	lda $0405			lda 	evalStack+5
.e476	ed 01 04	sbc $0401			sbc 	evalStack+1
.e479	ad 06 04	lda $0406			lda 	evalStack+6
.e47c	ed 02 04	sbc $0402			sbc 	evalStack+2
.e47f	ad 07 04	lda $0407			lda 	evalStack+7
.e482	ed 03 04	sbc $0403			sbc 	evalStack+3
.e485	30 a6		bmi $e42d			bmi 	COMP_Succeed
.e487	80 a8		bra $e431			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.e489					BFUNC_StringCompare:
.e489	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.e48c	85 26		sta $26				sta 	zTemp1
.e48e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e491	85 27		sta $27				sta 	zTemp1+1
.e493	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.e496	85 28		sta $28				sta 	zTemp2
.e498	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.e49b	85 29		sta $29				sta 	zTemp2+1
.e49d	a0 00		ldy #$00			ldy 	#0
.e49f					_BFSCLoop:
.e49f	b1 26		lda ($26),y			lda 	(zTemp1),y 					; comparison
.e4a1	38		sec				sec
.e4a2	d1 28		cmp ($28),y			cmp 	(zTemp2),y
.e4a4	d0 14		bne $e4ba			bne		_BFSCDifferent 				; return different result.
.e4a6	c8		iny				iny
.e4a7	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.e4a9	d0 f4		bne $e49f			bne 	_BFSCLoop
.e4ab	a9 00		lda #$00			lda 	#0
.e4ad					_BFSCSetAll:
.e4ad	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e4b0	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e4b3	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e4b6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e4b9	60		rts				rts
.e4ba					_BFSCDifferent:
.e4ba	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.e4bc	90 ef		bcc $e4ad			bcc 	_BFSCSetAll
.e4be	a9 00		lda #$00			lda 	#0 							; set all zero
.e4c0	20 ad e4	jsr $e4ad			jsr 	_BFSCSetAll
.e4c3	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.e4c6	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.e4c7					COMMAND_Run:
.e4c7	20 79 e5	jsr $e579			jsr 	COMMAND_Clear 				; clear everything for a new run.
.e4ca	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.e4cc	a0 21		ldy #$21			ldy 	#BasicProgram >> 8
.e4ce	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.e4d0	84 21		sty $21				sty 	zCurrentLine+1
.e4d2					CRUNNewLine:
.e4d2	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.e4d4	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e4d6	f0 51		beq $e529			beq 	COMMAND_End 				; if zero, off end of program so stop.
.e4d8	a0 04		ldy #$04			ldy 	#4 							; offset to first token.
.e4da					CRUNNextInstruction:
.e4da	c8		iny				iny 								; check end of line.
.e4db	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e4dd	aa		tax				tax 								; XA = Token.
.e4de	88		dey				dey
.e4df	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; if XA = 0 then next line.
.e4e1	d0 04		bne $e4e7			bne 	CRUNNotEndOfLine
.e4e3	e0 00		cpx #$00			cpx 	#0
.e4e5	f0 0c		beq $e4f3			beq 	CRUNNextLine
.e4e7					CRUNNotEndOfLine:
.e4e7	c9 8d		cmp #$8d			cmp 	#KW_Colon & $FF 			; check for a colon first.
.e4e9	d0 16		bne $e501			bne 	CRUNExecuteOne
.e4eb	e0 00		cpx #$00			cpx 	#KW_Colon >> 8
.e4ed	d0 12		bne $e501			bne 	CRUNExecuteOne
.e4ef	c8		iny				iny 								; if found, try next instruction
.e4f0	c8		iny				iny
.e4f1	80 e7		bra $e4da			bra 	CRUNNextInstruction
.e4f3					CRUNNextLine:
.e4f3	c8		iny				iny 								; step over it.
.e4f4	c8		iny				iny
.e4f5	98		tya				tya
.e4f6	18		clc				clc 								; add Y+2 to pointer
.e4f7	65 20		adc $20				adc 	zCurrentLine
.e4f9	85 20		sta $20				sta 	zCurrentLine
.e4fb	90 d5		bcc $e4d2			bcc 	CRUNNewLine
.e4fd	e6 21		inc $21				inc 	zCurrentLine+1
.e4ff	80 d1		bra $e4d2			bra 	CRUNNewLine
.e501					CRUNExecuteOne:
.e501	c8		iny				iny 								; skip over loaded token
.e502	c8		iny				iny
.e503	0a		asl a				asl 	a 							; double lower keyword byte.
.e504	48		pha				pha 								; save on stack.
.e505	8a		txa				txa 								; roll carry out into upper byte.
.e506	2a		rol a				rol 	a
.e507	29 03		and #$03			and 	#3 							; now an index
.e509	aa		tax				tax 								; back in X
.e50a	68		pla				pla
.e50b	18		clc				clc
.e50c	69 fe		adc #$fe			adc 	#(KeywordVectorTable-2)&$FF
.e50e	8d 7b 20	sta $207b			sta 	Temp1+1
.e511	8a		txa				txa
.e512	69 df		adc #$df			adc 	#(KeywordVectorTable-2)>>8
.e514	8d 7c 20	sta $207c			sta 	Temp1+2
.e517	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.e519	8d 7a 20	sta $207a			sta 	Temp1+0
.e51c	20 7a 20	jsr $207a			jsr 	Temp1 						; call instruction
.e51f	80 b9		bra $e4da			bra 	CRUNNextInstruction 		; do next instruction.
.e521					COMMAND_Stop:
.e521	20 0e e6	jsr $e60e			jsr 	ReportError
>e524	53 74 6f 70 00					.text 	"Stop",$00
.e529					COMMAND_End:
>e529	02						.byte 	2
.e52a	4c 03 e6	jmp $e603			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.e52d					COMMAND_Assert:
.e52d	20 2b e1	jsr $e12b			jsr 	EvaluateBase 				; evaluate the expression
.e530	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.e533	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e536	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.e539	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e53c	d0 11		bne $e54f			bne 	_CMDAExit
.e53e	20 0e e6	jsr $e60e			jsr 	ReportError
>e541	41 73 73 65 72 74 20 66				.text 	"Assert failed",$00
>e549	61 69 6c 65 64 00
.e54f					_CMDAExit:
.e54f	60		rts				rts
.e550					COMMAND_Rem:
.e550	c8		iny				iny
.e551	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; check string follows
.e553	d0 0b		bne $e560			bne 	_CRMSyntax
.e555	88		dey				dey
.e556	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e558	f0 06		beq $e560			beq 	_CRMSyntax
.e55a	98		tya				tya 								; skip over it.
.e55b	18		clc				clc
.e55c	71 20		adc ($20),y			adc 	(zCurrentLine),y
.e55e	a8		tay				tay
.e55f	60		rts				rts
.e560					_CRMSyntax:
.e560	4c 09 e6	jmp $e609			jmp 	SyntaxError
.e563					COMMAND_New:
.e563	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.e565	8d 00 21	sta $2100			sta 	BasicProgram
.e568	8d 01 21	sta $2101			sta 	BasicProgram+1
.e56b	20 79 e5	jsr $e579			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.e56e	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.e570	8d 78 20	sta $2078			sta 	HighMemory
.e573	a9 40		lda #$40			lda 	#endMemory >> 8
.e575	8d 79 20	sta $2079			sta 	HighMemory+1
.e578	60		rts				rts
.e579					COMMAND_Clear:
.e579	a2 0f		ldx #$0f			ldx 	#hashTableSize*2-1 			; clear the hash table to all zeros.
.e57b					_CCClearHash:
.e57b	a9 aa		lda #$aa			lda 	#$AA
.e57d	9d 68 20	sta $2068,x			sta 	HashTable,x
.e580	ca		dex				dex
.e581	10 f8		bpl $e57b			bpl 	_CCClearHash
.e583	a9 00		lda #$00			lda 	#basicStack & $FF 			; reset BASIC stack
.e585	85 22		sta $22				sta 	zBasicStack
.e587	a9 02		lda #$02			lda 	#basicStack >> 8
.e589	85 23		sta $23				sta 	zBasicStack+1
.e58b	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.e58d	85 24		sta $24				sta 	zLowMemory
.e58f	a9 21		lda #$21			lda 	#BasicProgram >> 8
.e591	85 25		sta $25				sta 	zLowMemory+1
.e593					_CCFindEnd:
.e593	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.e595	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.e597	f0 0b		beq $e5a4			beq 	_CCFoundEnd
.e599	18		clc				clc 								; go to next line.
.e59a	65 24		adc $24				adc 	zLowMemory
.e59c	85 24		sta $24				sta 	zLowMemory
.e59e	90 f3		bcc $e593			bcc 	_CCFindEnd
.e5a0	e6 25		inc $25				inc 	zLowMemory+1
.e5a2	80 ef		bra $e593			bra 	_CCFindEnd
.e5a4					_CCFoundEnd:
.e5a4	a5 24		lda $24				lda 	zLowMemory 					; variables etc. start after end of program.
.e5a6	18		clc				clc
.e5a7	69 02		adc #$02			adc 	#2
.e5a9	85 24		sta $24				sta 	zLowMemory
.e5ab	90 02		bcc $e5af			bcc 	_CCNoCarry
.e5ad	e6 25		inc $25				inc 	zLowMemory+1
.e5af					_CCNoCarry:
.e5af	60		rts				rts
.e5b0					COMMAND_Old:
.e5b0	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.e5b2	85 24		sta $24				sta 	zLowMemory
.e5b4	a9 21		lda #$21			lda 	#BasicProgram >> 8
.e5b6	85 25		sta $25				sta 	zLowMemory+1
.e5b8	a0 04		ldy #$04			ldy 	#4 							; look for the $0000 marker.
.e5ba					_COScan:
.e5ba	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; look at next byte pair
.e5bc	c8		iny				iny
.e5bd	11 24		ora ($24),y			ora 	(zLowMemory),y
.e5bf	c8		iny				iny
.e5c0	f0 0d		beq $e5cf			beq 	_COFail 					; can't find marker, corrupted maybe ?
.e5c2	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.e5c4	d0 f4		bne $e5ba			bne 	_COScan
.e5c6	98		tya				tya 								; Y is the new offset to the next instruction
.e5c7	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.e5c9	91 24		sta ($24),y			sta 	(zLowMemory),y
.e5cb	20 79 e5	jsr $e579			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.e5ce	60		rts				rts
.e5cf					_COFail:
.e5cf	20 0e e6	jsr $e60e			jsr 	ReportError
>e5d2	43 61 6e 6e 6f 74 20 72				.text 	"Cannot recover program",$00
>e5da	65 63 6f 76 65 72 20 70 72 6f 67 72 61 6d 00

;******  Return to file: basic.asm

.e5e9					Start:
.e5e9	20 9d b1	jsr $b19d		jsr 	IOInitialise
.e5ec					Loop:
.e5ec	20 e3 b1	jsr $b1e3		jsr 	IOReadKey
.e5ef	20 ac b1	jsr $b1ac		jsr 	IOPrintChar
.e5f2	20 ac b1	jsr $b1ac		jsr 	IOPrintChar
.e5f5	20 ac b1	jsr $b1ac		jsr 	IOPrintChar
.e5f8	80 f2		bra $e5ec		bra 	Loop
.e5fa	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.e5fc	9a		txs			txs
.e5fd	20 63 e5	jsr $e563			jsr 	COMMAND_New 				; do a new
.e600	20 b0 e5	jsr $e5b0			jsr 	COMMAND_Old 				; get back the old program as we're deving.
.e603					WarmStart:
.e603	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.e605	9a		txs			txs
.e606	4c c7 e4	jmp $e4c7			jmp 	COMMAND_Run 				; RUN current program.
.e609					SyntaxError:
.e609	a9 01		lda #$01			lda 	#1
.e60b	ea		nop				nop
.e60c	80 fb		bra $e609			bra 	SyntaxError
.e60e					ReportError:
.e60e	a9 02		lda #$02			lda 	#2
.e610	ea		nop				nop
.e611	80 fb		bra $e60e			bra 	ReportError

;******  Processing file: include/basic_generated.inc

>2100	07 2a 00 97 20 31 00 00			.byte $07,$2a,$00,$97,$20,$31,$00,$00

;******  Return to file: basic.asm


;******  End of listing
