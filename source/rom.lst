
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D TARGET=2 -b -L rom.lst -o rom.bin basic.asm
; Tue Jul 30 16:03:43 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	3a f1						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_6502.asm

>0000	00					.byte 	0
=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$0800					EXTLowMemory = $0800 						; Workspace RAM starts here
=$6000					EXTHighMemory = $6000 						; Workspace RAM ends here
=$b000					PScreen = $B000								; 1k screen RAM here
=$b800					PKeyboard = $B800							; Keyboard port.
=$b801					PBreak = $B801 								; Break key.
.a000					EXTStartPersonalise:
.a000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.a002	9a		txs			txs
.a003	20 82 a0	jsr $a082		jsr 	EXTReset 						; reset video
.a006	20 38 a0	jsr $a038		jsr 	EXTClearScreen 					; clear screen
.a009	4c 3a f1	jmp $f13a		jmp 	Start 							; start main application
.a00c					EXTReadKeyPort:
.a00c	ad 00 b8	lda $b800		lda 	PKeyboard							; read key
.a00f	09 00		ora #$00		ora 	#0
.a011	60		rts			rts
.a012					EXTRemoveKeyPressed:
.a012	48		pha			pha 										; key pressed clear queue byte.
.a013	a9 00		lda #$00		lda 	#0
.a015	8d 00 b8	sta $b800		sta 	PKeyboard
.a018	68		pla			pla
.a019	60		rts			rts
.a01a					EXTCheckBreak:
.a01a	ad 01 b8	lda $b801		lda 	PBreak
.a01d	60		rts			rts
.a01e					EXTReadScreen:
.a01e	5a		phy			phy 										; save Y
.a01f	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.a021	98		tya			tya
.a022	09 b0		ora #$b0		ora 	#PScreen>>8 						; move into screen area
.a024	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.a026	a0 00		ldy #$00		ldy 	#0
.a028	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a02a	7a		ply			ply 										; restore Y and exit.
.a02b	60		rts			rts
.a02c					EXTWriteScreen:
.a02c	5a		phy			phy
.a02d	48		pha			pha
.a02e	20 1e a0	jsr $a01e		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.a031	a0 00		ldy #$00		ldy 	#0
.a033	68		pla			pla 										; restore and write.
.a034	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a036	7a		ply			ply
.a037	60		rts			rts
.a038					EXTClearScreen:
.a038	48		pha			pha 										; save registers
.a039	da		phx			phx
.a03a	a2 00		ldx #$00		ldx 	#0
.a03c					_EXTCSLoop:
.a03c	a9 20		lda #$20		lda 	#32
.a03e	9d 00 b0	sta $b000,x		sta 	PScreen+0,x
.a041	9d 00 b1	sta $b100,x		sta 	PScreen+$100,x
.a044	9d 00 b2	sta $b200,x		sta 	PScreen+$200,x
.a047	9d 00 b3	sta $b300,x		sta 	PScreen+$300,x
.a04a	e8		inx			inx
.a04b	d0 ef		bne $a03c		bne 	_EXTCSLoop
.a04d	fa		plx			plx 										; restore
.a04e	68		pla			pla
.a04f	60		rts			rts
.a050					EXTScrollDisplay:
.a050	48		pha			pha 										; save registers
.a051	5a		phy			phy
.a052	a9 00		lda #$00		lda 	#PScreen & $FF 					; set pointer to screen
.a054	85 04		sta $04			sta 	EXTZPWork+0
.a056	a9 b0		lda #$b0		lda 	#PScreen >> 8
.a058	85 05		sta $05			sta 	EXTZPWork+1
.a05a					_EXTScroll:
.a05a	a0 28		ldy #$28		ldy 	#EXTWidth
.a05c	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a05e	a0 00		ldy #$00		ldy 	#0
.a060	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a062	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.a064	d0 02		bne $a068		bne 	_EXTNoCarry
.a066	e6 05		inc $05			inc 	EXTZPWork+1
.a068					_EXTNoCarry:
.a068	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.a06a	c9 c0		cmp #$c0		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) & $FF
.a06c	d0 ec		bne $a05a		bne 	_EXTScroll
.a06e	a5 05		lda $05			lda 	EXTZPWork+1
.a070	c9 b3		cmp #$b3		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) >> 8
.a072	d0 e6		bne $a05a		bne 	_EXTScroll
.a074	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.a076					_EXTLastLine:
.a076	a9 20		lda #$20		lda 	#32
.a078	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a07a	c8		iny			iny
.a07b	c0 28		cpy #$28		cpy 	#EXTWidth
.a07d	d0 f7		bne $a076		bne 	_EXTLastLine
.a07f	7a		ply			ply 										; restore and exit.
.a080	68		pla			pla
.a081	60		rts			rts
.a082					EXTReset:
.a082	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	b5 e8					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	56 e1					.word	SyntaxError                   ; """        ($0081)
>e004	56 e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	aa e8					.word	BFUNC_String                  ; "$"        ($0083)
>e008	4a ea					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	bc e8					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	56 e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	56 e1					.word	SyntaxError                   ; "("        ($0087)
>e010	56 e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	2b e9					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	5e e8					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	56 e1					.word	SyntaxError                   ; ","        ($008b)
>e018	84 e8					.word	BFUNC_Subtract                ; "-"        ($008c)
>e01a	82 e9					.word	BFUNC_Divide                  ; "/"        ($008d)
>e01c	56 e1					.word	SyntaxError                   ; ":"        ($008e)
>e01e	56 e1					.word	SyntaxError                   ; ";"        ($008f)
>e020	c8 ea					.word	BFUNC_LessEqual               ; "<="       ($0090)
>e022	69 ea					.word	BFUNC_NotEquals               ; "<>"       ($0091)
>e024	a3 ea					.word	BFUNC_Less                    ; "<"        ($0092)
>e026	66 ea					.word	BFUNC_Equals                  ; "="        ($0093)
>e028	a6 ea					.word	BFUNC_GreaterEqual            ; ">="       ($0094)
>e02a	c5 ea					.word	BFUNC_Greater                 ; ">"        ($0095)
>e02c	ae e8					.word	BFUNC_ByteInd                 ; "?"        ($0096)
>e02e	06 e9					.word	BFUNC_Xor                     ; "^"        ($0097)
>e030	9f ec					.word	COMMAND_Assert                ; "assert"   ($0098)
>e032	7f eb					.word	UNARY_Abs                     ; "abs"      ($0099)
>e034	e6 ec					.word	COMMAND_Clear                 ; "clear"    ($009a)
>e036	ab ef					.word	COMMAND_CLS                   ; "cls"      ($009b)
>e038	6a eb					.word	UNARY_Ch                      ; "ch"       ($009c)
>e03a	56 e1					.word	SyntaxError                   ; "dim"      ($009d)
>e03c	4e f0					.word	COMMAND_Do                    ; "do"       ($009e)
>e03e	94 ee					.word	COMMAND_ELSE                  ; "else"     ($009f)
>e040	94 ec					.word	COMMAND_End                   ; "end"      ($00a0)
>e042	56 e1					.word	SyntaxError                   ; "for"      ($00a1)
>e044	db f0					.word	COMMAND_Gosub                 ; "gosub"    ($00a2)
>e046	c8 f0					.word	COMMAND_Goto                  ; "goto"     ($00a3)
>e048	9c eb					.word	UNARY_Get                     ; "get"      ($00a4)
>e04a	f6 eb					.word	UNARY_IOAddr                  ; "ioaddr"   ($00a5)
>e04c	56 e1					.word	SyntaxError                   ; "input"    ($00a6)
>e04e	62 ee					.word	COMMAND_IF                    ; "if"       ($00a7)
>e050	ae ef					.word	COMMAND_List                  ; "list"     ($00a8)
>e052	56 e1					.word	SyntaxError                   ; "link"     ($00a9)
>e054	58 ed					.word	COMMAND_Let                   ; "let"      ($00aa)
>e056	28 eb					.word	UNARY_Len                     ; "len"      ($00ab)
>e058	56 e1					.word	SyntaxError                   ; "next"     ($00ac)
>e05a	cd ec					.word	COMMAND_NewExec               ; "new"      ($00ad)
>e05c	1c ed					.word	COMMAND_OldExec               ; "old"      ($00ae)
>e05e	9d ee					.word	COMMAND_Print                 ; "print"    ($00af)
>e060	a6 eb					.word	UNARY_Page                    ; "page"     ($00b0)
>e062	e7 f0					.word	COMMAND_Return                ; "return"   ($00b1)
>e064	c3 ec					.word	COMMAND_Rem                   ; "rem"      ($00b2)
>e066	0b ec					.word	COMMAND_Run                   ; "run"      ($00b3)
>e068	b9 eb					.word	UNARY_Rnd                     ; "rnd"      ($00b4)
>e06a	8c ec					.word	COMMAND_Stop                  ; "stop"     ($00b5)
>e06c	56 e1					.word	SyntaxError                   ; "step"     ($00b6)
>e06e	80 ee					.word	COMMAND_THEN                  ; "then"     ($00b7)
>e070	87 eb					.word	UNARY_Top                     ; "top"      ($00b8)
>e072	56 e1					.word	SyntaxError                   ; "to"       ($00b9)
>e074	54 f0					.word	COMMAND_Until                 ; "until"    ($00ba)
>e076	e1 e8					.word	BFUNC_Or                      ; "|"        ($00bb)
>e078	e7 ea					.word	BFUNC_StringCompare           ; "~"        ($00bc)
.e07a					TokenText:
>e07a	a1					.byte $a1                             ; $0080 !
>e07b	a2					.byte $a2                             ; $0081 "
>e07c	a3					.byte $a3                             ; $0082 #
>e07d	a4					.byte $a4                             ; $0083 $
>e07e	a5					.byte $a5                             ; $0084 %
>e07f	a6					.byte $a6                             ; $0085 &
>e080	a7					.byte $a7                             ; $0086 '
>e081	a8					.byte $a8                             ; $0087 (
>e082	a9					.byte $a9                             ; $0088 )
>e083	aa					.byte $aa                             ; $0089 *
>e084	ab					.byte $ab                             ; $008a +
>e085	ac					.byte $ac                             ; $008b ,
>e086	ad					.byte $ad                             ; $008c -
>e087	af					.byte $af                             ; $008d /
>e088	ba					.byte $ba                             ; $008e :
>e089	bb					.byte $bb                             ; $008f ;
>e08a	3c bd					.byte $3c,$bd                         ; $0090 <=
>e08c	3c be					.byte $3c,$be                         ; $0091 <>
>e08e	bc					.byte $bc                             ; $0092 <
>e08f	bd					.byte $bd                             ; $0093 =
>e090	3e bd					.byte $3e,$bd                         ; $0094 >=
>e092	be					.byte $be                             ; $0095 >
>e093	bf					.byte $bf                             ; $0096 ?
>e094	de					.byte $de                             ; $0097 ^
>e095	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0098 assert
>e09b	41 42 d3				.byte $41,$42,$d3                     ; $0099 abs
>e09e	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $009a clear
>e0a3	43 4c d3				.byte $43,$4c,$d3                     ; $009b cls
>e0a6	43 c8					.byte $43,$c8                         ; $009c ch
>e0a8	44 49 cd				.byte $44,$49,$cd                     ; $009d dim
>e0ab	44 cf					.byte $44,$cf                         ; $009e do
>e0ad	45 4c 53 c5				.byte $45,$4c,$53,$c5                 ; $009f else
>e0b1	45 4e c4				.byte $45,$4e,$c4                     ; $00a0 end
>e0b4	46 4f d2				.byte $46,$4f,$d2                     ; $00a1 for
>e0b7	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $00a2 gosub
>e0bc	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $00a3 goto
>e0c0	47 45 d4				.byte $47,$45,$d4                     ; $00a4 get
>e0c3	49 4f 41 44 44 d2			.byte $49,$4f,$41,$44,$44,$d2         ; $00a5 ioaddr
>e0c9	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a6 input
>e0ce	49 c6					.byte $49,$c6                         ; $00a7 if
>e0d0	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a8 list
>e0d4	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00a9 link
>e0d8	4c 45 d4				.byte $4c,$45,$d4                     ; $00aa let
>e0db	4c 45 ce				.byte $4c,$45,$ce                     ; $00ab len
>e0de	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00ac next
>e0e2	4e 45 d7				.byte $4e,$45,$d7                     ; $00ad new
>e0e5	4f 4c c4				.byte $4f,$4c,$c4                     ; $00ae old
>e0e8	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00af print
>e0ed	50 41 47 c5				.byte $50,$41,$47,$c5                 ; $00b0 page
>e0f1	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce         ; $00b1 return
>e0f7	52 45 cd				.byte $52,$45,$cd                     ; $00b2 rem
>e0fa	52 55 ce				.byte $52,$55,$ce                     ; $00b3 run
>e0fd	52 4e c4				.byte $52,$4e,$c4                     ; $00b4 rnd
>e100	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00b5 stop
>e104	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00b6 step
>e108	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b7 then
>e10c	54 4f d0				.byte $54,$4f,$d0                     ; $00b8 top
>e10f	54 cf					.byte $54,$cf                         ; $00b9 to
>e111	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc             ; $00ba until
>e116	fc					.byte $fc                             ; $00bb |
>e117	fe					.byte $fe                             ; $00bc ~
>e118	00					.byte $00
.e119					TokenTypeInformation:
>e119	04					.byte $04                             ; $0080 !
>e11a	0a					.byte $0a                             ; $0081 "
>e11b	0a					.byte $0a                             ; $0082 #
>e11c	04					.byte $04                             ; $0083 $
>e11d	03					.byte $03                             ; $0084 %
>e11e	00					.byte $00                             ; $0085 &
>e11f	0a					.byte $0a                             ; $0086 '
>e120	0a					.byte $0a                             ; $0087 (
>e121	0a					.byte $0a                             ; $0088 )
>e122	03					.byte $03                             ; $0089 *
>e123	02					.byte $02                             ; $008a +
>e124	0a					.byte $0a                             ; $008b ,
>e125	02					.byte $02                             ; $008c -
>e126	03					.byte $03                             ; $008d /
>e127	0a					.byte $0a                             ; $008e :
>e128	0a					.byte $0a                             ; $008f ;
>e129	01					.byte $01                             ; $0090 <=
>e12a	01					.byte $01                             ; $0091 <>
>e12b	01					.byte $01                             ; $0092 <
>e12c	01					.byte $01                             ; $0093 =
>e12d	01					.byte $01                             ; $0094 >=
>e12e	01					.byte $01                             ; $0095 >
>e12f	04					.byte $04                             ; $0096 ?
>e130	00					.byte $00                             ; $0097 ^
>e131	08					.byte $08                             ; $0098 assert
>e132	09					.byte $09                             ; $0099 abs
>e133	08					.byte $08                             ; $009a clear
>e134	08					.byte $08                             ; $009b cls
>e135	09					.byte $09                             ; $009c ch
>e136	08					.byte $08                             ; $009d dim
>e137	08					.byte $08                             ; $009e do
>e138	08					.byte $08                             ; $009f else
>e139	08					.byte $08                             ; $00a0 end
>e13a	08					.byte $08                             ; $00a1 for
>e13b	08					.byte $08                             ; $00a2 gosub
>e13c	08					.byte $08                             ; $00a3 goto
>e13d	09					.byte $09                             ; $00a4 get
>e13e	09					.byte $09                             ; $00a5 ioaddr
>e13f	08					.byte $08                             ; $00a6 input
>e140	08					.byte $08                             ; $00a7 if
>e141	08					.byte $08                             ; $00a8 list
>e142	08					.byte $08                             ; $00a9 link
>e143	08					.byte $08                             ; $00aa let
>e144	09					.byte $09                             ; $00ab len
>e145	08					.byte $08                             ; $00ac next
>e146	08					.byte $08                             ; $00ad new
>e147	08					.byte $08                             ; $00ae old
>e148	08					.byte $08                             ; $00af print
>e149	09					.byte $09                             ; $00b0 page
>e14a	08					.byte $08                             ; $00b1 return
>e14b	08					.byte $08                             ; $00b2 rem
>e14c	08					.byte $08                             ; $00b3 run
>e14d	09					.byte $09                             ; $00b4 rnd
>e14e	08					.byte $08                             ; $00b5 stop
>e14f	08					.byte $08                             ; $00b6 step
>e150	08					.byte $08                             ; $00b7 then
>e151	09					.byte $09                             ; $00b8 top
>e152	08					.byte $08                             ; $00b9 to
>e153	08					.byte $08                             ; $00ba until
>e154	00					.byte $00                             ; $00bb |
>e155	01					.byte $01                             ; $00bc ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_COMMA = $008b
=$008c					KW_MINUS = $008c
=$008d					KW_FSLASH = $008d
=$008e					KW_COLON = $008e
=$008f					KW_SEMICOLON = $008f
=$0090					KW_LESSEQUAL = $0090
=$0091					KW_LESSGREATER = $0091
=$0092					KW_LESS = $0092
=$0093					KW_EQUAL = $0093
=$0094					KW_GREATEREQUAL = $0094
=$0095					KW_GREATER = $0095
=$0096					KW_QUESTION = $0096
=$0097					KW_HAT = $0097
=$0098					KW_ASSERT = $0098
=$0099					KW_ABS = $0099
=$009a					KW_CLEAR = $009a
=$009b					KW_CLS = $009b
=$009c					KW_CH = $009c
=$009d					KW_DIM = $009d
=$009e					KW_DO = $009e
=$009f					KW_ELSE = $009f
=$00a0					KW_END = $00a0
=$00a1					KW_FOR = $00a1
=$00a2					KW_GOSUB = $00a2
=$00a3					KW_GOTO = $00a3
=$00a4					KW_GET = $00a4
=$00a5					KW_IOADDR = $00a5
=$00a6					KW_INPUT = $00a6
=$00a7					KW_IF = $00a7
=$00a8					KW_LIST = $00a8
=$00a9					KW_LINK = $00a9
=$00aa					KW_LET = $00aa
=$00ab					KW_LEN = $00ab
=$00ac					KW_NEXT = $00ac
=$00ad					KW_NEW = $00ad
=$00ae					KW_OLD = $00ae
=$00af					KW_PRINT = $00af
=$00b0					KW_PAGE = $00b0
=$00b1					KW_RETURN = $00b1
=$00b2					KW_REM = $00b2
=$00b3					KW_RUN = $00b3
=$00b4					KW_RND = $00b4
=$00b5					KW_STOP = $00b5
=$00b6					KW_STEP = $00b6
=$00b7					KW_THEN = $00b7
=$00b8					KW_TOP = $00b8
=$00b9					KW_TO = $00b9
=$00ba					KW_UNTIL = $00ba
=$00bb					KW_BAR = $00bb
=$00bc					KW_TILDE = $00bc

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e156					SyntaxError:
.e156	20 66 e1	jsr $e166			jsr 	ReportError
>e159	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e161	52 52 4f 52 00
.e166					ReportError:
.e166	fa		plx				plx
.e167	7a		ply				ply
.e168	e8		inx				inx
.e169	d0 01		bne $e16c			bne 	_REPrint
.e16b	c8		iny				iny
.e16c					_REPrint:
.e16c	20 a8 e4	jsr $e4a8			jsr 	SIOPrintString
.e16f	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e171	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e173	f0 13		beq $e188			beq 	_RENoLineNumber
.e175	a2 90		ldx #$90			ldx 	#_REAt & $FF
.e177	a0 e1		ldy #$e1			ldy 	#_REAt >> 8
.e179	20 a8 e4	jsr $e4a8			jsr 	SIOPrintString
.e17c	a0 01		ldy #$01			ldy 	#1
.e17e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e180	aa		tax				tax
.e181	c8		iny				iny
.e182	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e184	a8		tay				tay
.e185	20 95 e1	jsr $e195			jsr 	PrintWordInteger
.e188					_RENoLineNumber:
.e188	a9 0d		lda #$0d			lda 	#13
.e18a	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.e18d	4c 73 f1	jmp $f173			jmp 	WarmStart
>e190	20 41 54 20 00			_REAt:	.text 	" AT ",0
.e195					PrintWordInteger:
.e195	8a		txa				txa
.e196	a2 00		ldx #$00			ldx 	#0
.e198	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e19b	98		tya				tya
.e19c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e19f	c8		iny				iny
.e1a0	a9 00		lda #$00			lda 	#0
.e1a2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e1a5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e1a8	20 73 ef	jsr $ef73			jsr 	CPRPrintInteger
.e1ab	60		rts				rts
.e1ac					CheckNextCharacter:
.e1ac	8d 98 20	sta $2098			sta 	Temp1 						; save character to check
.e1af					_CNCLoop:
.e1af	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e1b1	f0 0b		beq $e1be			beq 	_CNCFail 					; end of line, so no character
.e1b3	c8		iny				iny
.e1b4	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e1b6	f0 f7		beq $e1af			beq 	_CNCLoop
.e1b8	cd 98 20	cmp $2098			cmp 	Temp1 						; fail if not what was wanted
.e1bb	d0 01		bne $e1be			bne 	_CNCFail
.e1bd	60		rts				rts
.e1be					_CNCFail:
.e1be	20 66 e1	jsr $e166			jsr 	ReportError
>e1c1	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e1c9	54 4f 4b 45 4e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e1cf							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0024					zTemp1:			.word 	?					; temporary vars
>0026					zTemp2:			.word 	?
>0028					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>2096					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>2098					Temp1:			.dword	?					; 4 byte temporary stores.
>209c					SignCount:		.byte 	? 					; count of signs in divide.
>209d					StringBufferPos:.byte 	? 					; next free slot in string buffer
>209e					RandomSeed 		.word 	? 					; Random Number
>20a0					xCursor 		.byte 	? 					; cursor position
>20a1					yCursor 		.byte 	?
>20a2					breakCheckCount	.byte 	?					; how often check for break.
>20a3					basicStackIndex	.byte 	? 					; index into Basic Stack.
>20a4									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e1cf					EvaluateSNError:
.e1cf	4c 56 e1	jmp $e156			jmp 	SyntaxError
.e1d2					EvaluateMissingQuote:
.e1d2	20 66 e1	jsr $e166			jsr 	ReportError
>e1d5	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e1dd	51 55 4f 54 45 00
.e1e3					EvaluateStringFull:
.e1e3	20 66 e1	jsr $e166			jsr 	ReportError
>e1e6	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e1ee	55 46 46 45 52 20 46 55 4c 4c 00
.e1f9					EvaluateBadHex:
.e1f9	20 66 e1	jsr $e166			jsr 	ReportError
>e1fc	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e204					EvaluateAtomCurrentLevel:
.e204	a9 07		lda #$07			lda 	#7
.e206	80 04		bra $e20c			bra 	EvaluateAtPrecedenceLevel
.e208					EvaluateBase:
.e208	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e20a					EvaluateBaseCurrentLevel:
.e20a	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e20c					EvaluateAtPrecedenceLevel:
.e20c	48		pha				pha 								; save precedence level
.e20d	a9 00		lda #$00			lda 	#0 							; zero the result.
.e20f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e212	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e215	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e218	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e21b					_EVALSkipSpace1:
.e21b	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e21d	f0 b0		beq $e1cf			beq 	EvaluateSNError 			; end of line, without token.
.e21f	c8		iny				iny
.e220	c9 20		cmp #$20			cmp 	#32
.e222	f0 f7		beq $e21b			beq 	_EVALSkipSpace1
.e224	88		dey				dey 								; points at the token.
.e225	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e227	f0 14		beq $e23d			beq 	_EVALString  				; if so load in a constant string
.e229	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e22b	f0 36		beq $e263			beq 	_EVALHexadecimal
.e22d	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e22f	90 04		bcc $e235			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e231	c9 3a		cmp #$3a			cmp 	#'9'+1
.e233	90 03		bcc $e238			bcc 	_EVALDecimal
.e235					_EVALGoKeywordVariable:
.e235	4c ba e2	jmp $e2ba			jmp 	_EVALKeywordVariable
.e238					_EVALDecimal:
.e238	20 17 e3	jsr $e317			jsr 	EVALGetDecConstant 			; get decimal constant
.e23b	80 34		bra $e271			bra 	_EVALGotAtom 				; got atom.
.e23d					_EVALString:
.e23d	da		phx				phx 								; save X on stack
.e23e	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e240	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e243	ad 9d 20	lda $209d			lda 	StringBufferPos 			; X = Buffer Position.
.e246	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e249	aa		tax				tax 								; put in X to build the string.
.e24a	c8		iny				iny 								; skip over opening quote character
.e24b					_EVALStringCopy:
.e24b	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e24d	c8		iny				iny
.e24e	f0 82		beq $e1d2			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e250	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e253	e8		inx				inx 								; and bump that pointer.
.e254	f0 8d		beq $e1e3			beq 	EvaluateStringFull 			; buffer is full.
.e256	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e258	d0 f1		bne $e24b			bne 	_EVALStringCopy
.e25a	8e 9d 20	stx $209d			stx 	StringBufferPos 			; this is the new next free slot.
.e25d	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e260	fa		plx				plx 								; restore X
.e261	80 0e		bra $e271			bra 	_EVALGotAtom 				; got the atom.
.e263					_EVALHexaDecimal
.e263	c8		iny				iny 								; skip over the '#'
.e264	5a		phy				phy 								; save Y
.e265	20 83 e3	jsr $e383			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e268	8c 98 20	sty $2098			sty 	Temp1 						; has Y changed ?
.e26b	68		pla				pla
.e26c	cd 98 20	cmp $2098			cmp 	Temp1
.e26f	f0 88		beq $e1f9			beq 	EvaluateBadHex 				; if not, error.
.e271					_EVALGotAtom:
.e271					_EVALGetOperator:
.e271	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e273	c8		iny				iny 								; this should be binary operator
.e274	c9 20		cmp #$20			cmp 	#$20
.e276	f0 f9		beq $e271			beq 	_EVALGetOperator
.e278	88		dey				dey
.e279	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e27b	10 3b		bpl $e2b8			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e27d	da		phx				phx 								; save X
.e27e	aa		tax				tax 								; token in X
.e27f	bd 99 e0	lda $e099,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e282	8d 98 20	sta $2098			sta 	Temp1 						; save precedence in Temp1
.e285	fa		plx				plx 								; restore X
.e286	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e288	b0 2e		bcs $e2b8			bcs 	_EVALExitPullA
.e28a	68		pla				pla 								; get and save precedence level.
.e28b	48		pha				pha
.e28c	cd 98 20	cmp $2098			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e28f	f0 02		beq $e293			beq 	_EVALDoCalc					; equal, do it.
.e291	b0 25		bcs $e2b8			bcs 	_EVALExitPullA				; too high, then exit.
.e293					_EVALDoCalc:
.e293	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e295	c8		iny				iny
.e296	48		pha				pha
.e297	da		phx				phx
.e298	e8		inx				inx 								; work out right hand side.
.e299	e8		inx				inx
.e29a	e8		inx				inx
.e29b	e8		inx				inx
.e29c	ad 98 20	lda $2098			lda 	Temp1 						; get current operator precedence level.
.e29f	1a		inc a				inc 	a 							; so work it out at the next level.
.e2a0	20 0c e2	jsr $e20c			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e2a3	fa		plx				plx 								; fix X back.
.e2a4	68		pla				pla 								; get keyword
.e2a5					_EVALExecuteA:
.e2a5	0a		asl a				asl 	a 							; shift left, drop bit 7
.e2a6	8d 99 20	sta $2099			sta 	Temp1+1						; save in Temp1.1
.e2a9	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e2ab	8d 9a 20	sta $209a			sta 	Temp1+2 					; set at Temp1.2
.e2ae	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e2b0	8d 98 20	sta $2098			sta 	Temp1+0
.e2b3	20 98 20	jsr $2098			jsr 	Temp1 						; call that routine.
.e2b6	80 b9		bra $e271			bra 	_EVALGotAtom 				; and loop back again.
.e2b8					_EVALExitPullA:
.e2b8	68		pla				pla 								; restore precedence.
.e2b9	60		rts				rts
.e2ba					_EVALKeywordVariable:
.e2ba	09 00		ora #$00			ora 	#0 							; check bit 7
.e2bc	10 0f		bpl $e2cd			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e2be	da		phx				phx
.e2bf	aa		tax				tax
.e2c0	bd 99 e0	lda $e099,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e2c3	fa		plx				plx
.e2c4	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e2c6	d0 05		bne $e2cd			bne 	_EVALNotUnaryFunction
.e2c8	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e2ca	c8		iny				iny 								; consume it
.e2cb	80 d8		bra $e2a5			bra 	_EVALExecuteA 				; execute TOS.
.e2cd					_EVALNotUnaryFunction:
.e2cd	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e2cf	10 3d		bpl $e30e			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e2d1	c9 8c		cmp #$8c			cmp 	#KW_MINUS 					; check negation
.e2d3	f0 0f		beq $e2e4			beq 	_EVALUnaryNegation
.e2d5	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e2d7	d0 14		bne $e2ed			bne		_EVALCheckUnaryOperator
.e2d9	c8		iny				iny 								; skip left bracket.
.e2da	20 0a e2	jsr $e20a			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e2dd	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e2df	20 ac e1	jsr $e1ac			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e2e2	80 8d		bra $e271			bra 	_EVALGotAtom
.e2e4					_EVALUnaryNegation:
.e2e4	c8		iny				iny 								; skip over the - sign.
.e2e5	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e2e8	20 25 ea	jsr $ea25			jsr 	BFUNC_NegateAlways 			; negate it.
.e2eb	80 84		bra $e271			bra 	_EVALGotAtom
.e2ed					_EVALCheckUnaryOperator:
.e2ed	48		pha				pha 								; save indirection operator.
.e2ee	c8		iny				iny 								; skip over the operator
.e2ef	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e2f2	68		pla				pla 								; restore the operator
.e2f3	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e2f5	f0 0e		beq $e305			beq 	_EVALGoGotAtom
.e2f7	c9 96		cmp #$96			cmp 	#KW_QUESTION				; byte indirection
.e2f9	f0 07		beq $e302			beq 	_EVALByteRead
.e2fb	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e2fd	f0 09		beq $e308			beq 	_EVALWordRead
.e2ff	4c 56 e1	jmp $e156			jmp 	SyntaxError 				; give up.
.e302					_EVALByteRead:
.e302	20 c2 e3	jsr $e3c2			jsr 	EVALReadByteIndirect
.e305					_EVALGoGotAtom:
.e305	4c 71 e2	jmp $e271			jmp 	_EVALGotAtom
.e308					_EVALWordRead:
.e308	20 eb e3	jsr $e3eb			jsr 	EVALReadWordIndirect
.e30b	4c 71 e2	jmp $e271			jmp 	_EVALGotAtom
.e30e					_EVALCheckVariable:
.e30e	20 1b e4	jsr $e41b			jsr 	VARReference 				; get variable reference to ZTemp1
.e311	20 ff e3	jsr $e3ff			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e314	4c 71 e2	jmp $e271			jmp 	_EVALGotAtom 				; and go round.
.e317					EVALGetDecConstant:
.e317	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e319	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e31b	90 04		bcc $e321			bcc 	_EVGDExit
.e31d	c9 3a		cmp #$3a			cmp 	#'9'+1
.e31f	90 01		bcc $e322			bcc 	_EVGDValue 					; if so has legal value
.e321					_EVGDExit:
.e321	60		rts				rts
.e322					_EVGDValue:
.e322	48		pha				pha 								; save value, Y on stack
.e323	5a		phy				phy
.e324	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e326	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e329	48		pha				pha
.e32a	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e32d	48		pha				pha
.e32e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e331	48		pha				pha
.e332	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e335	48		pha				pha
.e336					_EVGDLoop:
.e336	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e339	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e33c	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e33f	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e342	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e344	d0 1d		bne $e363			bne 	_EVGDNoAdd
.e346	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e347	68		pla				pla
.e348	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e34b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e34e	68		pla				pla
.e34f	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e352	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e355	68		pla				pla
.e356	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e359	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e35c	68		pla				pla
.e35d	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e360	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e363					_EVGDNoAdd:
.e363	88		dey				dey
.e364	d0 d0		bne $e336			bne 	_EVGDLoop
.e366	7a		ply				ply 								; restore YA
.e367	68		pla				pla
.e368	c8		iny				iny 								; next character
.e369	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e36b	18		clc				clc
.e36c	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e36f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e372	90 a3		bcc $e317			bcc 	EVALGetDecConstant 			; propogate constant through
.e374	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e377	d0 9e		bne $e317			bne 	EVALGetDecConstant
.e379	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e37c	d0 99		bne $e317			bne 	EVALGetDecConstant
.e37e	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e381	80 94		bra $e317			bra 	EVALGetDecConstant 			; go back and try again.
.e383					EVALGetHexConstant:
.e383	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e385	20 b7 e3	jsr $e3b7			jsr 	EVALToUpper 				; make upper case
.e388	38		sec				sec
.e389	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e38b	90 0a		bcc $e397			bcc 	_EVGHExit 					; exit if CC
.e38d	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e38f	90 07		bcc $e398			bcc 	_EVGHValue
.e391	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e393	c9 10		cmp #$10			cmp 	#15+1
.e395	90 01		bcc $e398			bcc 	_EVGHValue
.e397					_EVGHExit:
.e397	60		rts				rts
.e398					_EVGHValue:
.e398	5a		phy				phy 								; save Y and new digit.
.e399	48		pha				pha
.e39a	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e39c					_EVGHRotate:
.e39c	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e39f	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3a2	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3a5	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3a8	88		dey				dey
.e3a9	d0 f1		bne $e39c			bne 	_EVGHRotate
.e3ab	68		pla				pla 								; restore digit and X
.e3ac	7a		ply				ply
.e3ad	c8		iny				iny 								; next character
.e3ae	18		clc				clc
.e3af	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e3b2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3b5	80 cc		bra $e383			bra 	EVALGetHexConstant 			; go back and try again.
.e3b7					EVALToUpper:
.e3b7	c9 61		cmp #$61			cmp 	#'a'
.e3b9	90 06		bcc $e3c1			bcc 	_EVTUExit
.e3bb	c9 7b		cmp #$7b			cmp 	#'z'+1
.e3bd	b0 02		bcs $e3c1			bcs 	_EVTUExit
.e3bf	49 20		eor #$20			eor 	#32
.e3c1					_EVTUExit:
.e3c1	60		rts				rts
.e3c2					EVALReadByteIndirect:
.e3c2	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3c5	85 24		sta $24				sta 	zTemp1
.e3c7	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3ca	85 25		sta $25				sta 	zTemp1+1
.e3cc	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3cf	85 26		sta $26				sta 	zTemp1+2
.e3d1	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3d4	85 27		sta $27				sta 	zTemp1+3
.e3d6					_ERBBase:
.e3d6	5a		phy				phy
.e3d7	a0 00		ldy #$00			ldy 	#0 							; read byte
.e3d9	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3db	7a		ply				ply
.e3dc					_ERBExit:
.e3dc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3df	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e3e1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3e4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3e7	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3ea	60		rts				rts
.e3eb					EVALReadWordIndirect:
.e3eb	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3ee	85 24		sta $24				sta 	zTemp1
.e3f0	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3f3	85 25		sta $25				sta 	zTemp1+1
.e3f5	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3f8	85 26		sta $26				sta 	zTemp1+2
.e3fa	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3fd	85 27		sta $27				sta 	zTemp1+3
.e3ff					EVALReadWordIndirectZTemp:
.e3ff					_ERWBase
.e3ff	5a		phy				phy
.e400	a0 00		ldy #$00			ldy 	#0 							; read word
.e402	b1 24		lda ($24),y			lda 	(zTemp1),y
.e404	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e407	c8		iny				iny
.e408	b1 24		lda ($24),y			lda 	(zTemp1),y
.e40a	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e40d	c8		iny				iny
.e40e	b1 24		lda ($24),y			lda 	(zTemp1),y
.e410	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e413	c8		iny				iny
.e414	b1 24		lda ($24),y			lda 	(zTemp1),y
.e416	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e419	7a		ply				ply
.e41a					_ERWExit:
.e41a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e41b					VARReference:
.e41b	38		sec				sec 								; check range @-Z there
.e41c	c9 40		cmp #$40			cmp 	#'@'
.e41e	90 04		bcc $e424			bcc 	_VARRError
.e420	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e422	90 03		bcc $e427			bcc 	_VARROkay
.e424					_VARRError:
.e424	4c 56 e1	jmp $e156			jmp		SyntaxError
.e427					_VARROkay:
.e427	c8		iny				iny 								; consume the variable.
.e428	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e42a	f0 1b		beq $e447			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e42c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e42e	88		dey				dey 								; point back to the first character
.e42f	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e431	f0 14		beq $e447			beq 	_VARArrayAccess
.e433	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e435	c8		iny				iny
.e436	29 1f		and #$1f			and		#31 						; mask out
.e438	0a		asl a				asl 	a 							; x 4
.e439	0a		asl a				asl 	a
.e43a	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e43c	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e43e	85 25		sta $25				sta 	zTemp1+1
.e440	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e442	85 26		sta $26				sta 	zTemp1+2
.e444	85 27		sta $27				sta 	zTemp1+3 					; return with address set.
.e446	60		rts				rts
.e447					_VARArrayAccess:
.e447	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e449	c8		iny				iny
.e44a	29 1f		and #$1f			and 	#31 						; mask it off
.e44c	48		pha				pha 								; save on the stack.
.e44d	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e450	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e453	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e456	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e459	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e45c	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e45f	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e462	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e465	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e468	68		pla				pla 								; put address in zTemp1
.e469	0a		asl a				asl 	a 							; x 4
.e46a	0a		asl a				asl 	a
.e46b	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e46d	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e46f	85 25		sta $25				sta 	zTemp1+1
.e471	5a		phy				phy
.e472	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e474	b1 24		lda ($24),y			lda 	(zTemp1),y
.e476	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e479	48		pha				pha 								; save first result as we need the indirection.
.e47a	c8		iny				iny 								; 2nd byte
.e47b	b1 24		lda ($24),y			lda 	(zTemp1),y
.e47d	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e480	85 25		sta $25				sta 	zTemp1+1
.e482	68		pla				pla 								; save the low byte.
.e483	85 24		sta $24				sta 	zTemp1+0
.e485	a9 00		lda #$00			lda 	#0
.e487	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e48a	85 26		sta $26				sta 	zTemp1+2
.e48c	a9 00		lda #$00			lda 	#0
.e48e	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e491	85 27		sta $27				sta 	zTemp1+3
.e493	7a		ply				ply 								; restore Y, address setup
.e494	60		rts				rts
.e495	80 fe		bra $e495	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e497					SIOInitialise:
.e497	20 82 a0	jsr $a082			jsr 	EXTReset 					; reset video
.e49a					SIOClearScreen:
.e49a	20 38 a0	jsr $a038			jsr 	EXTClearScreen 				; clear screen
.e49d					SIOHomeCursor:
.e49d	48		pha				pha 								; home cursor
.e49e	a9 00		lda #$00			lda 	#0
.e4a0	8d a0 20	sta $20a0			sta 	xCursor
.e4a3	8d a1 20	sta $20a1			sta 	yCursor
.e4a6	68		pla				pla
.e4a7	60		rts				rts
.e4a8					SIOPrintString:
.e4a8	48		pha				pha 								; save registers
.e4a9	da		phx				phx
.e4aa	5a		phy				phy
.e4ab	86 26		stx $26				stx 	zTemp2 						; set up indirect pointer
.e4ad	84 27		sty $27				sty 	zTemp2+1
.e4af	a0 00		ldy #$00			ldy 	#0
.e4b1					_SIOPSLoop:
.e4b1	b1 26		lda ($26),y			lda 	(zTemp2),y 					; read next, exit if 0
.e4b3	f0 1c		beq $e4d1			beq 	_SIOPSExit
.e4b5	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter 			; print and bump
.e4b8	c8		iny				iny
.e4b9	d0 f6		bne $e4b1			bne 	_SIOPSLoop
.e4bb	20 66 e1	jsr $e166			jsr 	ReportError
>e4be	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e4c6	4e 47 20 50 52 49 4e 54 45 44 00
.e4d1					_SIOPSExit:
.e4d1	7a		ply				ply 								; restore and exit.
.e4d2	fa		plx				plx
.e4d3	68		pla				pla
.e4d4	60		rts				rts
.e4d5					SIOPrintCharacter:
.e4d5	48		pha				pha 								; save AXY
.e4d6	da		phx				phx
.e4d7	5a		phy				phy
.e4d8	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e4da	f0 16		beq $e4f2			beq 	_SIOPReturn
.e4dc	c9 09		cmp #$09			cmp 	#9
.e4de	f0 2b		beq $e50b			beq 	_SIOPTab
.e4e0	20 45 e6	jsr $e645			jsr 	SIOLoadCursor 				; load cursor position in.
.e4e3	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e4e5	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen 				; write character out.
.e4e8	ee a0 20	inc $20a0			inc 	xCursor 					; move right
.e4eb	ad a0 20	lda $20a0			lda 	xCursor 					; reached the RHS
.e4ee	c9 28		cmp #$28			cmp 	#EXTWidth
.e4f0	90 15		bcc $e507			bcc 	_SIOPExit
.e4f2					_SIOPReturn:
.e4f2	a9 00		lda #$00			lda 	#0 							; zero x
.e4f4	8d a0 20	sta $20a0			sta 	xCursor
.e4f7	ee a1 20	inc $20a1			inc 	yCursor 					; go down
.e4fa	ad a1 20	lda $20a1			lda 	yCursor
.e4fd	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e4ff	90 06		bcc $e507			bcc 	_SIOPExit
.e501	20 50 a0	jsr $a050			jsr 	EXTScrollDisplay 			; scroll display up
.e504	ce a1 20	dec $20a1			dec 	yCursor 					; cursor on bottom line.
.e507					_SIOPExit:
.e507	7a		ply				ply 								; restore and exit.
.e508	fa		plx				plx
.e509	68		pla				pla
.e50a	60		rts				rts
.e50b					_SIOPTab:
.e50b	a9 20		lda #$20			lda 	#32 						; tab.
.e50d	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.e510	ad a0 20	lda $20a0			lda 	xCursor
.e513	29 07		and #$07			and 	#7
.e515	d0 f4		bne $e50b			bne 	_SIOPTab
.e517	80 ee		bra $e507			bra 	_SIOPExit
.e519					SIOGetKey:
.e519	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort 				; wait for a key
.e51c	f0 fb		beq $e519			beq 	SIOGetKey
.e51e	20 b7 e3	jsr $e3b7			jsr 	EVALToUpper 				; capitalise it.
.e521	4c 12 a0	jmp $a012			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e524					SIOReadLine:
.e524	48		pha				pha 								; save registers
.e525	da		phx				phx
.e526	5a		phy				phy
.e527					_SIORLoop:
.e527	20 45 e6	jsr $e645			jsr 	SIOLoadCursor 				; cursor in XY
.e52a	20 1e a0	jsr $a01e			jsr 	EXTReadScreen 				; read the display.
.e52d	48		pha				pha 								; save on stack.
.e52e	a9 66		lda #$66			lda 	#102 						; write cursor out
.e530	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e533	20 19 e5	jsr $e519			jsr 	SIOGetKey
.e536	aa		tax				tax 								; save in X
.e537	68		pla				pla 								; old character
.e538	da		phx				phx 								; save key pressed
.e539	20 45 e6	jsr $e645			jsr 	SIOLoadCursor 				; cursor in XY
.e53c	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e53f	68		pla				pla
.e540	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e542	f0 29		beq $e56d			beq 	_SIOCursorLeft
.e544	c9 13		cmp #$13			cmp 	#"S"-64
.e546	f0 49		beq $e591			beq 	_SIOCursorDown
.e548	c9 04		cmp #$04			cmp 	#"D"-64
.e54a	f0 2d		beq $e579			beq 	_SIOCursorRight
.e54c	c9 17		cmp #$17			cmp 	#"W"-64
.e54e	f0 35		beq $e585			beq 	_SIOCursorUp
.e550	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e552	f0 49		beq $e59d			beq 	_SIOClearScreen
.e554	c9 08		cmp #$08			cmp 	#"H"-64
.e556	f0 4a		beq $e5a2			beq 	_SIOBackspace
.e558	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e55a	f0 0e		beq $e56a			beq 	_SIOGoReturn
.e55c	c9 20		cmp #$20			cmp 	#32 						; any control
.e55e	90 c7		bcc $e527			bcc 	_SIORLoop
.e560	48		pha				pha
.e561	20 e0 e5	jsr $e5e0			jsr 	_SIOInsert 					; insert a space for new character
.e564	68		pla				pla
.e565	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter 			; print character in A
.e568	80 bd		bra $e527			bra 	_SIORLoop
.e56a					_SIOGoReturn:
.e56a	4c 0b e6	jmp $e60b			jmp 	_SIOReturn
.e56d					_SIOCursorLeft:
.e56d	ce a0 20	dec $20a0			dec 	xCursor
.e570	10 b5		bpl $e527			bpl 	_SIORLoop
.e572	a9 27		lda #$27			lda 	#EXTWidth-1
.e574					_SIOWXLoop:
.e574	8d a0 20	sta $20a0			sta 	xCursor
.e577	80 ae		bra $e527			bra 	_SIORLoop
.e579					_SIOCursorRight:
.e579	ee a0 20	inc $20a0			inc 	xCursor
.e57c	ad a0 20	lda $20a0			lda 	xCursor
.e57f	49 28		eor #$28			eor 	#EXTWidth
.e581	d0 a4		bne $e527			bne 	_SIORLoop
.e583	80 ef		bra $e574			bra 	_SIOWXLoop
.e585					_SIOCursorUp:
.e585	ce a1 20	dec $20a1			dec 	yCursor
.e588	10 9d		bpl $e527			bpl 	_SIORLoop
.e58a	a9 18		lda #$18			lda 	#EXTHeight-1
.e58c					_SIOWYLoop:
.e58c	8d a1 20	sta $20a1			sta 	yCursor
.e58f	80 96		bra $e527			bra 	_SIORLoop
.e591					_SIOCursorDown:
.e591	ee a1 20	inc $20a1			inc 	yCursor
.e594	ad a1 20	lda $20a1			lda 	yCursor
.e597	49 19		eor #$19			eor 	#EXTHeight
.e599	d0 8c		bne $e527			bne 	_SIORLoop
.e59b	80 ef		bra $e58c			bra 	_SIOWYLoop
.e59d					_SIOClearScreen:
.e59d	20 9a e4	jsr $e49a			jsr 	SIOClearScreen
.e5a0	80 85		bra $e527			bra 	_SIORLoop
.e5a2					_SIOBackspace:
.e5a2	ad a0 20	lda $20a0			lda 	xCursor 					; backspace possible ?
.e5a5	f0 80		beq $e527			beq 	_SIORLoop 					; start of line, no.
.e5a7	48		pha				pha 								; save position.
.e5a8	c9 27		cmp #$27			cmp 	#EXTWidth-1 				; not required
.e5aa	f0 1f		beq $e5cb			beq 	_SIONoShift
.e5ac	ce a0 20	dec $20a0			dec 	xCursor
.e5af					_SIOShift2:
.e5af	ee a0 20	inc $20a0			inc 	xCursor 					; copy character backward
.e5b2	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e5b5	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5b8	ce a0 20	dec $20a0			dec 	xCursor
.e5bb	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e5be	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5c1	ee a0 20	inc $20a0			inc 	xCursor
.e5c4	ad a0 20	lda $20a0			lda 	xCursor
.e5c7	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e5c9	d0 e4		bne $e5af			bne 	_SIOShift2
.e5cb					_SIONoShift:
.e5cb	a9 27		lda #$27			lda 	#EXTWidth-1 				; space on far end.
.e5cd	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e5d0	a9 20		lda #$20			lda 	#32
.e5d2	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5d5	68		pla				pla 								; restore cursor, back one.
.e5d6	3a		dec a				dec 	a
.e5d7	8d a0 20	sta $20a0			sta 	xCursor
.e5da	20 45 e6	jsr $e645			jsr 	SIOLoadCursor 				; overwrite
.e5dd	4c 27 e5	jmp $e527			jmp	 	_SIORLoop
.e5e0					_SIOInsert:
.e5e0	ad a0 20	lda $20a0			lda 	xCursor 					; at far right, nothing to do.
.e5e3	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e5e5	f0 23		beq $e60a			beq 	_SIOIExit
.e5e7	85 26		sta $26				sta 	zTemp2 						; save in temporary workspace.
.e5e9	a9 27		lda #$27			lda 	#EXTWidth-1 				; cursor at far right.
.e5eb	8d a0 20	sta $20a0			sta 	xCursor
.e5ee					_SIOShift:
.e5ee	ce a0 20	dec $20a0			dec 	xCursor 					; copy character forward
.e5f1	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e5f4	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5f7	ee a0 20	inc $20a0			inc 	xCursor
.e5fa	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e5fd	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e600	ce a0 20	dec $20a0			dec 	xCursor
.e603	ad a0 20	lda $20a0			lda 	xCursor						; until shifted line to this point.
.e606	c5 26		cmp $26				cmp 	zTemp2
.e608	d0 e4		bne $e5ee			bne 	_SIOShift
.e60a					_SIOIExit:
.e60a	60		rts				rts
.e60b					_SIOReturn:
.e60b	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e60d	8d a0 20	sta $20a0			sta 	xCursor
.e610					_SIOCopy:
.e610	20 45 e6	jsr $e645			jsr 	SIOLoadCursor
.e613	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e616	49 20		eor #$20			eor 	#$20
.e618	18		clc				clc
.e619	69 20		adc #$20			adc 	#$20
.e61b	ae a0 20	ldx $20a0			ldx 	xCursor
.e61e	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e621	ee a0 20	inc $20a0			inc 	xCursor
.e624	ad a0 20	lda $20a0			lda 	xCursor
.e627	c9 28		cmp #$28			cmp 	#EXTWidth
.e629	d0 e5		bne $e610			bne 	_SIOCopy
.e62b	aa		tax				tax 								; X contains width
.e62c					_SIOStrip:
.e62c	ca		dex				dex									; back one
.e62d	30 07		bmi $e636			bmi		_SIOFound 					; if -ve gone too far
.e62f	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e632	c9 20		cmp #$20			cmp 	#' '
.e634	f0 f6		beq $e62c			beq 	_SIOStrip
.e636					_SIOFound:
.e636	e8		inx				inx
.e637	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e639	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e63c	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e63e	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.e641	7a		ply				ply
.e642	fa		plx				plx
.e643	68		pla				pla
.e644	60		rts				rts
.e645					SIOLoadCursor:
.e645	48		pha				pha
.e646	ad a1 20	lda $20a1			lda 	yCursor  					; Y Position
.e649	0a		asl a				asl 	a 							; x 2 	(80)
.e64a	0a		asl a				asl 	a 							; x 2 	(160)
.e64b	6d a1 20	adc $20a1			adc 	yCursor 					; x 5 	(200) (CC)
.e64e	85 24		sta $24				sta 	zTemp1
.e650	a9 00		lda #$00			lda 	#0
.e652	85 25		sta $25				sta 	zTemp1+1
.e654	06 24		asl $24				asl 	zTemp1						; x 10
.e656	26 25		rol $25				rol 	zTemp1+1
.e658	06 24		asl $24				asl 	zTemp1						; x 20
.e65a	26 25		rol $25				rol 	zTemp1+1
.e65c	06 24		asl $24				asl 	zTemp1						; x 40
.e65e	26 25		rol $25				rol 	zTemp1+1 					; (CC)
.e660	a5 24		lda $24				lda 	zTemp1 						; add X
.e662	6d a0 20	adc $20a0			adc 	xCursor
.e665	aa		tax				tax
.e666	a5 25		lda $25				lda 	zTemp1+1
.e668	69 00		adc #$00			adc 	#0
.e66a	a8		tay				tay
.e66b	68		pla				pla 								; restore and exit
.e66c	60		rts				rts
.e66d					SIOPrintHex:
.e66d	48		pha				pha
.e66e	48		pha				pha
.e66f	a9 20		lda #$20			lda 	#32
.e671	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.e674	68		pla				pla
.e675	48		pha				pha
.e676	4a		lsr a				lsr 	a
.e677	4a		lsr a				lsr 	a
.e678	4a		lsr a				lsr 	a
.e679	4a		lsr a				lsr 	a
.e67a	20 83 e6	jsr $e683			jsr 	_SIOPHex
.e67d	68		pla				pla
.e67e	20 83 e6	jsr $e683			jsr 	_SIOPHex
.e681	68		pla				pla
.e682	60		rts				rts
.e683					_SIOPHex:
.e683	29 0f		and #$0f			and 	#15
.e685	c9 0a		cmp #$0a			cmp 	#10
.e687	90 02		bcc $e68b			bcc 	_SIOPHex2
.e689	69 06		adc #$06			adc 	#6
.e68b					_SIOPHex2:
.e68b	69 30		adc #$30			adc 	#48
.e68d	4c d5 e4	jmp $e4d5			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e690					TokeniseString:
.e690	a0 00		ldy #$00			ldy 	#0							; source
.e692	a2 00		ldx #$00			ldx 	#0 							; target
.e694					_TokLoop:
.e694	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get first
.e696	f0 5d		beq $e6f5			beq 	_TokExit 					; End, exit.
.e698	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e69a	f0 35		beq $e6d1			beq 	_TokCopy1
.e69c	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e69e	f0 3a		beq $e6da			beq 	_TokCopyString
.e6a0	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e6a2	90 22		bcc $e6c6			bcc 	_TokPunctuation
.e6a4	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e6a6	90 29		bcc $e6d1			bcc 	_TokCopy1
.e6a8	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e6aa	90 1a		bcc $e6c6			bcc 	_TokPunctuation
.e6ac	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e6ae	b0 16		bcs $e6c6			bcs 	_TokPunctuation
.e6b0					_TokWord:
.e6b0	20 fb e6	jsr $e6fb			jsr 	TokeniseSearch 				; search for tokenised word.
.e6b3	b0 16		bcs $e6cb			bcs 	_TokFound 					; if successful, copy it out.
.e6b5					_TokSkip:
.e6b5	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e6b7	c9 41		cmp #$41			cmp 	#"A"
.e6b9	90 d9		bcc $e694			bcc 	_TokLoop
.e6bb	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e6bd	b0 d5		bcs $e694			bcs 	_TokLoop
.e6bf	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6c2	e8		inx				inx
.e6c3	c8		iny				iny
.e6c4	80 ef		bra $e6b5			bra 	_TokSkip
.e6c6					_TokPunctuation:
.e6c6	20 fb e6	jsr $e6fb			jsr 	TokeniseSearch 				; find it.
.e6c9	90 06		bcc $e6d1			bcc 	_TokCopy1 					; if found, just copy 1 character
.e6cb					_TokFound:
.e6cb	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e6ce	e8		inx				inx 								; advance target ; source is already advanced.
.e6cf	80 c3		bra $e694			bra 	_TokLoop 					; do the next character.
.e6d1					_TokCopy1:
.e6d1	b1 24		lda ($24),y			lda 	(zTemp1),y
.e6d3	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6d6	e8		inx				inx
.e6d7	c8		iny				iny
.e6d8	80 ba		bra $e694			bra 	_TokLoop
.e6da					_TokCopyString:
.e6da	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e6dc	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6df	e8		inx				inx 								; skip buffer and first quote.
.e6e0	c8		iny				iny
.e6e1					_TokCSLoop:
.e6e1	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get next character
.e6e3	f0 10		beq $e6f5			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e6e5	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e6e8	e8		inx				inx 								; advance both.
.e6e9	c8		iny				iny
.e6ea	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e6ec	d0 f3		bne $e6e1			bne 	_TokCSLoop
.e6ee	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e6f0	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e6f3	80 9f		bra $e694			bra 	_TokLoop
.e6f5					_TokExit:
.e6f5	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e6f7	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6fa	60		rts				rts
.e6fb					TokeniseSearch:
.e6fb	48		pha				pha 								; save AXY
.e6fc	da		phx				phx
.e6fd	5a		phy				phy
.e6fe	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e700	85 26		sta $26				sta 	zTemp2
.e702	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e704	bd 7a e0	lda $e07a,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e707	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e709	d1 24		cmp ($24),y			cmp 	(zTemp1),y 					; do the characters match.
.e70b	f0 13		beq $e720			beq 	_TSTryFullMatch 			; if so, try the full match.
.e70d					_TSGotoNext:
.e70d	bd 7a e0	lda $e07a,x			lda 	TokenText,x 				; read it
.e710	e8		inx				inx 								; bump index
.e711	0a		asl a				asl 	a 							; shift into C
.e712	90 f9		bcc $e70d			bcc 	_TSGotoNext 				; keep going until read the end character
.e714	e6 26		inc $26				inc 	zTemp2 						; bump the current token pointer.
.e716	bd 7a e0	lda $e07a,x			lda 	TokenText,x 				; look at the first character of the next token
.e719	d0 e9		bne $e704			bne 	_TSNext 					; if non-zero, go to the next.
.e71b					_TSFail:
.e71b	7a		ply				ply 								; fail.
.e71c	fa		plx				plx
.e71d	68		pla				pla
.e71e	18		clc				clc 				 				; return with carry clear.
.e71f	60		rts				rts
.e720					_TSTryFullMatch:
.e720	da		phx				phx									; save X and Y.
.e721	5a		phy				phy
.e722					_TSFullMatch:
.e722	bd 7a e0	lda $e07a,x			lda 	TokenText,x 				; compare the 7 bits.
.e725	29 7f		and #$7f			and 	#$7F
.e727	d1 24		cmp ($24),y			cmp 	(zTemp1),y
.e729	d0 15		bne $e740			bne 	_TSFullFail 				; different, this one doesn't match.
.e72b	bd 7a e0	lda $e07a,x			lda 	TokenText,x
.e72e	e8		inx				inx 								; advance to next character
.e72f	c8		iny				iny
.e730	0a		asl a				asl 	a 							; bit 7 of token text in C
.e731	90 ef		bcc $e722			bcc 	_TSFullMatch
.e733	84 27		sty $27				sty 	zTemp2+1 					; save the Y after last
.e735	68		pla				pla 								; so we don't restore Y
.e736	68		pla				pla 								; or X from the full test.
.e737	7a		ply				ply 								; restore original Y and X and A
.e738	fa		plx				plx
.e739	68		pla				pla
.e73a	a5 26		lda $26				lda 	zTemp2 						; and return token ID in A
.e73c	a4 27		ldy $27				ldy 	zTemp2+1 					; Y after the tokenised text.
.e73e	38		sec				sec 								; with carry set.
.e73f	60		rts				rts
.e740					_TSFullFail:
.e740	7a		ply				ply 								; restore Y and X
.e741	fa		plx				plx
.e742	80 c9		bra $e70d			bra 	_TSGotoNext 				; and go to the next token to test.
.e744					TokeniseTest:
.e744	a9 50		lda #$50			lda 	#TTString & $FF
.e746	85 24		sta $24				sta 	zTemp1
.e748	a9 e7		lda #$e7			lda 	#TTString >> 8
.e74a	85 25		sta $25				sta 	zTemp1+1
.e74c	20 90 e6	jsr $e690			jsr 	TokeniseString
.e74f	ea		nop				nop
.e750					TTString:
>e750	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e758	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: general/editor.asm

.e765					EditProgram:
.e765	a2 00		ldx #$00			ldx 	#0
.e767	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; get the line number
.e76a	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; upper bytes must be zero
.e76d	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e770	d0 37		bne $e7a9			bne 	_EPBadLine
.e772	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; lower bytes must be non-zero
.e775	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e778	f0 2f		beq $e7a9			beq 	_EPBadLine
.e77a	5a		phy				phy 								; save position
.e77b	20 b5 e7	jsr $e7b5			jsr 	EDFindLine 					; locate the line.
.e77e	90 12		bcc $e792			bcc 	_EPNotFound 				; skip delete if not found.
.e780	a5 24		lda $24				lda 	zTemp1 						; save the target address, as we will
.e782	48		pha				pha 								; insert the line, if done, at the same
.e783	a5 25		lda $25				lda 	zTemp1+1 					; place
.e785	48		pha				pha
.e786	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; clear all vars, make sure zLowMemory is right.
.e789	20 ec e7	jsr $e7ec			jsr 	EDDeleteLine 				; delete the line at zTemp1
.e78c	68		pla				pla 								; restore the target address.
.e78d	85 25		sta $25				sta 	zTemp1+1
.e78f	68		pla				pla
.e790	85 24		sta $24				sta 	zTemp1
.e792					_EPNotFound
.e792	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e795	7a		ply				ply 								; get pointer back
.e796					_EPSkipSpaces:
.e796	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get character
.e798	f0 0c		beq $e7a6			beq 	_EPGoWarmStart 				; EOL, just delete, so warm start.
.e79a	c8		iny				iny
.e79b	c9 20		cmp #$20			cmp 	#32
.e79d	f0 f7		beq $e796			beq 	_EPSkipSpaces
.e79f	88		dey				dey
.e7a0	20 0c e8	jsr $e80c			jsr 	EDInsertLine 				; insert the line.
.e7a3	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e7a6					_EPGoWarmStart:
.e7a6	4c 73 f1	jmp $f173			jmp 	WarmStart
.e7a9					_EPBadLine:
.e7a9	20 66 e1	jsr $e166			jsr 	ReportError
>e7ac	42 41 44 20 4c 49 4e 45				.text 	"BAD LINE",$00
>e7b4	00
.e7b5					EDFindLine:
.e7b5	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set zTemp1
.e7b7	85 24		sta $24				sta 	zTemp1
.e7b9	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e7bb	85 25		sta $25				sta 	zTemp1+1
.e7bd					_EDFLLoop:
.e7bd	a0 00		ldy #$00			ldy 	#0 							; reached the end
.e7bf	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7c1	f0 25		beq $e7e8			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.e7c3	c8		iny				iny
.e7c4	38		sec				sec
.e7c5	ad 00 04	lda $0400			lda 	evalStack+0					; subtract the current from the target
.e7c8	f1 24		sbc ($24),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.e7ca	aa		tax				tax	 								; this will return 10.
.e7cb	ad 01 04	lda $0401			lda 	evalStack+1
.e7ce	c8		iny				iny
.e7cf	f1 24		sbc ($24),y			sbc 	(zTemp1),y
.e7d1	90 15		bcc $e7e8			bcc 	_EDFLFail					; if target < current then failed.
.e7d3	d0 04		bne $e7d9			bne 	_EDFLNext 					; if non-zero then goto next
.e7d5	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.e7d7	f0 11		beq $e7ea			beq 	_EDFLFound
.e7d9					_EDFLNext:
.e7d9	a0 00		ldy #$00			ldy 	#0 							; get offset
.e7db	18		clc				clc
.e7dc	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7de	65 24		adc $24				adc 	zTemp1 						; add to pointer
.e7e0	85 24		sta $24				sta 	zTemp1
.e7e2	90 d9		bcc $e7bd			bcc 	_EDFLLoop
.e7e4	e6 25		inc $25				inc 	zTemp1+1 					; carry out.
.e7e6	80 d5		bra $e7bd			bra 	_EDFLLoop
.e7e8					_EDFLFail:
.e7e8	18		clc				clc
.e7e9	60		rts				rts
.e7ea					_EDFLFound:
.e7ea	38		sec				sec
.e7eb	60		rts				rts
.e7ec					EDDeleteLine:
.e7ec	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.e7ee	a2 00		ldx #$00			ldx 	#0
.e7f0	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7f2	a8		tay				tay 								; put in Y
.e7f3					_EDDelLoop:
.e7f3	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get it
.e7f5	81 24		sta ($24,x)			sta 	(zTemp1,x) 					; write it.
.e7f7	a5 24		lda $24				lda 	zTemp1 						; check if pointer has reached the end of
.e7f9	c5 22		cmp $22				cmp		zLowMemory 					; low memory. We will have copied down an
.e7fb	d0 06		bne $e803			bne 	_EDDelNext 					; extra pile of stuff - technically should
.e7fd	a5 25		lda $25				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.e7ff	c5 23		cmp $23				cmp 	zLowMemory+1				; doesn't really matter.
.e801	f0 08		beq $e80b			beq		_EDDelExit
.e803					_EDDelNext:
.e803	e6 24		inc $24				inc 	zTemp1 						; go to next byte.
.e805	d0 ec		bne $e7f3			bne 	_EDDelLoop
.e807	e6 25		inc $25				inc 	zTemp1+1
.e809	80 e8		bra $e7f3			bra 	_EDDelLoop
.e80b					_EDDelExit:
.e80b	60		rts				rts
.e80c					EDInsertLine:
.e80c	98		tya				tya 								; make zCurrentLine point to the actual new line.
.e80d	18		clc				clc
.e80e	65 20		adc $20				adc 	zCurrentLine
.e810	85 20		sta $20				sta 	zCurrentLine
.e812	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.e814					_EDGetLength:
.e814	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e816	c8		iny				iny
.e817	c9 00		cmp #$00			cmp 	#0
.e819	d0 f9		bne $e814			bne 	_EDGetLength
.e81b	88		dey				dey 								; fix up.
.e81c	98		tya				tya
.e81d	18		clc				clc
.e81e	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.e820	48		pha				pha 								; save total size (e.g. offset)
.e821	a8		tay				tay 								; in Y
.e822	a2 00		ldx #$00			ldx 	#0
.e824					_EDInsLoop:
.e824	a1 22		lda ($22,x)			lda 	(zLowMemory,x)				; copy it up
.e826	91 22		sta ($22),y			sta 	(zLowMemory),y
.e828	a5 22		lda $22				lda 	zLowMemory 					; reached the insert point (zTemp1)
.e82a	c5 24		cmp $24				cmp 	zTemp1
.e82c	d0 06		bne $e834			bne 	_EDINextShift
.e82e	a5 23		lda $23				lda 	zLowMemory+1
.e830	c5 25		cmp $25				cmp 	zTemp1+1
.e832	f0 0a		beq $e83e			beq 	_EDIShiftOver
.e834					_EDINextShift:
.e834	a5 22		lda $22				lda 	zLowMemory 					; decrement the copy pointer.
.e836	d0 02		bne $e83a			bne 	_EDINoBorrow
.e838	c6 23		dec $23				dec 	zLowMemory+1
.e83a					_EDINoBorrow:
.e83a	c6 22		dec $22				dec 	zLowMemory
.e83c	80 e6		bra $e824			bra 	_EDInsLoop
.e83e					_EDIShiftOver:
.e83e	68		pla				pla 								; this is the size + others, e.g. offset
.e83f	a0 00		ldy #$00			ldy 	#0
.e841	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write that out.
.e843	ad 00 04	lda $0400			lda 	evalStack+0 				; write LIne# out
.e846	c8		iny				iny
.e847	91 22		sta ($22),y			sta 	(zLowMemory),y
.e849	ad 01 04	lda $0401			lda 	evalStack+1
.e84c	c8		iny				iny
.e84d	91 22		sta ($22),y			sta 	(zLowMemory),y
.e84f	c8		iny				iny 								; where the code goes.
.e850	a2 00		ldx #$00			ldx 	#0 							; comes from
.e852					_EDICopyCode:
.e852	a1 20		lda ($20,x)			lda 	(zCurrentLine,x)			; read from the current line
.e854	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write out
.e856	c8		iny				iny 								; bump pointers
.e857	e6 20		inc $20				inc 	zCurrentLine
.e859	c9 00		cmp #$00			cmp 	#0 							; until zero copied
.e85b	d0 f5		bne $e852			bne 	_EDICopyCode
.e85d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e85e					BFUNC_Add:
.e85e	18		clc				clc
.e85f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e862	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e865	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e868	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e86b	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e86e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e871	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e874	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e877	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e87a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e87d	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e880	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e883	60		rts				rts
.e884					BFUNC_Subtract:
.e884	38		sec				sec
.e885	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e888	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e88b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e88e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e891	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e894	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e897	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e89a	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e89d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8a0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8a3	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e8a6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8a9	60		rts				rts
.e8aa					BFUNC_String:
.e8aa	20 5e e8	jsr $e85e			jsr 	BFUNC_Add
.e8ad	60		rts				rts
.e8ae					BFUNC_ByteInd:
.e8ae	20 5e e8	jsr $e85e			jsr 	BFUNC_Add
.e8b1	20 c2 e3	jsr $e3c2			jsr 	EVALReadByteIndirect
.e8b4	60		rts				rts
.e8b5					BFUNC_WordInd:
.e8b5	20 5e e8	jsr $e85e			jsr 	BFUNC_Add
.e8b8	20 eb e3	jsr $e3eb			jsr 	EVALReadWordIndirect
.e8bb	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e8bc					BFUNC_And:
.e8bc	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8bf	3d 04 04	and $0404,x			and 	evalStack+4,x
.e8c2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8c5	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8c8	3d 05 04	and $0405,x			and 	evalStack+5,x
.e8cb	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8ce	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8d1	3d 06 04	and $0406,x			and 	evalStack+6,x
.e8d4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8d7	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8da	3d 07 04	and $0407,x			and 	evalStack+7,x
.e8dd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8e0	60		rts				rts
.e8e1					BFUNC_Or:
.e8e1	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8e4	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e8e7	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8ea	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8ed	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e8f0	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8f3	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8f6	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e8f9	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8fc	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8ff	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e902	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e905	60		rts				rts
.e906					BFUNC_Xor:
.e906	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e909	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e90c	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e90f	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e912	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e915	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e918	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e91b	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e91e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e921	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e924	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e927	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e92a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e92b					BFUNC_Multiply:
.e92b	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e92e	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e931	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e934	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e937	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e93a	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e93d	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e940	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e943	a9 00		lda #$00			lda 	#0
.e945	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e948	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e94b	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e94e	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e951					_BFMMultiply:
.e951	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e954	29 01		and #$01			and 	#1
.e956	f0 03		beq $e95b			beq 	_BFMNoAdd
.e958	20 5e e8	jsr $e85e			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e95b					_BFMNoAdd:
.e95b	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e95e	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e961	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e964	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e967	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e96a	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e96d	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e970	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e973	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e976	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e979	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e97c	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e97f	d0 d0		bne $e951			bne 	_BFMMultiply
.e981	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e982					BFUNC_Divide:
.e982	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e985	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e988	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e98b	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e98e	d0 14		bne $e9a4			bne 	_BFDOkay
.e990	20 66 e1	jsr $e166			jsr 	ReportError
>e993	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>e99b	20 42 59 20 5a 45 52 4f 00
.e9a4					_BFDOkay:
.e9a4	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e9a6	8d 98 20	sta $2098			sta 	Temp1 						; Q/Dividend/Left in +0
.e9a9	8d 99 20	sta $2099			sta 	Temp1+1 					; M/Divisor/Right in +4
.e9ac	8d 9a 20	sta $209a			sta 	Temp1+2
.e9af	8d 9b 20	sta $209b			sta 	Temp1+3
.e9b2	8d 9c 20	sta $209c			sta 	SignCount 					; Count of signs.
.e9b5	20 20 ea	jsr $ea20			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e9b8	da		phx				phx
.e9b9	e8		inx				inx
.e9ba	e8		inx				inx
.e9bb	e8		inx				inx
.e9bc	e8		inx				inx
.e9bd	20 20 ea	jsr $ea20			jsr 	BFUNC_Negate
.e9c0	fa		plx				plx
.e9c1	5a		phy				phy 								; Y is the counter
.e9c2	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e9c4					_BFDLoop:
.e9c4	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e9c7	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e9ca	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e9cd	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e9d0	2e 98 20	rol $2098			rol 	Temp1
.e9d3	2e 99 20	rol $2099			rol 	Temp1+1
.e9d6	2e 9a 20	rol $209a			rol 	Temp1+2
.e9d9	2e 9b 20	rol $209b			rol 	Temp1+3
.e9dc	38		sec				sec
.e9dd	ad 98 20	lda $2098			lda 	Temp1+0 					; Calculate A-M on stack.
.e9e0	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e9e3	48		pha				pha
.e9e4	ad 99 20	lda $2099			lda 	Temp1+1
.e9e7	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e9ea	48		pha				pha
.e9eb	ad 9a 20	lda $209a			lda 	Temp1+2
.e9ee	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e9f1	48		pha				pha
.e9f2	ad 9b 20	lda $209b			lda 	Temp1+3
.e9f5	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e9f8	90 19		bcc $ea13			bcc 	_BFDNoAdd
.e9fa	8d 9b 20	sta $209b			sta 	Temp1+3 					; update A
.e9fd	68		pla				pla
.e9fe	8d 9a 20	sta $209a			sta 	Temp1+2
.ea01	68		pla				pla
.ea02	8d 99 20	sta $2099			sta 	Temp1+1
.ea05	68		pla				pla
.ea06	8d 98 20	sta $2098			sta 	Temp1+0
.ea09	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.ea0c	09 01		ora #$01			ora 	#1
.ea0e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea11	80 03		bra $ea16			bra 	_BFDNext
.ea13					_BFDNoAdd:
.ea13	68		pla				pla 								; Throw away the intermediate calculations
.ea14	68		pla				pla
.ea15	68		pla				pla
.ea16					_BFDNext:
.ea16	88		dey				dey
.ea17	d0 ab		bne $e9c4			bne 	_BFDLoop
.ea19	7a		ply				ply 								; restore Y and exit
.ea1a	4e 9c 20	lsr $209c			lsr 	SignCount 					; if sign count odd,
.ea1d	b0 06		bcs $ea25			bcs		BFUNC_NegateAlways 			; negate the result
.ea1f	60		rts				rts
.ea20					BFUNC_Negate:
.ea20	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ea23	10 24		bpl $ea49			bpl 	BFNExit
.ea25					BFUNC_NegateAlways:
.ea25	38		sec				sec
.ea26	a9 00		lda #$00			lda 	#0
.ea28	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.ea2b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea2e	a9 00		lda #$00			lda 	#0
.ea30	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.ea33	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea36	a9 00		lda #$00			lda 	#0
.ea38	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.ea3b	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea3e	a9 00		lda #$00			lda 	#0
.ea40	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.ea43	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea46	ee 9c 20	inc $209c			inc 	SignCount
.ea49					BFNExit:
.ea49	60		rts				rts
.ea4a					BFUNC_Modulus:
.ea4a	20 82 e9	jsr $e982			jsr 	BFUNC_Divide 				; start with division.
.ea4d	ad 98 20	lda $2098			lda 	Temp1+0 					; copy remainder
.ea50	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea53	ad 99 20	lda $2099			lda 	Temp1+1
.ea56	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea59	ad 9a 20	lda $209a			lda 	Temp1+2
.ea5c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea5f	ad 9b 20	lda $209b			lda 	Temp1+3
.ea62	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea65	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.ea66					BFUNC_Equals:
.ea66	18		clc				clc
.ea67	80 01		bra $ea6a			bra 	BFUNC_EqualCheck
.ea69					BFUNC_NotEquals:
.ea69	38		sec				sec
.ea6a					BFUNC_EqualCheck:
.ea6a	08		php				php									; save invert flag
.ea6b	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.ea6e	cd 04 04	cmp $0404			cmp 	evalStack+4
.ea71	d0 1c		bne $ea8f			bne 	COMP_Fail
.ea73	ad 01 04	lda $0401			lda 	evalStack+1
.ea76	cd 05 04	cmp $0405			cmp 	evalStack+5
.ea79	d0 14		bne $ea8f			bne 	COMP_Fail
.ea7b	ad 02 04	lda $0402			lda 	evalStack+2
.ea7e	cd 06 04	cmp $0406			cmp 	evalStack+6
.ea81	d0 0c		bne $ea8f			bne 	COMP_Fail
.ea83	ad 03 04	lda $0403			lda 	evalStack+3
.ea86	cd 07 04	cmp $0407			cmp 	evalStack+7
.ea89	d0 04		bne $ea8f			bne 	COMP_Fail
.ea8b					COMP_Succeed:
.ea8b	a9 ff		lda #$ff			lda 	#$FF
.ea8d	80 02		bra $ea91			bra 	COMP_SetResult
.ea8f					COMP_Fail:
.ea8f	a9 00		lda #$00			lda 	#0 							; here return 0
.ea91					COMP_SetResult:
.ea91	28		plp				plp 								; but if CS
.ea92	90 02		bcc $ea96			bcc 	COMP_Accept
.ea94	49 ff		eor #$ff			eor 	#$FF 						; invert that
.ea96					COMP_Accept:
.ea96	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.ea99	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea9c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea9f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eaa2	60		rts				rts
.eaa3					BFUNC_Less:
.eaa3	18		clc				clc
.eaa4	80 01		bra $eaa7			bra 	BFUNC_LessCheck
.eaa6					BFUNC_GreaterEqual:
.eaa6	38		sec				sec
.eaa7					BFUNC_LessCheck:
.eaa7	08		php				php
.eaa8	38		sec				sec
.eaa9	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.eaac	ed 04 04	sbc $0404			sbc 	evalStack+4
.eaaf	ad 01 04	lda $0401			lda 	evalStack+1
.eab2	ed 05 04	sbc $0405			sbc 	evalStack+5
.eab5	ad 02 04	lda $0402			lda 	evalStack+2
.eab8	ed 06 04	sbc $0406			sbc 	evalStack+6
.eabb	ad 03 04	lda $0403			lda 	evalStack+3
.eabe	ed 07 04	sbc $0407			sbc 	evalStack+7
.eac1	30 c8		bmi $ea8b			bmi 	COMP_Succeed
.eac3	80 ca		bra $ea8f			bra 	COMP_Fail
.eac5					BFUNC_Greater:
.eac5	18		clc				clc
.eac6	80 01		bra $eac9			bra 	BFUNC_GreaterCheck
.eac8					BFUNC_LessEqual:
.eac8	38		sec				sec
.eac9					BFUNC_GreaterCheck:
.eac9	08		php				php
.eaca	38		sec				sec
.eacb	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.eace	ed 00 04	sbc $0400			sbc 	evalStack+0
.ead1	ad 05 04	lda $0405			lda 	evalStack+5
.ead4	ed 01 04	sbc $0401			sbc 	evalStack+1
.ead7	ad 06 04	lda $0406			lda 	evalStack+6
.eada	ed 02 04	sbc $0402			sbc 	evalStack+2
.eadd	ad 07 04	lda $0407			lda 	evalStack+7
.eae0	ed 03 04	sbc $0403			sbc 	evalStack+3
.eae3	30 a6		bmi $ea8b			bmi 	COMP_Succeed
.eae5	80 a8		bra $ea8f			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.eae7					BFUNC_StringCompare:
.eae7	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.eaea	85 24		sta $24				sta 	zTemp1
.eaec	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eaef	85 25		sta $25				sta 	zTemp1+1
.eaf1	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.eaf4	85 26		sta $26				sta 	zTemp2
.eaf6	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.eaf9	85 27		sta $27				sta 	zTemp2+1
.eafb	5a		phy				phy
.eafc	a0 00		ldy #$00			ldy 	#0
.eafe					_BFSCLoop:
.eafe	b1 24		lda ($24),y			lda 	(zTemp1),y 					; comparison
.eb00	38		sec				sec
.eb01	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.eb03	d0 15		bne $eb1a			bne		_BFSCDifferent 				; return different result.
.eb05	c8		iny				iny
.eb06	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.eb08	d0 f4		bne $eafe			bne 	_BFSCLoop
.eb0a	7a		ply				ply
.eb0b	a9 00		lda #$00			lda 	#0
.eb0d					_BFSCSetAll:
.eb0d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb10	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb13	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb16	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb19	60		rts				rts
.eb1a					_BFSCDifferent:
.eb1a	7a		ply				ply
.eb1b	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.eb1d	90 ee		bcc $eb0d			bcc 	_BFSCSetAll
.eb1f	a9 00		lda #$00			lda 	#0 							; set all zero
.eb21	20 0d eb	jsr $eb0d			jsr 	_BFSCSetAll
.eb24	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.eb27	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.eb28					UNARY_Len:
.eb28	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb2b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb2e	85 24		sta $24				sta 	zTemp1
.eb30	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb33	85 25		sta $25				sta 	zTemp1+1
.eb35	5a		phy				phy
.eb36	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.eb38					_ULGetLength:
.eb38	b1 24		lda ($24),y			lda 	(zTemp1),y 					; read character
.eb3a	f0 1d		beq $eb59			beq 	_ULFoundEOL 				; found end of line.
.eb3c	c8		iny				iny
.eb3d	d0 f9		bne $eb38			bne 	_ULGetLength 				; scan 256 only.
.eb3f	20 66 e1	jsr $e166			jsr 	ReportError
>eb42	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>eb4a	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.eb59					_ULFoundEOL:
.eb59	98		tya				tya 								; length in A, restore Y
.eb5a	7a		ply				ply
.eb5b					UNARY_ReturnByte:
.eb5b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb5e	a9 00		lda #$00			lda 	#0 							; clear the rests
.eb60	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb63	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb66	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb69	60		rts				rts
.eb6a					UNARY_Ch:
.eb6a	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb6d	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb70	85 24		sta $24				sta 	zTemp1
.eb72	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb75	85 25		sta $25				sta 	zTemp1+1
.eb77	5a		phy				phy
.eb78	a0 00		ldy #$00			ldy 	#0 							; now get first character
.eb7a	b1 24		lda ($24),y			lda 	(zTemp1),y
.eb7c	7a		ply				ply
.eb7d	80 dc		bra $eb5b			bra 	UNARY_ReturnByte 			; return that byte.
.eb7f					UNARY_Abs:
.eb7f	ea		nop				nop
.eb80	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb83	20 20 ea	jsr $ea20			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.eb86	60		rts				rts
.eb87					UNARY_Top:
.eb87	ad 96 20	lda $2096			lda 	highMemory
.eb8a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb8d	ad 97 20	lda $2097			lda 	highMemory+1
.eb90	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb93	a9 00		lda #$00			lda 	#0
.eb95	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb98	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb9b	60		rts				rts
.eb9c					UNARY_Get:
.eb9c	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort
.eb9f	f0 fb		beq $eb9c			beq 	UNARY_Get
.eba1	20 12 a0	jsr $a012			jsr 	EXTRemoveKeyPressed
.eba4	80 b5		bra $eb5b			bra 	UNARY_ReturnByte
.eba6					UNARY_Page:
.eba6	a9 00		lda #$00			lda 	#BasicProgram & $FF
.eba8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebab	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ebad	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebb0	a9 00		lda #$00			lda 	#0
.ebb2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ebb5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebb8	60		rts				rts
.ebb9					UNARY_Rnd:
.ebb9	20 c4 eb	jsr $ebc4			jsr 	Random16 					; call 16 bit RNG twice
.ebbc	e8		inx				inx
.ebbd	e8		inx				inx
.ebbe	20 c4 eb	jsr $ebc4			jsr 	Random16
.ebc1	ca		dex				dex
.ebc2	ca		dex				dex
.ebc3	60		rts				rts
.ebc4					Random16:
.ebc4	ad 9e 20	lda $209e			lda 	RandomSeed 					; initialise if nonzero
.ebc7	0d 9f 20	ora $209f			ora 	RandomSeed+1
.ebca	d0 0d		bne $ebd9			bne 	_R16_NoInit
.ebcc	ee 9e 20	inc $209e			inc 	RandomSeed 					; by setting low to 1
.ebcf	5a		phy				phy
.ebd0	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.ebd2					_R16_Setup:
.ebd2	20 c4 eb	jsr $ebc4			jsr 	Random16
.ebd5	88		dey				dey
.ebd6	d0 fa		bne $ebd2			bne 	_R16_Setup
.ebd8	7a		ply				ply
.ebd9					_R16_NoInit:
.ebd9	4e 9f 20	lsr $209f			lsr 	RandomSeed+1				; shift seed right
.ebdc	6e 9e 20	ror $209e			ror 	RandomSeed
.ebdf	90 08		bcc $ebe9			bcc 	_R16_NoXor
.ebe1	ad 9f 20	lda $209f			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.ebe4	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ebe6	8d 9f 20	sta $209f			sta 	RandomSeed+1
.ebe9					_R16_NoXor:
.ebe9	ad 9e 20	lda $209e			lda 	RandomSeed					; copy result to evaluate stack.
.ebec	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebef	ad 9f 20	lda $209f			lda 	RandomSeed+1
.ebf2	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebf5	60		rts				rts
.ebf6					UNARY_IOAddr:
.ebf6	a9 0f		lda #$0f			lda 	#$0F
.ebf8	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebfb	a9 fd		lda #$fd			lda 	#$FD
.ebfd	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec00	a9 30		lda #$30			lda 	#$30
.ec02	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec05	a9 00		lda #$00			lda 	#$00
.ec07	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec0a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.ec0b					COMMAND_Run:
.ec0b	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; clear everything for a new run.
.ec0e	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.ec10	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.ec12	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.ec14	84 21		sty $21				sty 	zCurrentLine+1
.ec16					CRUNNewLine:
.ec16	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.ec18	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ec1a	f0 78		beq $ec94			beq 	COMMAND_End 				; if zero, off end of program so stop.
.ec1c	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.ec1e					CRUNNextInstruction:
.ec1e	ee a2 20	inc $20a2			inc 	breakCheckCount 			; don't check every time, might be slow.
.ec21	ad a2 20	lda $20a2			lda 	breakCheckCount
.ec24	29 1f		and #$1f			and 	#$1F 						; checking once in 32.
.ec26	f0 0e		beq $ec36			beq 	_CRUNNoCheck
.ec28	20 1a a0	jsr $a01a			jsr 	EXTCheckBreak
.ec2b	f0 09		beq $ec36			beq 	_CRUNNoCheck
.ec2d	20 66 e1	jsr $e166			jsr 	ReportError
>ec30	42 52 45 41 4b 00				.text 	"BREAK",$00
.ec36					_CRUNNoCheck:
.ec36	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.ec38	8d 9d 20	sta $209d			sta 	StringBufferPos
.ec3b	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.ec3d	f0 0b		beq $ec4a			beq 	CRUNNextLine 				; if zero, then end of line.
.ec3f					CRUNNotEndOfLine:
.ec3f	c9 20		cmp #$20			cmp 	#' '
.ec41	f0 04		beq $ec47			beq 	CRUNSkipLoop
.ec43	c9 8e		cmp #$8e			cmp 	#KW_Colon 					; check for a colon first.
.ec45	d0 1b		bne $ec62			bne 	CRUNExecuteOne 				; if not that, execute the token.
.ec47					CRUNSkipLoop:
.ec47	c8		iny				iny		 							; if colon, skip it and loop round.
.ec48	80 d4		bra $ec1e			bra 	CRUNNextInstruction
.ec4a					CRUNNextLine:
.ec4a	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.ec4c	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.ec4e	f0 0f		beq $ec5f			beq		CRUNWarmStart
.ec50	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.ec52	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ec54	18		clc				clc
.ec55	65 20		adc $20				adc 	zCurrentLine
.ec57	85 20		sta $20				sta 	zCurrentLine
.ec59	90 bb		bcc $ec16			bcc 	CRUNNewLine
.ec5b	e6 21		inc $21				inc 	zCurrentLine+1
.ec5d	80 b7		bra $ec16			bra 	CRUNNewLine
.ec5f					CRUNWarmStart:
.ec5f	4c 73 f1	jmp $f173			jmp 	WarmStart
.ec62					CRUNExecuteOne:
.ec62	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.ec64	10 21		bpl $ec87			bpl		_CRUNX1TryLet
.ec66	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.ec68	f0 1d		beq $ec87			beq 	_CRUNX1TryLet
.ec6a	c9 80		cmp #$80			cmp 	#KW_PLING
.ec6c	f0 19		beq $ec87			beq 	_CRUNX1TryLet
.ec6e	c9 96		cmp #$96			cmp 	#KW_QUESTION
.ec70	f0 15		beq $ec87			beq 	_CRUNX1TryLet
.ec72	c8		iny				iny 								; skip over loaded token
.ec73	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.ec74	8d 99 20	sta $2099			sta 	Temp1+1 					; this is the low byte into the KVT
.ec77	8a		txa				txa
.ec78	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.ec7a	8d 9a 20	sta $209a			sta 	Temp1+2
.ec7d	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.ec7f	8d 98 20	sta $2098			sta 	Temp1+0
.ec82	20 98 20	jsr $2098			jsr 	Temp1 						; call instruction
.ec85	80 97		bra $ec1e			bra 	CRUNNextInstruction 		; do next instruction.
.ec87					_CRUNX1TryLet:
.ec87	20 58 ed	jsr $ed58			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.ec8a	80 92		bra $ec1e			bra 	CRUNNextInstruction
.ec8c					COMMAND_Stop:
.ec8c	20 66 e1	jsr $e166			jsr 	ReportError
>ec8f	53 54 4f 50 00					.text 	"STOP",$00
.ec94					COMMAND_End:
.ec94	ad 6b 23	lda $236b			lda 	StartBehaviour 				; running program
.ec97	c9 52		cmp #$52			cmp 	#"R"
.ec99	d0 01		bne $ec9c			bne 	_CEWarmStart
>ec9b	02						.byte 	2
.ec9c					_CEWarmStart:
.ec9c	4c 73 f1	jmp $f173			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.ec9f					COMMAND_Assert:
.ec9f	20 08 e2	jsr $e208			jsr 	EvaluateBase 				; evaluate the expression
.eca2	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.eca5	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.eca8	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ecab	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ecae	d0 12		bne $ecc2			bne 	_CMDAExit
.ecb0	ea		nop				nop
.ecb1	20 66 e1	jsr $e166			jsr 	ReportError
>ecb4	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>ecbc	41 49 4c 45 44 00
.ecc2					_CMDAExit:
.ecc2	60		rts				rts
.ecc3					COMMAND_Rem:
.ecc3	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.ecc5	f0 05		beq $eccc			beq 	_CREMExit 					; End of line, then exit.
.ecc7	c8		iny				iny 								; something to skip
.ecc8	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; if not a colon
.ecca	d0 f7		bne $ecc3			bne 	COMMAND_Rem 				; keep searching
.eccc					_CREMExit:
.eccc	60		rts				rts
.eccd					COMMAND_NewExec:
.eccd	20 d3 ec	jsr $ecd3			jsr 	COMMAND_NewCode
.ecd0	4c 73 f1	jmp $f173			jmp 	WarmStart
.ecd3					COMMAND_NewCode:
.ecd3	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.ecd5	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.ecd8	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.ecdb	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.ecdd	8d 96 20	sta $2096			sta 	HighMemory
.ece0	a9 80		lda #$80			lda 	#endMemory >> 8
.ece2	8d 97 20	sta $2097			sta 	HighMemory+1
.ece5	60		rts				rts
.ece6					COMMAND_Clear:
.ece6	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.ece8					_CCClearVar:
.ece8	a9 00		lda #$00			lda 	#$00
.ecea	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.eced	e8		inx				inx
.ecee	e0 6c		cpx #$6c			cpx 	#27*4
.ecf0	10 f6		bpl $ece8			bpl 	_CCClearVar
.ecf2	a9 00		lda #$00			lda 	#0 							; reset BASIC stack index
.ecf4	8d a3 20	sta $20a3			sta 	basicStackIndex
.ecf7	a9 ff		lda #$ff			lda 	#$FF 						; put invalid token on TOS, so when pulled.
.ecf9	8d 00 02	sta $0200			sta 	basicStack 					; causes an error.
.ecfc	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.ecfe	85 22		sta $22				sta 	zLowMemory
.ed00	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ed02	85 23		sta $23				sta 	zLowMemory+1
.ed04					_CCFindEnd:
.ed04	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.ed06	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.ed08	f0 0b		beq $ed15			beq 	_CCFoundEnd
.ed0a	18		clc				clc 								; go to next line.
.ed0b	65 22		adc $22				adc 	zLowMemory
.ed0d	85 22		sta $22				sta 	zLowMemory
.ed0f	90 f3		bcc $ed04			bcc 	_CCFindEnd
.ed11	e6 23		inc $23				inc 	zLowMemory+1
.ed13	80 ef		bra $ed04			bra 	_CCFindEnd
.ed15					_CCFoundEnd:
.ed15	e6 22		inc $22				inc 	zLowMemory 					; variables etc. start after end of program.
.ed17	d0 02		bne $ed1b			bne 	_CCNoCarry 					; skip over zero end offset.
.ed19	e6 23		inc $23				inc 	zLowMemory+1
.ed1b					_CCNoCarry:
.ed1b	60		rts				rts
.ed1c					COMMAND_OldExec:
.ed1c	20 22 ed	jsr $ed22			jsr 	COMMAND_OldCode
.ed1f	4c 73 f1	jmp $f173			jmp 	WarmStart
.ed22					COMMAND_OldCode:
.ed22	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.ed24	85 22		sta $22				sta 	zLowMemory
.ed26	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ed28	85 23		sta $23				sta 	zLowMemory+1
.ed2a	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.ed2c					_COScan:
.ed2c	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; look at next byte pair
.ed2e	c8		iny				iny
.ed2f	f0 0d		beq $ed3e			beq 	_COFail 					; can't find marker, corrupted maybe ?
.ed31	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.ed33	d0 f7		bne $ed2c			bne 	_COScan
.ed35	98		tya				tya 								; Y is the new offset to the next instruction
.ed36	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.ed38	91 22		sta ($22),y			sta 	(zLowMemory),y
.ed3a	20 e6 ec	jsr $ece6			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.ed3d	60		rts				rts
.ed3e					_COFail:
.ed3e	20 66 e1	jsr $e166			jsr 	ReportError
>ed41	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>ed49	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ed58					COMMAND_Let:
.ed58	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ed5a	f0 58		beq $edb4			beq 	_CLESyntax
.ed5c	c8		iny				iny
.ed5d	c9 20		cmp #$20			cmp 	#32
.ed5f	f0 f7		beq $ed58			beq 	COMMAND_Let
.ed61	88		dey				dey
.ed62	c9 96		cmp #$96			cmp 	#KW_QUESTION				; check for first being indirect.
.ed64	f0 51		beq $edb7			beq 	_CLEIndirect 				; e.g. !x = 42
.ed66	c9 80		cmp #$80			cmp 	#KW_PLING
.ed68	f0 4d		beq $edb7			beq 	_CLEIndirect
.ed6a	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed6c	f0 49		beq $edb7			beq 	_CLEIndirect
.ed6e	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ed70	20 1b e4	jsr $e41b			jsr 	VARReference 				; get a variable reference.
.ed73	a5 24		lda $24				lda 	zTemp1 						; copy into target addr
.ed75	85 28		sta $28				sta 	zTargetAddr
.ed77	a5 25		lda $25				lda 	zTemp1+1
.ed79	85 29		sta $29				sta 	zTargetAddr+1
.ed7b	a5 26		lda $26				lda 	zTemp1+2
.ed7d	85 2a		sta $2a				sta 	zTargetAddr+2
.ed7f	a5 27		lda $27				lda 	zTemp1+3
.ed81	85 2b		sta $2b				sta 	zTargetAddr+3
.ed83					_CLEGetBinLHSOp:
.ed83	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ed85	f0 2d		beq $edb4			beq 	_CLESyntax
.ed87	c8		iny				iny
.ed88	c9 20		cmp #$20			cmp 	#' '
.ed8a	f0 f7		beq $ed83			beq 	_CLEGetBinLHSOp
.ed8c	88		dey				dey
.ed8d	c9 96		cmp #$96			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ed8f	f0 45		beq $edd6			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ed91	c9 80		cmp #$80			cmp 	#KW_PLING
.ed93	f0 41		beq $edd6			beq 	_CLEBinaryLHTerm
.ed95	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed97	f0 3d		beq $edd6			beq 	_CLEBinaryLHTerm
.ed99	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ed9b					_CLEWriteToAddress:
.ed9b	48		pha				pha 								; save write-type.
.ed9c	a9 93		lda #$93			lda 	#KW_EQUAL 					; check for '=' sign.
.ed9e	20 ac e1	jsr $e1ac			jsr 	CheckNextCharacter
.eda1	20 08 e2	jsr $e208			jsr 	EvaluateBase 				; evaluate the RHS.
.eda4	68		pla				pla
.eda5	c9 80		cmp #$80			cmp 	#KW_PLING
.eda7	f0 6f		beq $ee18			beq 	_CLEWordWrite
.eda9	c9 96		cmp #$96			cmp 	#KW_QUESTION
.edab	f0 60		beq $ee0d			beq 	_CLEByteWrite
.edad	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.edaf					_ErrorInternal:
.edaf	d0 fe		bne $edaf			bne 	_ErrorInternal
.edb1	4c 35 ee	jmp $ee35			jmp 	_CLEStringWrite
.edb4					_CLESyntax:
.edb4	4c 56 e1	jmp $e156			jmp 	SyntaxError
.edb7					_CLEIndirect:
.edb7	48		pha				pha 								; save operator on stack
.edb8	c8		iny				iny									; advance over cursor
.edb9	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.edbb	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel
.edbe	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.edc1	85 28		sta $28				sta 	zTargetAddr+0
.edc3	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.edc6	85 29		sta $29				sta 	zTargetAddr+1
.edc8	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.edcb	85 2a		sta $2a				sta 	zTargetAddr+2
.edcd	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.edd0	85 2b		sta $2b				sta 	zTargetAddr+3
.edd2	68		pla				pla 								; restore operator.
.edd3	4c 9b ed	jmp $ed9b			jmp 	_CLEWriteToAddress
.edd6					_CLEBinaryLHTerm:
.edd6	48		pha				pha 								; save operator on stack
.edd7	c8		iny				iny 								; skip over it.
.edd8	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.edda	20 04 e2	jsr $e204			jsr 	EvaluateAtomCurrentLevel
.eddd	a5 28		lda $28				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.eddf	85 24		sta $24				sta 	zTemp1 						; a four byte address.....
.ede1	a5 29		lda $29				lda 	zTargetAddr+1
.ede3	85 25		sta $25				sta 	zTemp1+1 					; we only worry about 4 byte value
.ede5	5a		phy				phy 								; save Y
.ede6	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.ede7	a0 00		ldy #$00			ldy 	#0
.ede9	b1 24		lda ($24),y			lda 	(zTemp1),y
.edeb	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.edee	85 28		sta $28				sta 	zTargetAddr+0
.edf0	c8		iny				iny
.edf1	b1 24		lda ($24),y			lda 	(zTemp1),y
.edf3	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.edf6	85 29		sta $29				sta 	zTargetAddr+1
.edf8	c8		iny				iny
.edf9	b1 24		lda ($24),y			lda 	(zTemp1),y
.edfb	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.edfe	85 2a		sta $2a				sta 	zTargetAddr+2
.ee00	c8		iny				iny
.ee01	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee03	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.ee06	85 2b		sta $2b				sta 	zTargetAddr+3
.ee08	7a		ply				ply 								; restore Y
.ee09	68		pla				pla 								; restore the operator.
.ee0a	4c 9b ed	jmp $ed9b			jmp 	_CLEWriteToAddress
.ee0d					_CLEByteWrite:
.ee0d	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ee10	5a		phy				phy 								; write the byte preserving Y
.ee11	a0 00		ldy #$00			ldy 	#0
.ee13	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee15	7a		ply				ply
.ee16	60		rts				rts
.ee17					_CLEByteWriteExt:
.ee17	60		rts				rts
.ee18					_CLEWordWrite:
.ee18	5a		phy				phy
.ee19	a0 00		ldy #$00			ldy 	#0
.ee1b	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ee1e	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee20	c8		iny				iny
.ee21	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee24	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee26	c8		iny				iny
.ee27	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ee2a	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee2c	c8		iny				iny
.ee2d	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ee30	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee32	7a		ply				ply 								; restore Y
.ee33	60		rts				rts
.ee34					_CLEWordWriteExt:
.ee34	60		rts				rts
.ee35					_CLEStringWrite:
.ee35	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.ee38	85 24		sta $24				sta 	zTemp1
.ee3a	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee3d	85 25		sta $25				sta 	zTemp1+1
.ee3f	5a		phy				phy
.ee40	a0 00		ldy #$00			ldy 	#0
.ee42					_CLEStringCopy:
.ee42	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee44	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee46	c9 00		cmp #$00			cmp 	#0
.ee48	f0 16		beq $ee60			beq	 	_CLEStringWritten
.ee4a	c8		iny				iny
.ee4b	d0 f5		bne $ee42			bne 	_CLEStringCopy
.ee4d	20 66 e1	jsr $e166			jsr 	ReportError
>ee50	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>ee58	4e 47 20 43 4f 50 59 00
.ee60					_CLEStringWritten:
.ee60	7a		ply				ply
.ee61	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/if.asm

.ee62					COMMAND_IF:
.ee62	a2 00		ldx #$00			ldx 	#0 							; do test
.ee64	20 08 e2	jsr $e208			jsr 	EvaluateBase
.ee67	ad 00 04	lda $0400			lda 	evalStack+0 				; check if test 0
.ee6a	0d 01 04	ora $0401			ora 	evalStack+1
.ee6d	0d 02 04	ora $0402			ora 	evalStack+2
.ee70	0d 03 04	ora $0403			ora 	evalStack+3
.ee73	f0 01		beq $ee76			beq 	_CIFSkip 					; if not, then skip to ELSE token or EOL.
.ee75					_CIFExit:
.ee75	60		rts				rts
.ee76					_CIFSkip:
.ee76	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; found EOL ?
.ee78	f0 fb		beq $ee75			beq 	_CIFExit
.ee7a	c8		iny				iny 								; is it ELSE
.ee7b	c9 9f		cmp #$9f			cmp 	#KW_ELSE
.ee7d	d0 f7		bne $ee76			bne 	_CIFSkip 					; no, keep going
.ee7f	60		rts				rts
.ee80					COMMAND_THEN:
.ee80	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; find first non space
.ee82	c8		iny				iny
.ee83	c9 20		cmp #$20			cmp 	#" "
.ee85	f0 f9		beq $ee80			beq 	COMMAND_THEN
.ee87	88		dey				dey
.ee88	c9 30		cmp #$30			cmp 	#"0" 						; THEN x is THEN GOTO x
.ee8a	90 07		bcc $ee93			bcc 	_CTHNoBranch
.ee8c	c9 3a		cmp #$3a			cmp 	#"9"+1
.ee8e	b0 03		bcs $ee93			bcs 	_CTHNoBranch
.ee90	4c c8 f0	jmp $f0c8			jmp 	Command_GOTO 				; so do the GOTO code.
.ee93					_CTHNoBranch:
.ee93	60		rts				rts
.ee94					COMMAND_ELSE:
.ee94	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ee96	c8		iny				iny
.ee97	c9 00		cmp #$00			cmp 	#0
.ee99	d0 f9		bne $ee94			bne 	COMMAND_ELSE
.ee9b	88		dey				dey
.ee9c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.ee9d					COMMAND_Print:
.ee9d	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.ee9f	f0 29		beq $eeca			beq 	_CPRExitNL 					; zero end of line.
.eea1	c8		iny				iny
.eea2	c9 20		cmp #$20			cmp 	#' '
.eea4	f0 f7		beq $ee9d			beq 	COMMAND_Print
.eea6	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; colon, end of line
.eea8	f0 20		beq $eeca			beq 	_CPRExitNL
.eeaa	c9 8b		cmp #$8b			cmp 	#KW_COMMA 					; comma, tab
.eeac	f0 0d		beq $eebb			beq 	_CPRTab
.eeae	c9 8f		cmp #$8f			cmp 	#KW_SEMICOLON 				; semicolon ?
.eeb0	d0 1e		bne $eed0			bne 	_CPRNotSemicolon
.eeb2	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.eeb4	f0 19		beq $eecf			beq 	_CPRExit
.eeb6	c9 8e		cmp #$8e			cmp 	#KW_COLON
.eeb8	d0 e3		bne $ee9d			bne 	COMMAND_Print 				; if not, just go back round again
.eeba	60		rts				rts
.eebb	a9 09		lda #$09	_CPRTab:lda 	#9 							; print tab.
.eebd	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.eec0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next.
.eec2	f0 0b		beq $eecf			beq 	_CPRExit 					; exit if 0 or :
.eec4	c9 8e		cmp #$8e			cmp 	#KW_COLON
.eec6	f0 07		beq $eecf			beq 	_CPRExit
.eec8	80 d3		bra $ee9d			bra 	COMMAND_Print
.eeca					_CPRExitNL:
.eeca	a9 0d		lda #$0d			lda 	#13
.eecc	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.eecf					_CPRExit:
.eecf	60		rts				rts
.eed0					_CPRNotSemicolon:
.eed0	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.eed2	f0 2b		beq $eeff			beq 	_CPRNewLine 				; new line
.eed4	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.eed6	d0 2e		bne $ef06			bne 	_CPRNotQuote
.eed8					_CPRPrintText:
.eed8	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.eeda	f0 0a		beq $eee6			beq 	_CPRError 					; if zero no closing quote
.eedc	c8		iny				iny
.eedd	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.eedf	f0 bc		beq $ee9d			beq 	COMMAND_Print 				; go round again.
.eee1	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter 			; print and do next character
.eee4	80 f2		bra $eed8			bra 	_CPRPrintText
.eee6					_CPRError:
.eee6	20 66 e1	jsr $e166			jsr 	ReportError
>eee9	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>eef1	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.eeff					_CPRNewLine:
.eeff	a9 0d		lda #$0d			lda 	#13
.ef01	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.ef04	80 97		bra $ee9d			bra 	COMMAND_Print
.ef06					_CPRNotQuote:
.ef06	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.ef08	d0 11		bne $ef1b			bne 	_CPRNumber 					; print a number.
.ef0a	20 08 e2	jsr $e208			jsr 	EvaluateBase 				; this is the address to print.
.ef0d	5a		phy				phy
.ef0e	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.ef11	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ef14	aa		tax				tax
.ef15	20 a8 e4	jsr $e4a8			jsr 	SIOPrintString
.ef18	7a		ply				ply
.ef19	80 82		bra $ee9d			bra 	COMMAND_Print
.ef1b					_CPRNumber:
.ef1b	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.ef1d	f0 17		beq $ef36			beq 	_CPRHexadecimal
.ef1f	88		dey				dey 								; must be 1st char of expr
.ef20	20 08 e2	jsr $e208			jsr 	EvaluateBase 				; this is the value to print.
.ef23	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.ef26	10 08		bpl $ef30			bpl 	_CPRIsPositive
.ef28	20 25 ea	jsr $ea25			jsr 	BFUNC_NegateAlways 			; negate it
.ef2b	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.ef2d	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.ef30					_CPRIsPositive:
.ef30	20 73 ef	jsr $ef73			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.ef33	4c 9d ee	jmp $ee9d			jmp 	COMMAND_Print
.ef36					_CPRHexadecimal:
.ef36	20 08 e2	jsr $e208			jsr 	EvaluateBase 				; this is the value to print.
.ef39	20 3f ef	jsr $ef3f			jsr 	_CPRPrintRecHex 			; hex version of it.
.ef3c	4c 9d ee	jmp $ee9d			jmp 	COMMAND_Print
.ef3f					_CPRPrintRecHex:
.ef3f	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.ef42	29 0f		and #$0f			and 	#15 						; and put on stack
.ef44	48		pha				pha
.ef45	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.ef47					_CPRShiftDiv:
.ef47	4e 03 04	lsr $0403			lsr 	evalStack+3
.ef4a	6e 02 04	ror $0402			ror 	evalStack+2
.ef4d	6e 01 04	ror $0401			ror		evalStack+1
.ef50	6e 00 04	ror $0400			ror		evalStack+0
.ef53	ca		dex				dex
.ef54	d0 f1		bne $ef47			bne 	_CPRShiftDiv
.ef56	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.ef59	0d 01 04	ora $0401			ora 	evalStack+1
.ef5c	0d 02 04	ora $0402			ora 	evalStack+2
.ef5f	0d 03 04	ora $0403			ora 	evalStack+3
.ef62	f0 03		beq $ef67			beq 	_CPRNoHexRec
.ef64	20 3f ef	jsr $ef3f			jsr 	_CPRPrintRecHex
.ef67					_CPRNoHexRec:
.ef67	68		pla				pla 								; original remainder.
.ef68	c9 0a		cmp #$0a			cmp 	#10
.ef6a	90 02		bcc $ef6e			bcc		_CPRNH2
.ef6c	69 06		adc #$06			adc 	#6
.ef6e	69 30		adc #$30	_CPRNH2:adc 	#48
.ef70	4c d5 e4	jmp $e4d5			jmp 	SIOPrintCharacter
.ef73					CPRPrintInteger:
.ef73	48		pha				pha 								; save on stack.
.ef74	da		phx				phx
.ef75	5a		phy				phy
.ef76	20 7d ef	jsr $ef7d			jsr 	_CPRPrintRec 				; recursive print call
.ef79	7a		ply				ply
.ef7a	fa		plx				plx
.ef7b	68		pla				pla
.ef7c	60		rts				rts
.ef7d					_CPRPrintRec:
.ef7d	a9 0a		lda #$0a			lda 	#10 						; save base
.ef7f	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.ef82	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.ef84	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.ef87	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.ef8a	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.ef8d	20 82 e9	jsr $e982			jsr 	BFUNC_Divide 				; divide by 10.
.ef90	ad 98 20	lda $2098			lda 	Temp1+0		 				; push remainder on stack
.ef93	48		pha				pha
.ef94	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.ef97	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ef9a	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ef9d	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.efa0	f0 03		beq $efa5			beq 	_CPRNoRecurse
.efa2	20 7d ef	jsr $ef7d			jsr 	_CPRPrintRec 				; recursive print.
.efa5					_CPRNoRecurse:
.efa5	68		pla				pla
.efa6	09 30		ora #$30			ora 	#"0"
.efa8	4c d5 e4	jmp $e4d5			jmp 	SIOPrintCharacter
.efab					COMMAND_CLS:
.efab	4c 9a e4	jmp $e49a			jmp 	SIOClearScreen

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.efae					COMMAND_List:
.efae	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look first non space
.efb0	c8		iny				iny
.efb1	c9 20		cmp #$20			cmp 	#' '
.efb3	f0 f9		beq $efae			beq 	COMMAND_List
.efb5	88		dey				dey
.efb6	c9 30		cmp #$30			cmp 	#"0" 						; not digit, list all
.efb8	90 0e		bcc $efc8			bcc 	_CLIAll
.efba	c9 3a		cmp #$3a			cmp 	#"9"+1
.efbc	b0 0a		bcs $efc8			bcs 	_CLIAll
.efbe	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.efc0	20 08 e2	jsr $e208			jsr 	EvaluateBase
.efc3	20 f2 f0	jsr $f0f2			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.efc6	80 09		bra $efd1			bra 	_CLIMain 					; list it.
.efc8					_CLIAll:
.efc8	5a		phy				phy
.efc9	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.efcb	85 28		sta $28				sta 	zTargetAddr
.efcd	a9 23		lda #$23			lda 	#BasicProgram >> 8
.efcf	85 29		sta $29				sta 	zTargetAddr+1
.efd1					_CLIMain:
.efd1	a9 10		lda #$10			lda 	#16 						; print 16 lines
.efd3	85 2a		sta $2a				sta 	zTargetAddr+2
.efd5					_CLLILoop:
.efd5	a0 00		ldy #$00			ldy 	#0
.efd7	b1 28		lda ($28),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.efd9	f0 14		beq $efef			beq 	_CLLIExit
.efdb	20 f3 ef	jsr $eff3			jsr 	CLIOneLine 					; list one line.
.efde	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.efe0	18		clc				clc
.efe1	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efe3	65 28		adc $28				adc 	zTargetAddr
.efe5	85 28		sta $28				sta 	zTargetAddr
.efe7	90 02		bcc $efeb			bcc 	_CLLINoCarry
.efe9	e6 29		inc $29				inc 	zTargetAddr+1
.efeb					_CLLINoCarry:
.efeb	c6 2a		dec $2a				dec 	zTargetAddr+2 				; done all of them ?
.efed	d0 e6		bne $efd5			bne 	_CLLILoop
.efef					_CLLIExit:
.efef	7a		ply				ply
.eff0	4c 73 f1	jmp $f173			jmp 	WarmStart
.eff3					CLIOneLine:
.eff3	a0 01		ldy #$01			ldy 	#1 							; get line#
.eff5	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.eff7	8d 00 04	sta $0400			sta 	evalStack+0
.effa	c8		iny				iny
.effb	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.effd	8d 01 04	sta $0401			sta 	evalStack+1
.f000	a9 00		lda #$00			lda 	#0
.f002	aa		tax				tax
.f003	8d 02 04	sta $0402			sta 	evalStack+2
.f006	8d 03 04	sta $0403			sta 	evalStack+3
.f009	20 73 ef	jsr $ef73			jsr 	CPRPrintInteger 			; print line#
.f00c	a9 20		lda #$20			lda 	#32
.f00e	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.f011	a0 03		ldy #$03			ldy 	#3 							; where to start
.f013					_CLIOutput:
.f013	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.f015	c8		iny				iny
.f016	09 00		ora #$00			ora 	#0
.f018	f0 0c		beq $f026			beq 	_CLIExit
.f01a	10 05		bpl $f021			bpl		_CLISingle
.f01c	20 2c f0	jsr $f02c			jsr 	CLIPrintToken
.f01f	80 f2		bra $f013			bra 	_CLIOutput
.f021					_CLISingle:
.f021	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.f024	80 ed		bra $f013			bra 	_CLIOutput
.f026					_CLIExit:
.f026	a9 0d		lda #$0d			lda 	#13 						; new line.
.f028	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.f02b	60		rts				rts
.f02c					CLIPrintToken:
.f02c	5a		phy				phy 								; save Y
.f02d	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.f02f	a8		tay				tay
.f030	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.f032					_CLIFind:
.f032	88		dey				dey 								; decrement counter
.f033	30 09		bmi $f03e			bmi 	_CLIFoundToken 				; if -ve found the token.
.f035					_CLISkip:
.f035	bd 7a e0	lda $e07a,x			lda 	TokenText,x
.f038	e8		inx				inx
.f039	0a		asl a				asl		a
.f03a	90 f9		bcc $f035			bcc 	_CLISkip
.f03c	80 f4		bra $f032			bra 	_CLIFind
.f03e					_CLIFoundToken:
.f03e	7a		ply				ply
.f03f					_CLIPrintIt:
.f03f	bd 7a e0	lda $e07a,x			lda 	TokenText,x
.f042	e8		inx				inx
.f043	48		pha				pha
.f044	29 7f		and #$7f			and 	#$7F
.f046	20 d5 e4	jsr $e4d5			jsr 	SIOPrintCharacter
.f049	68		pla				pla
.f04a	0a		asl a				asl 	a
.f04b	90 f2		bcc $f03f			bcc 	_CLIPrintIt
.f04d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/dountil.asm

.f04e					COMMAND_Do:
.f04e	a9 9e		lda #$9e			lda 	#KW_DO						; push position with a DO token.
.f050	20 6e f0	jsr $f06e			jsr 	CDOPushPosOnStack
.f053	60		rts				rts
.f054					COMMAND_Until:
.f054	a9 9e		lda #$9e			lda 	#KW_DO 						; check TOS is a Do.
.f056	20 ac f0	jsr $f0ac			jsr 	CDOCheckTopStack
.f059	a2 00		ldx #$00			ldx 	#0 							; evaluate the test
.f05b	20 08 e2	jsr $e208			jsr 	EvaluateBase
.f05e	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check if zero
.f061	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.f064	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.f067	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f06a	f0 2a		beq $f096			beq 	CDOPullPosOffStack 			; zero, restore the position.
.f06c	80 1e		bra $f08c			bra 	CDOThrowPosOffStack			; non-zero chuck it.
.f06e					CDOPushPosOnStack:
.f06e	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.f071	48		pha				pha
.f072	98		tya				tya
.f073	9d 01 02	sta $0201,x			sta 	BasicStack+1,x 				; +1 	Y Position
.f076	a5 20		lda $20				lda 	zCurrentLine
.f078	9d 02 02	sta $0202,x			sta 	BasicStack+2,x 				; +2 	low of pos
.f07b	a5 21		lda $21				lda 	zCurrentLine+1
.f07d	9d 03 02	sta $0203,x			sta 	BasicStack+3,x 				; +3 	high of pos
.f080	68		pla				pla
.f081	9d 04 02	sta $0204,x			sta 	BasicStack+4,x 				; +4 	token on stack
.f084	e8		inx				inx
.f085	e8		inx				inx
.f086	e8		inx				inx
.f087	e8		inx				inx 								; always points to TOS.
.f088	8e a3 20	stx $20a3			stx 	basicStackIndex
.f08b	60		rts				rts
.f08c					CDOThrowPosOffStack:
.f08c	ad a3 20	lda $20a3			lda 	basicStackIndex
.f08f	38		sec				sec
.f090	e9 04		sbc #$04			sbc 	#4
.f092	8d a3 20	sta $20a3			sta 	basicStackIndex
.f095	60		rts				rts
.f096					CDOPullPosOffStack:
.f096	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.f099	ca		dex				dex
.f09a	ca		dex				dex
.f09b	ca		dex				dex
.f09c	ca		dex				dex
.f09d	bd 01 02	lda $0201,x			lda 	BasicStack+1,x 					; get position back.
.f0a0	a8		tay				tay
.f0a1	bd 02 02	lda $0202,x			lda 	BasicStack+2,x
.f0a4	85 20		sta $20				sta 	zCurrentLine
.f0a6	bd 03 02	lda $0203,x			lda 	BasicStack+3,x
.f0a9	85 21		sta $21				sta 	zCurrentLine+1
.f0ab	60		rts				rts
.f0ac					CDOCheckTopStack:
.f0ac	ae a3 20	ldx $20a3			ldx 	basicStackIndex 			; if match
.f0af	dd 00 02	cmp $0200,x			cmp 	BasicStack+0,x
.f0b2	d0 01		bne $f0b5			bne 	_CDOCTSError
.f0b4	60		rts				rts
.f0b5					_CDOCTSError:
.f0b5	20 66 e1	jsr $e166			jsr 	ReportError
>f0b8	53 54 52 55 43 54 55 52				.text 	"STRUCTURE MIXED",$00
>f0c0	45 20 4d 49 58 45 44 00

;******  Return to file: basic.asm


;******  Processing file: commands/goto.asm

.f0c8					COMMAND_Goto:
.f0c8	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.f0ca	20 08 e2	jsr $e208			jsr 	EvaluateBase
.f0cd					CMDGoto:
.f0cd	20 f2 f0	jsr $f0f2			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.f0d0	a5 28		lda $28				lda 	zTargetAddr 				; new line
.f0d2	85 20		sta $20				sta 	zCurrentLine
.f0d4	a5 29		lda $29				lda 	zTargetAddr+1
.f0d6	85 21		sta $21				sta 	zCurrentLine+1
.f0d8	a0 03		ldy #$03			ldy 	#3
.f0da	60		rts				rts
.f0db					COMMAND_Gosub:
.f0db	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.f0dd	20 08 e2	jsr $e208			jsr 	EvaluateBase
.f0e0	a9 a2		lda #$a2			lda 	#KW_GOSUB
.f0e2	20 6e f0	jsr $f06e			jsr 	CDOPushPosOnStack 			; save return address on stack.
.f0e5	80 e6		bra $f0cd			bra 	CMDGoto
.f0e7					COMMAND_Return:
.f0e7	a9 a2		lda #$a2			lda 	#KW_GOSUB 					; check GOSUB on BASIC Stack.
.f0e9	20 ac f0	jsr $f0ac			jsr 	CDOCheckTopStack
.f0ec	20 96 f0	jsr $f096			jsr 	CDOPullPosOffStack 			; restore
.f0ef	4c 8c f0	jmp $f08c			jmp 	CDOThrowPosOffStack 		; and drop it.
.f0f2					FindProgramLine:
.f0f2	ad 02 04	lda $0402			lda 	evalStack+2 				; check in range 0-65535
.f0f5	0d 03 04	ora $0403			ora 	evalStack+3
.f0f8	d0 2e		bne $f128			bne		_FPLFail
.f0fa	a9 00		lda #$00			lda 	#BasicProgram & 255 		; start of code
.f0fc	85 28		sta $28				sta 	zTargetAddr
.f0fe	a9 23		lda #$23			lda 	#BasicProgram >> 8
.f100	85 29		sta $29				sta 	zTargetAddr+1
.f102					_FPLLoop:
.f102	a0 00		ldy #$00			ldy 	#0 							; reached end
.f104	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.f106	f0 20		beq $f128			beq 	_FPLFail
.f108	c8		iny				iny 								; check line numbers
.f109	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.f10b	cd 00 04	cmp $0400			cmp 	evalStack+0
.f10e	d0 09		bne $f119			bne 	_FPLNext
.f110	c8		iny				iny
.f111	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.f113	cd 01 04	cmp $0401			cmp 	evalStack+1
.f116	d0 01		bne $f119			bne 	_FPLNext
.f118	60		rts				rts
.f119					_FPLNext:
.f119	a0 00		ldy #$00			ldy 	#0 							; go to next
.f11b	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.f11d	18		clc				clc
.f11e	65 28		adc $28				adc 	zTargetAddr
.f120	85 28		sta $28				sta 	zTargetAddr
.f122	90 de		bcc $f102			bcc 	_FPLLoop
.f124	e6 29		inc $29				inc 	zTargetAddr+1
.f126	80 da		bra $f102			bra 	_FPLLoop
.f128					_FPLFail:
.f128	20 66 e1	jsr $e166			jsr 	ReportError
>f12b	4c 49 4e 45 20 4e 4f 54				.text 	"LINE NOT FOUND",$00
>f133	20 46 4f 55 4e 44 00

;******  Return to file: basic.asm

.f13a					Start:
.f13a	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f13c	9a		txs			txs
.f13d	20 97 e4	jsr $e497			jsr 	SIOInitialise 				; initialise the I/O system.
.f140	a2 b3		ldx #$b3			ldx 	#BootMsg1 & 255 			; boot text.
.f142	a0 f1		ldy #$f1			ldy 	#BootMsg1 >> 8
.f144	20 a8 e4	jsr $e4a8			jsr 	SIOPrintString
.f147	a2 ff		ldx #$ff			ldx 	#(endMemory-startMemory-1) & $FF
.f149	a0 5f		ldy #$5f			ldy 	#(endMemory-startMemory-1) >> 8
.f14b	20 95 e1	jsr $e195			jsr 	PrintWordInteger
.f14e	a2 ca		ldx #$ca			ldx 	#BootMsg2 & 255
.f150	a0 f1		ldy #$f1			ldy 	#BootMsg2 >> 8
.f152	20 a8 e4	jsr $e4a8			jsr 	SIOPrintString
.f155	ad 6b 23	lda $236b			lda 	StartBehaviour 				; what to do ?
.f158	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.f15a	f0 14		beq $f170			beq		CommandLine
.f15c	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.f15e	f0 07		beq $f167			beq	 	RunProgram
.f160	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.f162	f0 43		beq $f1a7			beq 	TokeniseExec
.f164	4c 56 e1	jmp $e156			jmp		SyntaxError
.f167					RunProgram:
.f167	20 d3 ec	jsr $ecd3			jsr 	COMMAND_NewCode 			; do a new
.f16a	20 22 ed	jsr $ed22			jsr 	COMMAND_OldCode 			; get back the old program as we're deving.
.f16d	4c 0b ec	jmp $ec0b			jmp 	COMMAND_Run
.f170					CommandLine:
.f170	20 d3 ec	jsr $ecd3			jsr 	Command_NewCode
.f173					WarmStart:
.f173	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f175	9a		txs			txs
.f176	20 24 e5	jsr $e524			jsr 	SIOReadLine 				; read input line.
.f179	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.f17b	85 24		sta $24				sta 	zTemp1
.f17d	a9 20		lda #$20			lda 	#InputLine >> 8
.f17f	85 25		sta $25				sta 	zTemp1+1
.f181	20 90 e6	jsr $e690			jsr 	TokeniseString
.f184	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.f186	85 20		sta $20				sta 	zCurrentLine
.f188	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.f18a	85 21		sta $21				sta 	zCurrentLine+1
.f18c	a0 00		ldy #$00			ldy 	#0
.f18e					_WSSkipSpace:
.f18e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f190	c8		iny				iny
.f191	c9 20		cmp #$20			cmp 	#' '
.f193	f0 f9		beq $f18e			beq 	_WSSkipSpace
.f195	88		dey				dey
.f196	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.f198	90 0a		bcc $f1a4			bcc 	_WSExecute
.f19a	c9 3a		cmp #$3a			cmp 	#"9"+1
.f19c	b0 06		bcs $f1a4			bcs 	_WSExecute
.f19e	20 65 e7	jsr $e765			jsr 	EditProgram
.f1a1	4c 73 f1	jmp $f173			jmp 	WarmStart
.f1a4					_WSExecute:
.f1a4	4c 1e ec	jmp $ec1e			jmp 	CRUNNextInstruction
.f1a7					TokeniseExec:
.f1a7	a9 00		lda #$00			lda 	#BasicCode & $FF 			; if so tokenise whatever I've put in the basic code
.f1a9	85 24		sta $24				sta 	zTemp1 						; area
.f1ab	a9 23		lda #$23			lda 	#BasicCode >> 8
.f1ad	85 25		sta $25				sta 	zTemp1+1
.f1af	20 90 e6	jsr $e690			jsr 	TokeniseString
>f1b2	02						.byte 	2
.f1b3					BootMsg1:
>f1b3	2a 2a 2a 20 41 54 4f 4d				.text 	"*** ATOMIC BASIC ***",13,13,0
>f1bb	49 43 20 42 41 53 49 43 20 2a 2a 2a 0d 0d 00
.f1ca					BootMsg2:
>f1ca	20 42 59 54 45 53 20 46				.text	" BYTES FREE.",13,13,0
>f1d2	52 45 45 2e 0d 0d 00
.2300					BasicCode:

;******  Processing file: include/basic_generated.inc

>2300	09 0c 00 41 20 93 20 30			.byte $09,$0c,$00,$41,$20,$93,$20,$30,$00,$0f,$0d,$00,$9e,$20,$41,$20,$93,$20,$41,$20,$8a,$20,$31,$00,$08,$0e,$00,$af,$20,$41,$8b,$00,$1f,$0f,$00,$a7,$20,$41,$84,$33,$93,$30,$20,$b7,$20,$af,$20,$81,$59,$45,$53,$81,$8f,$8e,$9f,$20,$a2,$20,$31,$30,$30,$30,$00,$0c,$1e,$00,$af,$8e,$ba,$20,$41,$93,$31,$31,$00,$0e,$28,$00,$4d,$93,$82,$46,$46,$44,$33,$30,$30,$30,$00,$05,$64,$00,$b5,$00,$0c,$e8,$03,$af,$20,$81,$2a,$81,$8f,$8e,$b1,$00,$00
>2308	00 0f 0d 00 9e 20 41 20 93 20 41 20 8a 20 31 00
>2318	08 0e 00 af 20 41 8b 00 1f 0f 00 a7 20 41 84 33
>2328	93 30 20 b7 20 af 20 81 59 45 53 81 8f 8e 9f 20
>2338	a2 20 31 30 30 30 00 0c 1e 00 af 8e ba 20 41 93
>2348	31 31 00 0e 28 00 4d 93 82 46 46 44 33 30 30 30
>2358	00 05 64 00 b5 00 0c e8 03 af 20 81 2a 81 8f 8e
>2368	b1 00 00
.236b					StartBehaviour:
>236b	52					.text "R"

;******  Return to file: basic.asm


;******  End of listing
