
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q --m4510 -D TARGET=1 -b -L rom.lst -o rom.bin basic.asm
; Fri Aug  2 18:20:24 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					TARGET=1

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	d8 f2						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_mega65.asm

=80					EXTWidth = 80 								; screen width
=25					EXTHeight = 25 								; screen height
=$2000					EXTLowMemory = $2000 						; Workspace RAM starts here
=$8000					EXTHighMemory = $8000 						; Workspace RAM ends here
=$1000					EXTScreen = $1000							; 2k screen RAM here
=$800					EXTCharSet = $800							; 2k character set (0-7F) here
>0000	00 00					.word 	0 								; forces it to be a 64k ROM (at least)
.a000					EXTCBMFont:
>a000	3c 66 6e 6e 60 62 3c 00			.binary "c64-chargen.rom"
>a008	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>a018	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>a028	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>a038	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>a048	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>a058	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>a068	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>a078	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>a088	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>a098	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>a0a8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>a0b8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>a0c8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>a0d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a0e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a0f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a108	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a118	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a128	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a138	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a148	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a158	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a168	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a178	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a188	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a198	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a1a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a1b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a1c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a1d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a1e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a1f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>a208	08 1c 3e 7f 7f 1c 3e 00 18 18 18 18 18 18 18 18
>a218	00 00 00 ff ff 00 00 00 00 00 ff ff 00 00 00 00
>a228	00 ff ff 00 00 00 00 00 00 00 00 00 ff ff 00 00
>a238	30 30 30 30 30 30 30 30 0c 0c 0c 0c 0c 0c 0c 0c
>a248	00 00 00 e0 f0 38 18 18 18 18 1c 0f 07 00 00 00
>a258	18 18 38 f0 e0 00 00 00 c0 c0 c0 c0 c0 c0 ff ff
>a268	c0 e0 70 38 1c 0e 07 03 03 07 0e 1c 38 70 e0 c0
>a278	ff ff c0 c0 c0 c0 c0 c0 ff ff 03 03 03 03 03 03
>a288	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 ff ff 00
>a298	36 7f 7f 7f 3e 1c 08 00 60 60 60 60 60 60 60 60
>a2a8	00 00 00 07 0f 1c 18 18 c3 e7 7e 3c 3c 7e e7 c3
>a2b8	00 3c 7e 66 66 7e 3c 00 18 18 66 66 18 18 3c 00
>a2c8	06 06 06 06 06 06 06 06 08 1c 3e 7f 3e 1c 08 00
>a2d8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>a2e8	18 18 18 18 18 18 18 18 00 00 03 3e 76 36 36 00
>a2f8	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a308	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a318	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a328	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>a338	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>a348	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a358	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>a368	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>a378	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>a388	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>a398	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>a3a8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a3b8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a3c8	00 00 00 00 00 ff ff ff 03 03 03 03 03 03 ff ff
>a3d8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a3e8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a3f8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>a408	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>a418	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>a428	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>a438	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>a448	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>a458	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>a468	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>a478	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>a488	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>a498	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>a4a8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>a4b8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>a4c8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>a4d8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>a4e8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>a4f8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>a508	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>a518	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>a528	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>a538	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>a548	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>a558	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>a568	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>a578	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>a588	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>a598	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>a5a8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>a5b8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>a5c8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>a5d8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>a5e8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>a5f8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>a608	f7 e3 c1 80 80 e3 c1 ff e7 e7 e7 e7 e7 e7 e7 e7
>a618	ff ff ff 00 00 ff ff ff ff ff 00 00 ff ff ff ff
>a628	ff 00 00 ff ff ff ff ff ff ff ff ff 00 00 ff ff
>a638	cf cf cf cf cf cf cf cf f3 f3 f3 f3 f3 f3 f3 f3
>a648	ff ff ff 1f 0f c7 e7 e7 e7 e7 e3 f0 f8 ff ff ff
>a658	e7 e7 c7 0f 1f ff ff ff 3f 3f 3f 3f 3f 3f 00 00
>a668	3f 1f 8f c7 e3 f1 f8 fc fc f8 f1 e3 c7 8f 1f 3f
>a678	00 00 3f 3f 3f 3f 3f 3f 00 00 fc fc fc fc fc fc
>a688	ff c3 81 81 81 81 c3 ff ff ff ff ff ff 00 00 ff
>a698	c9 80 80 80 c1 e3 f7 ff 9f 9f 9f 9f 9f 9f 9f 9f
>a6a8	ff ff ff f8 f0 e3 e7 e7 3c 18 81 c3 c3 81 18 3c
>a6b8	ff c3 81 99 99 81 c3 ff e7 e7 99 99 e7 e7 c3 ff
>a6c8	f9 f9 f9 f9 f9 f9 f9 f9 f7 e3 c1 80 c1 e3 f7 ff
>a6d8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>a6e8	e7 e7 e7 e7 e7 e7 e7 e7 ff ff fc c1 89 c9 c9 ff
>a6f8	00 80 c0 e0 f0 f8 fc fe ff ff ff ff ff ff ff ff
>a708	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>a718	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>a728	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>a738	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>a748	00 01 03 07 0f 1f 3f 7f fc fc fc fc fc fc fc fc
>a758	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>a768	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>a778	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>a788	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>a798	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>a7a8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>a7b8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>a7c8	ff ff ff ff ff 00 00 00 fc fc fc fc fc fc 00 00
>a7d8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>a7e8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>a7f8	0f 0f 0f 0f f0 f0 f0 f0 3c 66 6e 6e 60 62 3c 00
>a808	00 00 3c 06 3e 66 3e 00 00 60 60 7c 66 66 7c 00
>a818	00 00 3c 60 60 60 3c 00 00 06 06 3e 66 66 3e 00
>a828	00 00 3c 66 7e 60 3c 00 00 0e 18 3e 18 18 18 00
>a838	00 00 3e 66 66 3e 06 7c 00 60 60 7c 66 66 66 00
>a848	00 18 00 38 18 18 3c 00 00 06 00 06 06 06 06 3c
>a858	00 60 60 6c 78 6c 66 00 00 38 18 18 18 18 3c 00
>a868	00 00 66 7f 7f 6b 63 00 00 00 7c 66 66 66 66 00
>a878	00 00 3c 66 66 66 3c 00 00 00 7c 66 66 7c 60 60
>a888	00 00 3e 66 66 3e 06 06 00 00 7c 66 60 60 60 00
>a898	00 00 3e 60 3c 06 7c 00 00 18 7e 18 18 18 0e 00
>a8a8	00 00 66 66 66 66 3e 00 00 00 66 66 66 3c 18 00
>a8b8	00 00 63 6b 7f 3e 36 00 00 00 66 3c 18 3c 66 00
>a8c8	00 00 66 66 66 3e 0c 78 00 00 7e 0c 18 30 7e 00
>a8d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a8e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a8f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a908	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a918	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a928	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a938	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a948	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a958	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a968	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a978	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a988	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a998	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a9a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a9b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a9c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a9d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a9e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a9f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>aa08	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>aa18	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>aa28	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>aa38	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>aa48	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>aa58	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>aa68	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>aa78	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>aa88	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>aa98	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>aaa8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>aab8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>aac8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>aad8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>aae8	18 18 18 18 18 18 18 18 33 33 cc cc 33 33 cc cc
>aaf8	33 99 cc 66 33 99 cc 66 00 00 00 00 00 00 00 00
>ab08	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>ab18	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>ab28	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>ab38	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>ab48	cc 99 33 66 cc 99 33 66 03 03 03 03 03 03 03 03
>ab58	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>ab68	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>ab78	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>ab88	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>ab98	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>aba8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>abb8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>abc8	00 00 00 00 00 ff ff ff 01 03 06 6c 78 70 60 00
>abd8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>abe8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>abf8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>ac08	ff ff c3 f9 c1 99 c1 ff ff 9f 9f 83 99 99 83 ff
>ac18	ff ff c3 9f 9f 9f c3 ff ff f9 f9 c1 99 99 c1 ff
>ac28	ff ff c3 99 81 9f c3 ff ff f1 e7 c1 e7 e7 e7 ff
>ac38	ff ff c1 99 99 c1 f9 83 ff 9f 9f 83 99 99 99 ff
>ac48	ff e7 ff c7 e7 e7 c3 ff ff f9 ff f9 f9 f9 f9 c3
>ac58	ff 9f 9f 93 87 93 99 ff ff c7 e7 e7 e7 e7 c3 ff
>ac68	ff ff 99 80 80 94 9c ff ff ff 83 99 99 99 99 ff
>ac78	ff ff c3 99 99 99 c3 ff ff ff 83 99 99 83 9f 9f
>ac88	ff ff c1 99 99 c1 f9 f9 ff ff 83 99 9f 9f 9f ff
>ac98	ff ff c1 9f c3 f9 83 ff ff e7 81 e7 e7 e7 f1 ff
>aca8	ff ff 99 99 99 99 c1 ff ff ff 99 99 99 c3 e7 ff
>acb8	ff ff 9c 94 80 c1 c9 ff ff ff 99 c3 e7 c3 99 ff
>acc8	ff ff 99 99 99 c1 f3 87 ff ff 81 f3 e7 cf 81 ff
>acd8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>ace8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>acf8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>ad08	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>ad18	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>ad28	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>ad38	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>ad48	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>ad58	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>ad68	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>ad78	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>ad88	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>ad98	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>ada8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>adb8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>adc8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>add8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>ade8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>adf8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>ae08	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>ae18	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>ae28	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>ae38	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>ae48	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>ae58	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>ae68	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>ae78	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>ae88	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>ae98	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>aea8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>aeb8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>aec8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>aed8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>aee8	e7 e7 e7 e7 e7 e7 e7 e7 cc cc 33 33 cc cc 33 33
>aef8	cc 66 33 99 cc 66 33 99 ff ff ff ff ff ff ff ff
>af08	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>af18	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>af28	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>af38	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>af48	33 66 cc 99 33 66 cc 99 fc fc fc fc fc fc fc fc
>af58	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>af68	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>af78	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>af88	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>af98	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>afa8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>afb8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>afc8	ff ff ff ff ff 00 00 00 fe fc f9 93 87 8f 9f ff
>afd8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>afe8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>aff8	0f 0f 0f 0f f0 f0 f0 f0
.b000					EXTStartPersonalise:
.b000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.b002	9a		txs			txs
.b003	20 d6 b0	jsr $b0d6		jsr 	EXTReset 						; reset video
.b006	20 86 b0	jsr $b086		jsr 	EXTClearScreen 					; clear screen
.b009	4c d8 f2	jmp $f2d8		jmp 	Start 							; start main application
.b00c					EXTReadKeyPort:
.b00c	db		phz			phz
.b00d	20 42 b0	jsr $b042		jsr 	EXTSetupKeyAddress
.b010	ea		nop			nop 									; read keyboard
.b011	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b013	fb		plz			plz
.b014	c9 14		cmp #$14		cmp 	#20
.b016	d0 02		bne $b01a		bne 	_KMNo
.b018	a9 08		lda #$08		lda 	#"H"-64
.b01a					_KMNo:
.b01a	c9 91		cmp #$91		cmp 	#145
.b01c	d0 02		bne $b020		bne 	_KMNo
.b01e	a9 17		lda #$17		lda 	#"W"-64
.b020					_KMNo:
.b020	c9 11		cmp #$11		cmp 	#17
.b022	d0 02		bne $b026		bne 	_KMNo
.b024	a9 13		lda #$13		lda 	#"S"-64
.b026					_KMNo:
.b026	c9 9d		cmp #$9d		cmp 	#157
.b028	d0 02		bne $b02c		bne 	_KMNo
.b02a	a9 01		lda #$01		lda 	#"A"-64
.b02c					_KMNo:
.b02c	c9 1d		cmp #$1d		cmp 	#29
.b02e	d0 02		bne $b032		bne 	_KMNo
.b030	a9 04		lda #$04		lda 	#"D"-64
.b032					_KMNo:
.b032	c9 00		cmp #$00		cmp 	#0 								; set Z
.b034	60		rts			rts
.b035					EXTRemoveKeyPressed:
.b035	48		pha			pha
.b036	db		phz			phz
.b037	20 42 b0	jsr $b042		jsr 	EXTSetupKeyAddress
.b03a	a9 00		lda #$00		lda 	#0
.b03c	ea		nop			nop 									; read keyboard
.b03d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b03f	fb		plz			plz
.b040	68		pla			pla
.b041	60		rts			rts
.b042					EXTSetupKeyAddress:
.b042	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to read keyboard.
.b044	85 07		sta $07			sta 	EXTZPWork+3
.b046	a9 fd		lda #$fd		lda 	#$FD
.b048	85 06		sta $06			sta 	EXTZPWork+2
.b04a	a9 36		lda #$36		lda 	#$36
.b04c	85 05		sta $05			sta 	EXTZPWork+1
.b04e	a9 10		lda #$10		lda 	#$10
.b050	85 04		sta $04			sta 	EXTZPWork+0
.b052	a3 00		ldz #$00		ldz 	#0
.b054	60		rts			rts
.b055					EXTCheckBreak:
.b055	db		phz			phz
.b056	20 42 b0	jsr $b042		jsr 	EXTSetupKeyAddress 				; point to keyboard
.b059	e6 04		inc $04			inc 	EXTZPWork 						; point to modifiers.
.b05b	ea		nop			nop 									; read modifiers.
.b05c	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b05e	fb		plz			plz 									; restore Z
.b05f	29 05		and #$05		and 	#5								; break is LeftShift+Ctrl
.b061	c9 05		cmp #$05		cmp 	#5
.b063	f0 03		beq $b068		beq 	_EXTCBYes
.b065	a9 00		lda #$00		lda 	#0
.b067	60		rts			rts
.b068					_EXTCBYes:
.b068	a9 01		lda #$01		lda 	#1
.b06a	60		rts			rts
.b06b					EXTReadScreen:
.b06b	5a		phy			phy 										; save Y
.b06c	8a		txa			txa 										; multiply XY by 2
.b06d	85 04		sta $04			sta 	EXTZPWork							; into EXTZPWork
.b06f	98		tya			tya
.b070	09 10		ora #$10		ora 	#EXTScreen>>8 						; move into screen area
.b072	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.b074	a0 00		ldy #$00		ldy 	#0
.b076	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b078	7a		ply			ply 										; restore Y and exit.
.b079	60		rts			rts
.b07a					EXTWriteScreen:
.b07a	5a		phy			phy
.b07b	48		pha			pha
.b07c	20 6b b0	jsr $b06b		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.b07f	a0 00		ldy #$00		ldy 	#0
.b081	68		pla			pla 										; restore and write.
.b082	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b084	7a		ply			ply
.b085	60		rts			rts
.b086					EXTClearScreen:
.b086	48		pha			pha 										; save registers
.b087	5a		phy			phy
.b088	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set up pointer
.b08a	85 04		sta $04			sta 	EXTZPWork
.b08c	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b08e	85 05		sta $05			sta 	EXTZPWork+1
.b090	a0 00		ldy #$00		ldy 	#0
.b092					_EXTCSLoop:
.b092	a9 20		lda #$20		lda 	#32
.b094	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b096	c8		iny			iny
.b097	d0 f9		bne $b092		bne 	_EXTCSLoop
.b099	e6 05		inc $05			inc 	EXTZPWork+1 						; next screen page
.b09b	a5 05		lda $05			lda 	EXTZPWork+1
.b09d	c9 18		cmp #$18		cmp 	#(EXTScreen>>8)+8 					; done 2k ?
.b09f	d0 f1		bne $b092		bne 	_EXTCSLoop
.b0a1	7a		ply			ply 										; restore
.b0a2	68		pla			pla
.b0a3	60		rts			rts
.b0a4					EXTScrollDisplay:
.b0a4	48		pha			pha 										; save registers
.b0a5	5a		phy			phy
.b0a6	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set pointer to screen
.b0a8	85 04		sta $04			sta 	EXTZPWork+0
.b0aa	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b0ac	85 05		sta $05			sta 	EXTZPWork+1
.b0ae					_EXTScroll:
.b0ae	a0 50		ldy #$50		ldy 	#EXTWidth 							; x 2 because of two byte format.
.b0b0	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b0b2	a0 00		ldy #$00		ldy 	#0
.b0b4	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b0b6	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.b0b8	d0 02		bne $b0bc		bne 	_EXTNoCarry
.b0ba	e6 05		inc $05			inc 	EXTZPWork+1
.b0bc					_EXTNoCarry:
.b0bc	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.b0be	c9 80		cmp #$80		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) & $FF
.b0c0	d0 ec		bne $b0ae		bne 	_EXTScroll
.b0c2	a5 05		lda $05			lda 	EXTZPWork+1
.b0c4	c9 17		cmp #$17		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) >> 8
.b0c6	d0 e6		bne $b0ae		bne 	_EXTScroll
.b0c8	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.b0ca					_EXTLastLine:
.b0ca	a9 20		lda #$20		lda 	#32
.b0cc	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b0ce	c8		iny			iny
.b0cf	c0 50		cpy #$50		cpy 	#EXTWidth
.b0d1	d0 f7		bne $b0ca		bne 	_EXTLastLine
.b0d3	7a		ply			ply 										; restore and exit.
.b0d4	68		pla			pla
.b0d5	60		rts			rts
.b0d6					EXTReset:
.b0d6	48		pha			pha 									; save registers
.b0d7	da		phx			phx
.b0d8	5a		phy			phy
.b0d9	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to video system.
.b0db	85 07		sta $07			sta 	EXTZPWork+3
.b0dd	a9 fd		lda #$fd		lda 	#$FD
.b0df	85 06		sta $06			sta 	EXTZPWork+2
.b0e1	a9 30		lda #$30		lda 	#$30
.b0e3	85 05		sta $05			sta 	EXTZPWork+1
.b0e5	a9 00		lda #$00		lda 	#$00
.b0e7	85 04		sta $04			sta 	EXTZPWork+0
.b0e9	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0eb	a9 a5		lda #$a5		lda 	#$A5
.b0ed	ea		nop			nop
.b0ee	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0f0	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0f2	a9 96		lda #$96		lda 	#$96
.b0f4	ea		nop			nop
.b0f5	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0f7	a3 30		ldz #$30		ldz 	#$30 							; address already set up
.b0f9	a9 40		lda #$40		lda 	#$40
.b0fb	ea		nop			nop
.b0fc	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0fe	a3 31		ldz #$31		ldz 	#$31 							; address already set up
.b100	a9 80		lda #$80		lda 	#$80
.b102	ea		nop			nop
.b103	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b105	a3 20		ldz #$20		ldz 	#$20 							; address already set up
.b107	a9 00		lda #$00		lda 	#0
.b109	ea		nop			nop
.b10a	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b10c	a3 21		ldz #$21		ldz 	#$21 							; address already set up
.b10e	a9 00		lda #$00		lda 	#0
.b110	ea		nop			nop
.b111	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b113	a3 01		ldz #$01		ldz 	#$01 							; address already set up
.b115	a9 ff		lda #$ff		lda 	#$FF
.b117	ea		nop			nop
.b118	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b11a	a3 00		ldz #$00		ldz 	#$00 							; address already set up
.b11c	a9 ff		lda #$ff		lda 	#$FF
.b11e	ea		nop			nop
.b11f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b121	a3 16		ldz #$16		ldz 	#$16 							; address already set up
.b123	a9 cc		lda #$cc		lda 	#$CC
.b125	ea		nop			nop
.b126	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b128	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b12a	a9 42		lda #$42		lda 	#$42
.b12c	ea		nop			nop
.b12d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b12f	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b131	a9 1b		lda #$1b		lda 	#$1B
.b133	ea		nop			nop
.b134	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b136					ClearColourRAM:
.b136	a9 00		lda #$00		lda 	#$00							; colour RAM at $1F800-1FFFF (2kb)
.b138	85 07		sta $07			sta 	EXTZPWork+3
.b13a	a9 01		lda #$01		lda 	#$01
.b13c	85 06		sta $06			sta 	EXTZPWork+2
.b13e	a9 f8		lda #$f8		lda 	#$F8
.b140	85 05		sta $05			sta 	EXTZPWork+1
.b142	a9 00		lda #$00		lda 	#$00
.b144	85 04		sta $04			sta 	EXTZPWork+0
.b146	a3 00		ldz #$00		ldz 	#0
.b148					_EXTClearColorRam:
.b148	a9 01		lda #$01		lda 	#1 								; fill that with this colour.
.b14a	ea		nop			nop
.b14b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b14d	3b		dez			dez
.b14e	d0 f8		bne $b148		bne 	_EXTClearColorRam
.b150	e6 05		inc $05			inc 	EXTZPWork+1
.b152	d0 f4		bne $b148		bne 	_EXTClearColorRam
.b154	a2 00		ldx #$00		ldx 	#0 								; copy PET Font into memory.
.b156					_EXTCopyCBMFont:
.b156	bd 00 a8	lda $a800,x		lda 	EXTCBMFont+$800,x 				; +$800 uses the lower case c/set
.b159	9d 00 08	sta $0800,x		sta 	EXTCharSet,x
.b15c	bd 00 a1	lda $a100,x		lda 	EXTCBMFont+$100,x
.b15f	9d 00 09	sta $0900,x		sta 	EXTCharSet+$100,x
.b162	bd 00 a2	lda $a200,x		lda 	EXTCBMFont+$200,x
.b165	9d 00 0a	sta $0a00,x		sta 	EXTCharSet+$200,x
.b168	bd 00 a3	lda $a300,x		lda 	EXTCBMFont+$300,x
.b16b	9d 00 0b	sta $0b00,x		sta 	EXTCharSet+$300,x
.b16e	ca		dex			dex
.b16f	d0 e5		bne $b156		bne 	_EXTCopyCBMFont
.b171	7a		ply			ply 									; restore and exit.
.b172	fa		plx			plx
.b173	68		pla			pla
.b174	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm

.b175					IncludeBasicCode:

;******  Processing file: include/basic_generated.inc

>b175	13 6e 00 9e 20 43 87 33			.byte $13,$6e,$00,$9e,$20,$43,$87,$33,$32,$88,$8b,$5a,$5a,$87,$35,$88,$8e,$b0,$00,$1c,$6f,$00,$5a,$5a,$30,$20,$93,$20,$9c,$8e,$80,$5a,$5a,$30,$20,$93,$20,$30,$8e,$5a,$5a,$30,$96,$34,$93,$30,$00,$15,$70,$00,$43,$96,$30,$20,$93,$20,$82,$41,$32,$8e,$43,$96,$31,$93,$82,$38,$33,$00,$0d,$71,$00,$43,$96,$32,$20,$93,$20,$82,$36,$30,$00,$08,$96,$00,$b0,$20,$85,$43,$00,$07,$aa,$00,$aa,$20,$43,$00,$0a,$af,$00,$a3,$20,$32,$30,$30,$30,$00,$05,$b0,$00,$b7,$00,$05,$c1,$07,$b3,$00,$14,$c6,$07,$b3,$20,$44,$55,$4d,$50,$20,$9c,$20,$53,$54,$41,$54,$55,$53,$2e,$00,$05,$cb,$07,$b3,$00,$0b,$d0,$07,$5a,$5a,$30,$20,$93,$20,$9c,$00,$50,$da,$07,$b0,$81,$36,$35,$30,$32,$3a,$20,$41,$3a,$81,$85,$5a,$5a,$30,$96,$30,$81,$20,$58,$3a,$81,$85,$5a,$5a,$30,$96,$31,$81,$20,$59,$3a,$81,$85,$5a,$5a,$30,$96,$32,$81,$20,$5a,$3a,$81,$85,$5a,$5a,$30,$96,$33,$81,$20,$50,$3a,$81,$8f,$85,$5a,$5a,$30,$96,$34,$8f,$81,$20,$4e,$56,$53,$42,$44,$49,$5a,$43,$3a,$81,$8f,$00,$4f,$e4,$07,$5a,$5a,$31,$20,$93,$20,$30,$8e,$5a,$5a,$32,$93,$5a,$5a,$30,$96,$34,$8e,$9f,$8e,$b0,$20,$85,$87,$5a,$5a,$32,$20,$85,$20,$82,$38,$30,$88,$8d,$31,$32,$38,$8f,$8e,$5a,$5a,$32,$20,$93,$20,$5a,$5a,$32,$89,$32,$8e,$5a,$5a,$31,$20,$93,$20,$5a,$5a,$31,$8a,$31,$8e,$bc,$20,$5a,$5a,$31,$20,$93,$20,$38,$8e,$b0,$00,$05,$ee,$07,$b2,$00,$00
>b17d	32 88 8b 5a 5a 87 35 88 8e b0 00 1c 6f 00 5a 5a
>b18d	30 20 93 20 9c 8e 80 5a 5a 30 20 93 20 30 8e 5a
>b19d	5a 30 96 34 93 30 00 15 70 00 43 96 30 20 93 20
>b1ad	82 41 32 8e 43 96 31 93 82 38 33 00 0d 71 00 43
>b1bd	96 32 20 93 20 82 36 30 00 08 96 00 b0 20 85 43
>b1cd	00 07 aa 00 aa 20 43 00 0a af 00 a3 20 32 30 30
>b1dd	30 00 05 b0 00 b7 00 05 c1 07 b3 00 14 c6 07 b3
>b1ed	20 44 55 4d 50 20 9c 20 53 54 41 54 55 53 2e 00
>b1fd	05 cb 07 b3 00 0b d0 07 5a 5a 30 20 93 20 9c 00
>b20d	50 da 07 b0 81 36 35 30 32 3a 20 41 3a 81 85 5a
>b21d	5a 30 96 30 81 20 58 3a 81 85 5a 5a 30 96 31 81
>b22d	20 59 3a 81 85 5a 5a 30 96 32 81 20 5a 3a 81 85
>b23d	5a 5a 30 96 33 81 20 50 3a 81 8f 85 5a 5a 30 96
>b24d	34 8f 81 20 4e 56 53 42 44 49 5a 43 3a 81 8f 00
>b25d	4f e4 07 5a 5a 31 20 93 20 30 8e 5a 5a 32 93 5a
>b26d	5a 30 96 34 8e 9f 8e b0 20 85 87 5a 5a 32 20 85
>b27d	20 82 38 30 88 8d 31 32 38 8f 8e 5a 5a 32 20 93
>b28d	20 5a 5a 32 89 32 8e 5a 5a 31 20 93 20 5a 5a 31
>b29d	8a 31 8e bc 20 5a 5a 31 20 93 20 38 8e b0 00 05
>b2ad	ee 07 b2 00 00
.b2b2					StartBehaviour:
>b2b2	52					.text "R"

;******  Return to file: basic.asm

.b2b3					EndBasicCode:

;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	26 e9					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	62 e1					.word	SyntaxError                   ; """        ($0081)
>e004	62 e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	1b e9					.word	BFUNC_String                  ; "$"        ($0083)
>e008	e5 ea					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	2d e9					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	62 e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	62 e1					.word	SyntaxError                   ; "("        ($0087)
>e010	62 e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	01 eb					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	cf e8					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	62 e1					.word	SyntaxError                   ; ","        ($008b)
>e018	f5 e8					.word	BFUNC_Subtract                ; "-"        ($008c)
>e01a	1d ea					.word	BFUNC_Divide                  ; "/"        ($008d)
>e01c	62 e1					.word	SyntaxError                   ; ":"        ($008e)
>e01e	62 e1					.word	SyntaxError                   ; ";"        ($008f)
>e020	fe e9					.word	BFUNC_LessEqual               ; "<="       ($0090)
>e022	9f e9					.word	BFUNC_NotEquals               ; "<>"       ($0091)
>e024	d9 e9					.word	BFUNC_Less                    ; "<"        ($0092)
>e026	9c e9					.word	BFUNC_Equals                  ; "="        ($0093)
>e028	dc e9					.word	BFUNC_GreaterEqual            ; ">="       ($0094)
>e02a	fb e9					.word	BFUNC_Greater                 ; ">"        ($0095)
>e02c	1f e9					.word	BFUNC_ByteInd                 ; "?"        ($0096)
>e02e	77 e9					.word	BFUNC_Xor                     ; "^"        ($0097)
>e030	1e f0					.word	COMMAND_Assert                ; "assert"   ($0098)
>e032	f0 eb					.word	UNARY_Abs                     ; "abs"      ($0099)
>e034	65 f0					.word	COMMAND_Clear                 ; "clear"    ($009a)
>e036	41 f2					.word	COMMAND_CLS                   ; "cls"      ($009b)
>e038	7c ec					.word	UNARY_CPU                     ; "cpu"      ($009c)
>e03a	db eb					.word	UNARY_Ch                      ; "ch"       ($009d)
>e03c	8f ec					.word	COMMAND_Dim                   ; "dim"      ($009e)
>e03e	1c ed					.word	COMMAND_Do                    ; "do"       ($009f)
>e040	3a ee					.word	COMMAND_ELSE                  ; "else"     ($00a0)
>e042	cd f2					.word	COMMAND_End                   ; "end"      ($00a1)
>e044	62 e1					.word	SyntaxError                   ; "for"      ($00a2)
>e046	a9 ed					.word	COMMAND_Gosub                 ; "gosub"    ($00a3)
>e048	96 ed					.word	COMMAND_Goto                  ; "goto"     ($00a4)
>e04a	0d ec					.word	UNARY_Get                     ; "get"      ($00a5)
>e04c	67 ec					.word	UNARY_IOAddr                  ; "ioaddr"   ($00a6)
>e04e	62 e1					.word	SyntaxError                   ; "input"    ($00a7)
>e050	08 ee					.word	COMMAND_IF                    ; "if"       ($00a8)
>e052	7e ef					.word	COMMAND_List                  ; "list"     ($00a9)
>e054	db f0					.word	COMMAND_LINK                  ; "link"     ($00aa)
>e056	43 ee					.word	COMMAND_Let                   ; "let"      ($00ab)
>e058	99 eb					.word	UNARY_Len                     ; "len"      ($00ac)
>e05a	62 e1					.word	SyntaxError                   ; "next"     ($00ad)
>e05c	4c f0					.word	COMMAND_NewExec               ; "new"      ($00ae)
>e05e	9b f0					.word	COMMAND_OldExec               ; "old"      ($00af)
>e060	33 f1					.word	COMMAND_Print                 ; "print"    ($00b0)
>e062	17 ec					.word	UNARY_Page                    ; "page"     ($00b1)
>e064	b5 ed					.word	COMMAND_Return                ; "return"   ($00b2)
>e066	42 f0					.word	COMMAND_Rem                   ; "rem"      ($00b3)
>e068	44 f2					.word	COMMAND_Run                   ; "run"      ($00b4)
>e06a	d7 f0					.word	COMMAND_RST                   ; "rst"      ($00b5)
>e06c	2a ec					.word	UNARY_Rnd                     ; "rnd"      ($00b6)
>e06e	c5 f2					.word	COMMAND_Stop                  ; "stop"     ($00b7)
>e070	62 e1					.word	SyntaxError                   ; "step"     ($00b8)
>e072	26 ee					.word	COMMAND_THEN                  ; "then"     ($00b9)
>e074	f8 eb					.word	UNARY_Top                     ; "top"      ($00ba)
>e076	62 e1					.word	SyntaxError                   ; "to"       ($00bb)
>e078	22 ed					.word	COMMAND_Until                 ; "until"    ($00bc)
>e07a	52 e9					.word	BFUNC_Or                      ; "|"        ($00bd)
>e07c	58 eb					.word	BFUNC_StringCompare           ; "~"        ($00be)
.e07e					TokenText:
>e07e	a1					.byte $a1                             ; $0080 !
>e07f	a2					.byte $a2                             ; $0081 "
>e080	a3					.byte $a3                             ; $0082 #
>e081	a4					.byte $a4                             ; $0083 $
>e082	a5					.byte $a5                             ; $0084 %
>e083	a6					.byte $a6                             ; $0085 &
>e084	a7					.byte $a7                             ; $0086 '
>e085	a8					.byte $a8                             ; $0087 (
>e086	a9					.byte $a9                             ; $0088 )
>e087	aa					.byte $aa                             ; $0089 *
>e088	ab					.byte $ab                             ; $008a +
>e089	ac					.byte $ac                             ; $008b ,
>e08a	ad					.byte $ad                             ; $008c -
>e08b	af					.byte $af                             ; $008d /
>e08c	ba					.byte $ba                             ; $008e :
>e08d	bb					.byte $bb                             ; $008f ;
>e08e	3c bd					.byte $3c,$bd                         ; $0090 <=
>e090	3c be					.byte $3c,$be                         ; $0091 <>
>e092	bc					.byte $bc                             ; $0092 <
>e093	bd					.byte $bd                             ; $0093 =
>e094	3e bd					.byte $3e,$bd                         ; $0094 >=
>e096	be					.byte $be                             ; $0095 >
>e097	bf					.byte $bf                             ; $0096 ?
>e098	de					.byte $de                             ; $0097 ^
>e099	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0098 assert
>e09f	41 42 d3				.byte $41,$42,$d3                     ; $0099 abs
>e0a2	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $009a clear
>e0a7	43 4c d3				.byte $43,$4c,$d3                     ; $009b cls
>e0aa	43 50 d5				.byte $43,$50,$d5                     ; $009c cpu
>e0ad	43 c8					.byte $43,$c8                         ; $009d ch
>e0af	44 49 cd				.byte $44,$49,$cd                     ; $009e dim
>e0b2	44 cf					.byte $44,$cf                         ; $009f do
>e0b4	45 4c 53 c5				.byte $45,$4c,$53,$c5                 ; $00a0 else
>e0b8	45 4e c4				.byte $45,$4e,$c4                     ; $00a1 end
>e0bb	46 4f d2				.byte $46,$4f,$d2                     ; $00a2 for
>e0be	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $00a3 gosub
>e0c3	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $00a4 goto
>e0c7	47 45 d4				.byte $47,$45,$d4                     ; $00a5 get
>e0ca	49 4f 41 44 44 d2			.byte $49,$4f,$41,$44,$44,$d2         ; $00a6 ioaddr
>e0d0	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a7 input
>e0d5	49 c6					.byte $49,$c6                         ; $00a8 if
>e0d7	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a9 list
>e0db	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00aa link
>e0df	4c 45 d4				.byte $4c,$45,$d4                     ; $00ab let
>e0e2	4c 45 ce				.byte $4c,$45,$ce                     ; $00ac len
>e0e5	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00ad next
>e0e9	4e 45 d7				.byte $4e,$45,$d7                     ; $00ae new
>e0ec	4f 4c c4				.byte $4f,$4c,$c4                     ; $00af old
>e0ef	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00b0 print
>e0f4	50 41 47 c5				.byte $50,$41,$47,$c5                 ; $00b1 page
>e0f8	52 45 54 55 52 ce			.byte $52,$45,$54,$55,$52,$ce         ; $00b2 return
>e0fe	52 45 cd				.byte $52,$45,$cd                     ; $00b3 rem
>e101	52 55 ce				.byte $52,$55,$ce                     ; $00b4 run
>e104	52 53 d4				.byte $52,$53,$d4                     ; $00b5 rst
>e107	52 4e c4				.byte $52,$4e,$c4                     ; $00b6 rnd
>e10a	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00b7 stop
>e10e	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00b8 step
>e112	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b9 then
>e116	54 4f d0				.byte $54,$4f,$d0                     ; $00ba top
>e119	54 cf					.byte $54,$cf                         ; $00bb to
>e11b	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc             ; $00bc until
>e120	fc					.byte $fc                             ; $00bd |
>e121	fe					.byte $fe                             ; $00be ~
>e122	00					.byte $00
.e123					TokenTypeInformation:
>e123	04					.byte $04                             ; $0080 !
>e124	0a					.byte $0a                             ; $0081 "
>e125	0a					.byte $0a                             ; $0082 #
>e126	04					.byte $04                             ; $0083 $
>e127	03					.byte $03                             ; $0084 %
>e128	00					.byte $00                             ; $0085 &
>e129	0a					.byte $0a                             ; $0086 '
>e12a	0a					.byte $0a                             ; $0087 (
>e12b	0a					.byte $0a                             ; $0088 )
>e12c	03					.byte $03                             ; $0089 *
>e12d	02					.byte $02                             ; $008a +
>e12e	0a					.byte $0a                             ; $008b ,
>e12f	02					.byte $02                             ; $008c -
>e130	03					.byte $03                             ; $008d /
>e131	0a					.byte $0a                             ; $008e :
>e132	0a					.byte $0a                             ; $008f ;
>e133	01					.byte $01                             ; $0090 <=
>e134	01					.byte $01                             ; $0091 <>
>e135	01					.byte $01                             ; $0092 <
>e136	01					.byte $01                             ; $0093 =
>e137	01					.byte $01                             ; $0094 >=
>e138	01					.byte $01                             ; $0095 >
>e139	04					.byte $04                             ; $0096 ?
>e13a	00					.byte $00                             ; $0097 ^
>e13b	08					.byte $08                             ; $0098 assert
>e13c	09					.byte $09                             ; $0099 abs
>e13d	08					.byte $08                             ; $009a clear
>e13e	08					.byte $08                             ; $009b cls
>e13f	09					.byte $09                             ; $009c cpu
>e140	09					.byte $09                             ; $009d ch
>e141	08					.byte $08                             ; $009e dim
>e142	08					.byte $08                             ; $009f do
>e143	08					.byte $08                             ; $00a0 else
>e144	08					.byte $08                             ; $00a1 end
>e145	08					.byte $08                             ; $00a2 for
>e146	08					.byte $08                             ; $00a3 gosub
>e147	08					.byte $08                             ; $00a4 goto
>e148	09					.byte $09                             ; $00a5 get
>e149	09					.byte $09                             ; $00a6 ioaddr
>e14a	08					.byte $08                             ; $00a7 input
>e14b	08					.byte $08                             ; $00a8 if
>e14c	08					.byte $08                             ; $00a9 list
>e14d	08					.byte $08                             ; $00aa link
>e14e	08					.byte $08                             ; $00ab let
>e14f	09					.byte $09                             ; $00ac len
>e150	08					.byte $08                             ; $00ad next
>e151	08					.byte $08                             ; $00ae new
>e152	08					.byte $08                             ; $00af old
>e153	08					.byte $08                             ; $00b0 print
>e154	09					.byte $09                             ; $00b1 page
>e155	08					.byte $08                             ; $00b2 return
>e156	08					.byte $08                             ; $00b3 rem
>e157	08					.byte $08                             ; $00b4 run
>e158	08					.byte $08                             ; $00b5 rst
>e159	09					.byte $09                             ; $00b6 rnd
>e15a	08					.byte $08                             ; $00b7 stop
>e15b	08					.byte $08                             ; $00b8 step
>e15c	08					.byte $08                             ; $00b9 then
>e15d	09					.byte $09                             ; $00ba top
>e15e	08					.byte $08                             ; $00bb to
>e15f	08					.byte $08                             ; $00bc until
>e160	00					.byte $00                             ; $00bd |
>e161	01					.byte $01                             ; $00be ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_COMMA = $008b
=$008c					KW_MINUS = $008c
=$008d					KW_FSLASH = $008d
=$008e					KW_COLON = $008e
=$008f					KW_SEMICOLON = $008f
=$0090					KW_LESSEQUAL = $0090
=$0091					KW_LESSGREATER = $0091
=$0092					KW_LESS = $0092
=$0093					KW_EQUAL = $0093
=$0094					KW_GREATEREQUAL = $0094
=$0095					KW_GREATER = $0095
=$0096					KW_QUESTION = $0096
=$0097					KW_HAT = $0097
=$0098					KW_ASSERT = $0098
=$0099					KW_ABS = $0099
=$009a					KW_CLEAR = $009a
=$009b					KW_CLS = $009b
=$009c					KW_CPU = $009c
=$009d					KW_CH = $009d
=$009e					KW_DIM = $009e
=$009f					KW_DO = $009f
=$00a0					KW_ELSE = $00a0
=$00a1					KW_END = $00a1
=$00a2					KW_FOR = $00a2
=$00a3					KW_GOSUB = $00a3
=$00a4					KW_GOTO = $00a4
=$00a5					KW_GET = $00a5
=$00a6					KW_IOADDR = $00a6
=$00a7					KW_INPUT = $00a7
=$00a8					KW_IF = $00a8
=$00a9					KW_LIST = $00a9
=$00aa					KW_LINK = $00aa
=$00ab					KW_LET = $00ab
=$00ac					KW_LEN = $00ac
=$00ad					KW_NEXT = $00ad
=$00ae					KW_NEW = $00ae
=$00af					KW_OLD = $00af
=$00b0					KW_PRINT = $00b0
=$00b1					KW_PAGE = $00b1
=$00b2					KW_RETURN = $00b2
=$00b3					KW_REM = $00b3
=$00b4					KW_RUN = $00b4
=$00b5					KW_RST = $00b5
=$00b6					KW_RND = $00b6
=$00b7					KW_STOP = $00b7
=$00b8					KW_STEP = $00b8
=$00b9					KW_THEN = $00b9
=$00ba					KW_TOP = $00ba
=$00bb					KW_TO = $00bb
=$00bc					KW_UNTIL = $00bc
=$00bd					KW_BAR = $00bd
=$00be					KW_TILDE = $00be

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e162					SyntaxError:
.e162	20 72 e1	jsr $e172			jsr 	ReportError
>e165	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e16d	52 52 4f 52 00
.e172					ReportError:
.e172	fa		plx				plx
.e173	7a		ply				ply
.e174	e8		inx				inx
.e175	d0 01		bne $e178			bne 	_REPrint
.e177	c8		iny				iny
.e178					_REPrint:
.e178	20 15 e5	jsr $e515			jsr 	SIOPrintString
.e17b	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e17d	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e17f	f0 13		beq $e194			beq 	_RENoLineNumber
.e181	a2 9c		ldx #$9c			ldx 	#_REAt & $FF
.e183	a0 e1		ldy #$e1			ldy 	#_REAt >> 8
.e185	20 15 e5	jsr $e515			jsr 	SIOPrintString
.e188	a0 01		ldy #$01			ldy 	#1
.e18a	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e18c	aa		tax				tax
.e18d	c8		iny				iny
.e18e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e190	a8		tay				tay
.e191	20 a1 e1	jsr $e1a1			jsr 	PrintWordInteger
.e194					_RENoLineNumber:
.e194	a9 0d		lda #$0d			lda 	#13
.e196	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.e199	4c 14 f3	jmp $f314			jmp 	WarmStart
>e19c	20 41 54 20 00			_REAt:	.text 	" AT ",0
.e1a1					PrintWordInteger:
.e1a1	8a		txa				txa
.e1a2	a2 00		ldx #$00			ldx 	#0
.e1a4	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1a7	98		tya				tya
.e1a8	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1ab	c8		iny				iny
.e1ac	a9 00		lda #$00			lda 	#0
.e1ae	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e1b1	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e1b4	20 09 f2	jsr $f209			jsr 	CPRPrintInteger
.e1b7	60		rts				rts
.e1b8					CheckNextCharacter:
.e1b8	8d c0 20	sta $20c0			sta 	Temp1 						; save character to check
.e1bb					_CNCLoop:
.e1bb	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e1bd	f0 0b		beq $e1ca			beq 	_CNCFail 					; end of line, so no character
.e1bf	c8		iny				iny
.e1c0	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e1c2	f0 f7		beq $e1bb			beq 	_CNCLoop
.e1c4	cd c0 20	cmp $20c0			cmp 	Temp1 						; fail if not what was wanted
.e1c7	d0 01		bne $e1ca			bne 	_CNCFail
.e1c9	60		rts				rts
.e1ca					_CNCFail:
.e1ca	20 72 e1	jsr $e172			jsr 	ReportError
>e1cd	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e1d5	54 4f 4b 45 4e 00
.e1db					CopyBasicCode:
.e1db	a9 75		lda #$75			lda 	#IncludeBasicCode & $FF
.e1dd	85 24		sta $24				sta 	zTemp1
.e1df	a9 b1		lda #$b1			lda 	#IncludeBasicCode >> 8
.e1e1	85 25		sta $25				sta 	zTemp1+1
.e1e3	a9 00		lda #$00			lda 	#BasicProgram & $FF
.e1e5	85 26		sta $26				sta 	zTemp2
.e1e7	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e1e9	85 27		sta $27				sta 	zTemp2+1
.e1eb					_CopyLoop:
.e1eb	a0 00		ldy #$00			ldy 	#0
.e1ed	b1 24		lda ($24),y			lda 	(zTemp1),y
.e1ef	91 26		sta ($26),y			sta 	(zTemp2),y
.e1f1	e6 24		inc $24				inc 	zTemp1
.e1f3	d0 02		bne $e1f7			bne 	_Copy1
.e1f5	e6 25		inc $25				inc 	zTemp1+1
.e1f7					_Copy1:
.e1f7	e6 26		inc $26				inc 	zTemp2
.e1f9	d0 02		bne $e1fd			bne 	_Copy2
.e1fb	e6 27		inc $27				inc 	zTemp2+1
.e1fd					_Copy2:
.e1fd	a5 24		lda $24				lda 	zTemp1
.e1ff	c9 b3		cmp #$b3			cmp 	#EndBasicCode & $FF
.e201	d0 e8		bne $e1eb			bne 	_CopyLoop
.e203	a5 25		lda $25				lda 	zTemp1+1
.e205	c9 b2		cmp #$b2			cmp 	#EndBasicCode >> 8
.e207	d0 e2		bne $e1eb			bne 	_CopyLoop
.e209	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e20a							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0024					zTemp1:			.word 	?					; temporary vars
>0026					zTemp2:			.word 	?
>0028					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>20be					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>20c0					Temp1:			.dword	?					; 4 byte temporary stores.
>20c4					SignCount:		.byte 	? 					; count of signs in divide.
>20c5					StringBufferPos:.byte 	? 					; next free slot in string buffer
>20c6					RandomSeed 		.word 	? 					; Random Number
>20c8					xCursor 		.byte 	? 					; cursor position
>20c9					yCursor 		.byte 	?
>20ca					breakCheckCount	.byte 	?					; how often check for break.
>20cb					basicStackIndex	.byte 	? 					; index into Basic Stack.
>20cc					registers		.fill 	5 					; A X Y Z P registers in/out for LINK.
>20d1					linkaddress	 	.fill 	2
>20d3									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e20a					EvaluateSNError:
.e20a	4c 62 e1	jmp $e162			jmp 	SyntaxError
.e20d					EvaluateMissingQuote:
.e20d	20 72 e1	jsr $e172			jsr 	ReportError
>e210	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e218	51 55 4f 54 45 00
.e21e					EvaluateStringFull:
.e21e	20 72 e1	jsr $e172			jsr 	ReportError
>e221	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e229	55 46 46 45 52 20 46 55 4c 4c 00
.e234					EvaluateBadHex:
.e234	20 72 e1	jsr $e172			jsr 	ReportError
>e237	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e23f					EvaluateAtomCurrentLevel:
.e23f	a9 07		lda #$07			lda 	#7
.e241	80 04		bra $e247			bra 	EvaluateAtPrecedenceLevel
.e243					EvaluateBase:
.e243	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e245					EvaluateBaseCurrentLevel:
.e245	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e247					EvaluateAtPrecedenceLevel:
.e247	48		pha				pha 								; save precedence level
.e248	a9 00		lda #$00			lda 	#0 							; zero the result.
.e24a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e24d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e250	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e253	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e256					_EVALSkipSpace1:
.e256	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e258	f0 b0		beq $e20a			beq 	EvaluateSNError 			; end of line, without token.
.e25a	c8		iny				iny
.e25b	c9 20		cmp #$20			cmp 	#32
.e25d	f0 f7		beq $e256			beq 	_EVALSkipSpace1
.e25f	88		dey				dey 								; points at the token.
.e260	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e262	f0 14		beq $e278			beq 	_EVALString  				; if so load in a constant string
.e264	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e266	f0 36		beq $e29e			beq 	_EVALHexadecimal
.e268	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e26a	90 04		bcc $e270			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e26c	c9 3a		cmp #$3a			cmp 	#'9'+1
.e26e	90 03		bcc $e273			bcc 	_EVALDecimal
.e270					_EVALGoKeywordVariable:
.e270	4c f5 e2	jmp $e2f5			jmp 	_EVALKeywordVariable
.e273					_EVALDecimal:
.e273	20 52 e3	jsr $e352			jsr 	EVALGetDecConstant 			; get decimal constant
.e276	80 34		bra $e2ac			bra 	_EVALGotAtom 				; got atom.
.e278					_EVALString:
.e278	da		phx				phx 								; save X on stack
.e279	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e27b	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e27e	ad c5 20	lda $20c5			lda 	StringBufferPos 			; X = Buffer Position.
.e281	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e284	aa		tax				tax 								; put in X to build the string.
.e285	c8		iny				iny 								; skip over opening quote character
.e286					_EVALStringCopy:
.e286	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e288	c8		iny				iny
.e289	f0 82		beq $e20d			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e28b	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e28e	e8		inx				inx 								; and bump that pointer.
.e28f	f0 8d		beq $e21e			beq 	EvaluateStringFull 			; buffer is full.
.e291	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e293	d0 f1		bne $e286			bne 	_EVALStringCopy
.e295	8e c5 20	stx $20c5			stx 	StringBufferPos 			; this is the new next free slot.
.e298	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e29b	fa		plx				plx 								; restore X
.e29c	80 0e		bra $e2ac			bra 	_EVALGotAtom 				; got the atom.
.e29e					_EVALHexaDecimal
.e29e	c8		iny				iny 								; skip over the '#'
.e29f	5a		phy				phy 								; save Y
.e2a0	20 be e3	jsr $e3be			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e2a3	8c c0 20	sty $20c0			sty 	Temp1 						; has Y changed ?
.e2a6	68		pla				pla
.e2a7	cd c0 20	cmp $20c0			cmp 	Temp1
.e2aa	f0 88		beq $e234			beq 	EvaluateBadHex 				; if not, error.
.e2ac					_EVALGotAtom:
.e2ac					_EVALGetOperator:
.e2ac	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e2ae	c8		iny				iny 								; this should be binary operator
.e2af	c9 20		cmp #$20			cmp 	#$20
.e2b1	f0 f9		beq $e2ac			beq 	_EVALGetOperator
.e2b3	88		dey				dey
.e2b4	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e2b6	10 3b		bpl $e2f3			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e2b8	da		phx				phx 								; save X
.e2b9	aa		tax				tax 								; token in X
.e2ba	bd a3 e0	lda $e0a3,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e2bd	8d c0 20	sta $20c0			sta 	Temp1 						; save precedence in Temp1
.e2c0	fa		plx				plx 								; restore X
.e2c1	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e2c3	b0 2e		bcs $e2f3			bcs 	_EVALExitPullA
.e2c5	68		pla				pla 								; get and save precedence level.
.e2c6	48		pha				pha
.e2c7	cd c0 20	cmp $20c0			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e2ca	f0 02		beq $e2ce			beq 	_EVALDoCalc					; equal, do it.
.e2cc	b0 25		bcs $e2f3			bcs 	_EVALExitPullA				; too high, then exit.
.e2ce					_EVALDoCalc:
.e2ce	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e2d0	c8		iny				iny
.e2d1	48		pha				pha
.e2d2	da		phx				phx
.e2d3	e8		inx				inx 								; work out right hand side.
.e2d4	e8		inx				inx
.e2d5	e8		inx				inx
.e2d6	e8		inx				inx
.e2d7	ad c0 20	lda $20c0			lda 	Temp1 						; get current operator precedence level.
.e2da	1a		inc a				inc 	a 							; so work it out at the next level.
.e2db	20 47 e2	jsr $e247			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e2de	fa		plx				plx 								; fix X back.
.e2df	68		pla				pla 								; get keyword
.e2e0					_EVALExecuteA:
.e2e0	0a		asl a				asl 	a 							; shift left, drop bit 7
.e2e1	8d c1 20	sta $20c1			sta 	Temp1+1						; save in Temp1.1
.e2e4	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e2e6	8d c2 20	sta $20c2			sta 	Temp1+2 					; set at Temp1.2
.e2e9	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e2eb	8d c0 20	sta $20c0			sta 	Temp1+0
.e2ee	20 c0 20	jsr $20c0			jsr 	Temp1 						; call that routine.
.e2f1	80 b9		bra $e2ac			bra 	_EVALGotAtom 				; and loop back again.
.e2f3					_EVALExitPullA:
.e2f3	68		pla				pla 								; restore precedence.
.e2f4	60		rts				rts
.e2f5					_EVALKeywordVariable:
.e2f5	09 00		ora #$00			ora 	#0 							; check bit 7
.e2f7	10 0f		bpl $e308			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e2f9	da		phx				phx
.e2fa	aa		tax				tax
.e2fb	bd a3 e0	lda $e0a3,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e2fe	fa		plx				plx
.e2ff	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e301	d0 05		bne $e308			bne 	_EVALNotUnaryFunction
.e303	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e305	c8		iny				iny 								; consume it
.e306	80 d8		bra $e2e0			bra 	_EVALExecuteA 				; execute TOS.
.e308					_EVALNotUnaryFunction:
.e308	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e30a	10 3d		bpl $e349			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e30c	c9 8c		cmp #$8c			cmp 	#KW_MINUS 					; check negation
.e30e	f0 0f		beq $e31f			beq 	_EVALUnaryNegation
.e310	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e312	d0 14		bne $e328			bne		_EVALCheckUnaryOperator
.e314	c8		iny				iny 								; skip left bracket.
.e315	20 45 e2	jsr $e245			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e318	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e31a	20 b8 e1	jsr $e1b8			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e31d	80 8d		bra $e2ac			bra 	_EVALGotAtom
.e31f					_EVALUnaryNegation:
.e31f	c8		iny				iny 								; skip over the - sign.
.e320	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e323	20 c0 ea	jsr $eac0			jsr 	BFUNC_NegateAlways 			; negate it.
.e326	80 84		bra $e2ac			bra 	_EVALGotAtom
.e328					_EVALCheckUnaryOperator:
.e328	48		pha				pha 								; save indirection operator.
.e329	c8		iny				iny 								; skip over the operator
.e32a	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e32d	68		pla				pla 								; restore the operator
.e32e	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e330	f0 0e		beq $e340			beq 	_EVALGoGotAtom
.e332	c9 96		cmp #$96			cmp 	#KW_QUESTION				; byte indirection
.e334	f0 07		beq $e33d			beq 	_EVALByteRead
.e336	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e338	f0 09		beq $e343			beq 	_EVALWordRead
.e33a	4c 62 e1	jmp $e162			jmp 	SyntaxError 				; give up.
.e33d					_EVALByteRead:
.e33d	20 fd e3	jsr $e3fd			jsr 	EVALReadByteIndirect
.e340					_EVALGoGotAtom:
.e340	4c ac e2	jmp $e2ac			jmp 	_EVALGotAtom
.e343					_EVALWordRead:
.e343	20 33 e4	jsr $e433			jsr 	EVALReadWordIndirect
.e346	4c ac e2	jmp $e2ac			jmp 	_EVALGotAtom
.e349					_EVALCheckVariable:
.e349	20 88 e4	jsr $e488			jsr 	VARReference 				; get variable reference to ZTemp1
.e34c	20 47 e4	jsr $e447			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e34f	4c ac e2	jmp $e2ac			jmp 	_EVALGotAtom 				; and go round.
.e352					EVALGetDecConstant:
.e352	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e354	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e356	90 04		bcc $e35c			bcc 	_EVGDExit
.e358	c9 3a		cmp #$3a			cmp 	#'9'+1
.e35a	90 01		bcc $e35d			bcc 	_EVGDValue 					; if so has legal value
.e35c					_EVGDExit:
.e35c	60		rts				rts
.e35d					_EVGDValue:
.e35d	48		pha				pha 								; save value, Y on stack
.e35e	5a		phy				phy
.e35f	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e361	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e364	48		pha				pha
.e365	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e368	48		pha				pha
.e369	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e36c	48		pha				pha
.e36d	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e370	48		pha				pha
.e371					_EVGDLoop:
.e371	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e374	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e377	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e37a	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e37d	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e37f	d0 1d		bne $e39e			bne 	_EVGDNoAdd
.e381	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e382	68		pla				pla
.e383	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e386	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e389	68		pla				pla
.e38a	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e38d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e390	68		pla				pla
.e391	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e394	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e397	68		pla				pla
.e398	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e39b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e39e					_EVGDNoAdd:
.e39e	88		dey				dey
.e39f	d0 d0		bne $e371			bne 	_EVGDLoop
.e3a1	7a		ply				ply 								; restore YA
.e3a2	68		pla				pla
.e3a3	c8		iny				iny 								; next character
.e3a4	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e3a6	18		clc				clc
.e3a7	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e3aa	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3ad	90 a3		bcc $e352			bcc 	EVALGetDecConstant 			; propogate constant through
.e3af	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e3b2	d0 9e		bne $e352			bne 	EVALGetDecConstant
.e3b4	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e3b7	d0 99		bne $e352			bne 	EVALGetDecConstant
.e3b9	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e3bc	80 94		bra $e352			bra 	EVALGetDecConstant 			; go back and try again.
.e3be					EVALGetHexConstant:
.e3be	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e3c0	20 f2 e3	jsr $e3f2			jsr 	EVALToUpper 				; make upper case
.e3c3	38		sec				sec
.e3c4	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e3c6	90 0a		bcc $e3d2			bcc 	_EVGHExit 					; exit if CC
.e3c8	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e3ca	90 07		bcc $e3d3			bcc 	_EVGHValue
.e3cc	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e3ce	c9 10		cmp #$10			cmp 	#15+1
.e3d0	90 01		bcc $e3d3			bcc 	_EVGHValue
.e3d2					_EVGHExit:
.e3d2	60		rts				rts
.e3d3					_EVGHValue:
.e3d3	5a		phy				phy 								; save Y and new digit.
.e3d4	48		pha				pha
.e3d5	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e3d7					_EVGHRotate:
.e3d7	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e3da	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e3dd	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e3e0	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e3e3	88		dey				dey
.e3e4	d0 f1		bne $e3d7			bne 	_EVGHRotate
.e3e6	68		pla				pla 								; restore digit and X
.e3e7	7a		ply				ply
.e3e8	c8		iny				iny 								; next character
.e3e9	18		clc				clc
.e3ea	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e3ed	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3f0	80 cc		bra $e3be			bra 	EVALGetHexConstant 			; go back and try again.
.e3f2					EVALToUpper:
.e3f2	c9 61		cmp #$61			cmp 	#'a'
.e3f4	90 06		bcc $e3fc			bcc 	_EVTUExit
.e3f6	c9 7b		cmp #$7b			cmp 	#'z'+1
.e3f8	b0 02		bcs $e3fc			bcs 	_EVTUExit
.e3fa	49 20		eor #$20			eor 	#32
.e3fc					_EVTUExit:
.e3fc	60		rts				rts
.e3fd					EVALReadByteIndirect:
.e3fd	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e400	85 24		sta $24				sta 	zTemp1
.e402	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e405	85 25		sta $25				sta 	zTemp1+1
.e407	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e40a	85 26		sta $26				sta 	zTemp1+2
.e40c	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e40f	85 27		sta $27				sta 	zTemp1+3
.e411	a5 26		lda $26				lda 	zTemp1+2 					; address $0000xxxx
.e413	05 27		ora $27				ora 	zTemp1+3
.e415	f0 07		beq $e41e			beq 	_ERBBase
.e417	a3 00		ldz #$00			ldz 	#0 							; read from far memory.
.e419	ea		nop				nop
.e41a	b2 24		lda ($24),z			lda 	(zTemp1),z
.e41c	80 06		bra $e424			bra 	_ERBExit
.e41e					_ERBBase:
.e41e	5a		phy				phy
.e41f	a0 00		ldy #$00			ldy 	#0 							; read byte
.e421	b1 24		lda ($24),y			lda 	(zTemp1),y
.e423	7a		ply				ply
.e424					_ERBExit:
.e424	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e427	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e429	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e42c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e42f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e432	60		rts				rts
.e433					EVALReadWordIndirect:
.e433	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e436	85 24		sta $24				sta 	zTemp1
.e438	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e43b	85 25		sta $25				sta 	zTemp1+1
.e43d	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e440	85 26		sta $26				sta 	zTemp1+2
.e442	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e445	85 27		sta $27				sta 	zTemp1+3
.e447					EVALReadWordIndirectZTemp:
.e447	a5 26		lda $26				lda 	zTemp1+2 					; address $0000xxxx
.e449	05 27		ora $27				ora 	zTemp1+3
.e44b	f0 1f		beq $e46c			beq 	_ERWBase
.e44d	a3 00		ldz #$00			ldz 	#0 							; read from far memory.
.e44f	ea		nop				nop
.e450	b2 24		lda ($24),z			lda 	(zTemp1),z
.e452	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e455	1b		inz				inz
.e456	ea		nop				nop
.e457	b2 24		lda ($24),z			lda 	(zTemp1),z
.e459	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e45c	1b		inz				inz
.e45d	ea		nop				nop
.e45e	b2 24		lda ($24),z			lda 	(zTemp1),z
.e460	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e463	1b		inz				inz
.e464	ea		nop				nop
.e465	b2 24		lda ($24),z			lda 	(zTemp1),z
.e467	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e46a	80 1b		bra $e487			bra 	_ERWExit
.e46c					_ERWBase
.e46c	5a		phy				phy
.e46d	a0 00		ldy #$00			ldy 	#0 							; read word
.e46f	b1 24		lda ($24),y			lda 	(zTemp1),y
.e471	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e474	c8		iny				iny
.e475	b1 24		lda ($24),y			lda 	(zTemp1),y
.e477	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e47a	c8		iny				iny
.e47b	b1 24		lda ($24),y			lda 	(zTemp1),y
.e47d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e480	c8		iny				iny
.e481	b1 24		lda ($24),y			lda 	(zTemp1),y
.e483	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e486	7a		ply				ply
.e487					_ERWExit:
.e487	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e488					VARReference:
.e488	38		sec				sec 								; check range @-Z there
.e489	c9 40		cmp #$40			cmp 	#'@'
.e48b	90 04		bcc $e491			bcc 	_VARRError
.e48d	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e48f	90 03		bcc $e494			bcc 	_VARROkay
.e491					_VARRError:
.e491	4c 62 e1	jmp $e162			jmp		SyntaxError
.e494					_VARROkay:
.e494	c8		iny				iny 								; consume the variable.
.e495	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e497	f0 1b		beq $e4b4			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e499	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e49b	88		dey				dey 								; point back to the first character
.e49c	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e49e	f0 14		beq $e4b4			beq 	_VARArrayAccess
.e4a0	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e4a2	c8		iny				iny
.e4a3	29 1f		and #$1f			and		#31 						; mask out
.e4a5	0a		asl a				asl 	a 							; x 4
.e4a6	0a		asl a				asl 	a
.e4a7	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e4a9	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e4ab	85 25		sta $25				sta 	zTemp1+1
.e4ad	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e4af	85 26		sta $26				sta 	zTemp1+2
.e4b1	85 27		sta $27				sta 	zTemp1+3 					; return with address set.
.e4b3	60		rts				rts
.e4b4					_VARArrayAccess:
.e4b4	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e4b6	c8		iny				iny
.e4b7	29 1f		and #$1f			and 	#31 						; mask it off
.e4b9	48		pha				pha 								; save on the stack.
.e4ba	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e4bd	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e4c0	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e4c3	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e4c6	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e4c9	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e4cc	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e4cf	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e4d2	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e4d5	68		pla				pla 								; put address in zTemp1
.e4d6	0a		asl a				asl 	a 							; x 4
.e4d7	0a		asl a				asl 	a
.e4d8	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e4da	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e4dc	85 25		sta $25				sta 	zTemp1+1
.e4de	5a		phy				phy
.e4df	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e4e1	b1 24		lda ($24),y			lda 	(zTemp1),y
.e4e3	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e4e6	48		pha				pha 								; save first result as we need the indirection.
.e4e7	c8		iny				iny 								; 2nd byte
.e4e8	b1 24		lda ($24),y			lda 	(zTemp1),y
.e4ea	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e4ed	85 25		sta $25				sta 	zTemp1+1
.e4ef	68		pla				pla 								; save the low byte.
.e4f0	85 24		sta $24				sta 	zTemp1+0
.e4f2	a9 00		lda #$00			lda 	#0
.e4f4	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e4f7	85 26		sta $26				sta 	zTemp1+2
.e4f9	a9 00		lda #$00			lda 	#0
.e4fb	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e4fe	85 27		sta $27				sta 	zTemp1+3
.e500	7a		ply				ply 								; restore Y, address setup
.e501	60		rts				rts
.e502	80 fe		bra $e502	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e504					SIOInitialise:
.e504	20 d6 b0	jsr $b0d6			jsr 	EXTReset 					; reset video
.e507					SIOClearScreen:
.e507	20 86 b0	jsr $b086			jsr 	EXTClearScreen 				; clear screen
.e50a					SIOHomeCursor:
.e50a	48		pha				pha 								; home cursor
.e50b	a9 00		lda #$00			lda 	#0
.e50d	8d c8 20	sta $20c8			sta 	xCursor
.e510	8d c9 20	sta $20c9			sta 	yCursor
.e513	68		pla				pla
.e514	60		rts				rts
.e515					SIOPrintString:
.e515	48		pha				pha 								; save registers
.e516	da		phx				phx
.e517	5a		phy				phy
.e518	86 26		stx $26				stx 	zTemp2 						; set up indirect pointer
.e51a	84 27		sty $27				sty 	zTemp2+1
.e51c	a0 00		ldy #$00			ldy 	#0
.e51e					_SIOPSLoop:
.e51e	b1 26		lda ($26),y			lda 	(zTemp2),y 					; read next, exit if 0
.e520	f0 1c		beq $e53e			beq 	_SIOPSExit
.e522	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter 			; print and bump
.e525	c8		iny				iny
.e526	d0 f6		bne $e51e			bne 	_SIOPSLoop
.e528	20 72 e1	jsr $e172			jsr 	ReportError
>e52b	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e533	4e 47 20 50 52 49 4e 54 45 44 00
.e53e					_SIOPSExit:
.e53e	7a		ply				ply 								; restore and exit.
.e53f	fa		plx				plx
.e540	68		pla				pla
.e541	60		rts				rts
.e542					SIOPrintCharacter:
.e542	48		pha				pha 								; save AXY
.e543	da		phx				phx
.e544	5a		phy				phy
.e545	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e547	f0 16		beq $e55f			beq 	_SIOPReturn
.e549	c9 09		cmp #$09			cmp 	#9
.e54b	f0 2b		beq $e578			beq 	_SIOPTab
.e54d	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor 				; load cursor position in.
.e550	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e552	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen 				; write character out.
.e555	ee c8 20	inc $20c8			inc 	xCursor 					; move right
.e558	ad c8 20	lda $20c8			lda 	xCursor 					; reached the RHS
.e55b	c9 50		cmp #$50			cmp 	#EXTWidth
.e55d	90 15		bcc $e574			bcc 	_SIOPExit
.e55f					_SIOPReturn:
.e55f	a9 00		lda #$00			lda 	#0 							; zero x
.e561	8d c8 20	sta $20c8			sta 	xCursor
.e564	ee c9 20	inc $20c9			inc 	yCursor 					; go down
.e567	ad c9 20	lda $20c9			lda 	yCursor
.e56a	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e56c	90 06		bcc $e574			bcc 	_SIOPExit
.e56e	20 a4 b0	jsr $b0a4			jsr 	EXTScrollDisplay 			; scroll display up
.e571	ce c9 20	dec $20c9			dec 	yCursor 					; cursor on bottom line.
.e574					_SIOPExit:
.e574	7a		ply				ply 								; restore and exit.
.e575	fa		plx				plx
.e576	68		pla				pla
.e577	60		rts				rts
.e578					_SIOPTab:
.e578	a9 20		lda #$20			lda 	#32 						; tab.
.e57a	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.e57d	ad c8 20	lda $20c8			lda 	xCursor
.e580	29 07		and #$07			and 	#7
.e582	d0 f4		bne $e578			bne 	_SIOPTab
.e584	80 ee		bra $e574			bra 	_SIOPExit
.e586					SIOGetKey:
.e586	20 0c b0	jsr $b00c			jsr 	EXTReadKeyPort 				; wait for a key
.e589	f0 fb		beq $e586			beq 	SIOGetKey
.e58b	20 f2 e3	jsr $e3f2			jsr 	EVALToUpper 				; capitalise it.
.e58e	4c 35 b0	jmp $b035			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e591					SIOReadLine:
.e591	48		pha				pha 								; save registers
.e592	da		phx				phx
.e593	5a		phy				phy
.e594					_SIORLoop:
.e594	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor 				; cursor in XY
.e597	20 6b b0	jsr $b06b			jsr 	EXTReadScreen 				; read the display.
.e59a	48		pha				pha 								; save on stack.
.e59b	a9 66		lda #$66			lda 	#102 						; write cursor out
.e59d	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen
.e5a0	20 86 e5	jsr $e586			jsr 	SIOGetKey
.e5a3	aa		tax				tax 								; save in X
.e5a4	68		pla				pla 								; old character
.e5a5	da		phx				phx 								; save key pressed
.e5a6	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor 				; cursor in XY
.e5a9	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen
.e5ac	68		pla				pla
.e5ad	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e5af	f0 29		beq $e5da			beq 	_SIOCursorLeft
.e5b1	c9 13		cmp #$13			cmp 	#"S"-64
.e5b3	f0 49		beq $e5fe			beq 	_SIOCursorDown
.e5b5	c9 04		cmp #$04			cmp 	#"D"-64
.e5b7	f0 2d		beq $e5e6			beq 	_SIOCursorRight
.e5b9	c9 17		cmp #$17			cmp 	#"W"-64
.e5bb	f0 35		beq $e5f2			beq 	_SIOCursorUp
.e5bd	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e5bf	f0 49		beq $e60a			beq 	_SIOClearScreen
.e5c1	c9 08		cmp #$08			cmp 	#"H"-64
.e5c3	f0 4a		beq $e60f			beq 	_SIOBackspace
.e5c5	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e5c7	f0 0e		beq $e5d7			beq 	_SIOGoReturn
.e5c9	c9 20		cmp #$20			cmp 	#32 						; any control
.e5cb	90 c7		bcc $e594			bcc 	_SIORLoop
.e5cd	48		pha				pha
.e5ce	20 4d e6	jsr $e64d			jsr 	_SIOInsert 					; insert a space for new character
.e5d1	68		pla				pla
.e5d2	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter 			; print character in A
.e5d5	80 bd		bra $e594			bra 	_SIORLoop
.e5d7					_SIOGoReturn:
.e5d7	4c 78 e6	jmp $e678			jmp 	_SIOReturn
.e5da					_SIOCursorLeft:
.e5da	ce c8 20	dec $20c8			dec 	xCursor
.e5dd	10 b5		bpl $e594			bpl 	_SIORLoop
.e5df	a9 4f		lda #$4f			lda 	#EXTWidth-1
.e5e1					_SIOWXLoop:
.e5e1	8d c8 20	sta $20c8			sta 	xCursor
.e5e4	80 ae		bra $e594			bra 	_SIORLoop
.e5e6					_SIOCursorRight:
.e5e6	ee c8 20	inc $20c8			inc 	xCursor
.e5e9	ad c8 20	lda $20c8			lda 	xCursor
.e5ec	49 50		eor #$50			eor 	#EXTWidth
.e5ee	d0 a4		bne $e594			bne 	_SIORLoop
.e5f0	80 ef		bra $e5e1			bra 	_SIOWXLoop
.e5f2					_SIOCursorUp:
.e5f2	ce c9 20	dec $20c9			dec 	yCursor
.e5f5	10 9d		bpl $e594			bpl 	_SIORLoop
.e5f7	a9 18		lda #$18			lda 	#EXTHeight-1
.e5f9					_SIOWYLoop:
.e5f9	8d c9 20	sta $20c9			sta 	yCursor
.e5fc	80 96		bra $e594			bra 	_SIORLoop
.e5fe					_SIOCursorDown:
.e5fe	ee c9 20	inc $20c9			inc 	yCursor
.e601	ad c9 20	lda $20c9			lda 	yCursor
.e604	49 19		eor #$19			eor 	#EXTHeight
.e606	d0 8c		bne $e594			bne 	_SIORLoop
.e608	80 ef		bra $e5f9			bra 	_SIOWYLoop
.e60a					_SIOClearScreen:
.e60a	20 07 e5	jsr $e507			jsr 	SIOClearScreen
.e60d	80 85		bra $e594			bra 	_SIORLoop
.e60f					_SIOBackspace:
.e60f	ad c8 20	lda $20c8			lda 	xCursor 					; backspace possible ?
.e612	f0 80		beq $e594			beq 	_SIORLoop 					; start of line, no.
.e614	48		pha				pha 								; save position.
.e615	c9 4f		cmp #$4f			cmp 	#EXTWidth-1 				; not required
.e617	f0 1f		beq $e638			beq 	_SIONoShift
.e619	ce c8 20	dec $20c8			dec 	xCursor
.e61c					_SIOShift2:
.e61c	ee c8 20	inc $20c8			inc 	xCursor 					; copy character backward
.e61f	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e622	20 6b b0	jsr $b06b			jsr 	EXTReadScreen
.e625	ce c8 20	dec $20c8			dec 	xCursor
.e628	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e62b	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen
.e62e	ee c8 20	inc $20c8			inc 	xCursor
.e631	ad c8 20	lda $20c8			lda 	xCursor
.e634	c9 4f		cmp #$4f			cmp 	#EXTWidth-1
.e636	d0 e4		bne $e61c			bne 	_SIOShift2
.e638					_SIONoShift:
.e638	a9 4f		lda #$4f			lda 	#EXTWidth-1 				; space on far end.
.e63a	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e63d	a9 20		lda #$20			lda 	#32
.e63f	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen
.e642	68		pla				pla 								; restore cursor, back one.
.e643	3a		dec a				dec 	a
.e644	8d c8 20	sta $20c8			sta 	xCursor
.e647	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor 				; overwrite
.e64a	4c 94 e5	jmp $e594			jmp	 	_SIORLoop
.e64d					_SIOInsert:
.e64d	ad c8 20	lda $20c8			lda 	xCursor 					; at far right, nothing to do.
.e650	c9 4f		cmp #$4f			cmp 	#EXTWidth-1
.e652	f0 23		beq $e677			beq 	_SIOIExit
.e654	85 26		sta $26				sta 	zTemp2 						; save in temporary workspace.
.e656	a9 4f		lda #$4f			lda 	#EXTWidth-1 				; cursor at far right.
.e658	8d c8 20	sta $20c8			sta 	xCursor
.e65b					_SIOShift:
.e65b	ce c8 20	dec $20c8			dec 	xCursor 					; copy character forward
.e65e	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e661	20 6b b0	jsr $b06b			jsr 	EXTReadScreen
.e664	ee c8 20	inc $20c8			inc 	xCursor
.e667	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e66a	20 7a b0	jsr $b07a			jsr 	EXTWriteScreen
.e66d	ce c8 20	dec $20c8			dec 	xCursor
.e670	ad c8 20	lda $20c8			lda 	xCursor						; until shifted line to this point.
.e673	c5 26		cmp $26				cmp 	zTemp2
.e675	d0 e4		bne $e65b			bne 	_SIOShift
.e677					_SIOIExit:
.e677	60		rts				rts
.e678					_SIOReturn:
.e678	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e67a	8d c8 20	sta $20c8			sta 	xCursor
.e67d					_SIOCopy:
.e67d	20 b2 e6	jsr $e6b2			jsr 	SIOLoadCursor
.e680	20 6b b0	jsr $b06b			jsr 	EXTReadScreen
.e683	49 20		eor #$20			eor 	#$20
.e685	18		clc				clc
.e686	69 20		adc #$20			adc 	#$20
.e688	ae c8 20	ldx $20c8			ldx 	xCursor
.e68b	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e68e	ee c8 20	inc $20c8			inc 	xCursor
.e691	ad c8 20	lda $20c8			lda 	xCursor
.e694	c9 50		cmp #$50			cmp 	#EXTWidth
.e696	d0 e5		bne $e67d			bne 	_SIOCopy
.e698	aa		tax				tax 								; X contains width
.e699					_SIOStrip:
.e699	ca		dex				dex									; back one
.e69a	30 07		bmi $e6a3			bmi		_SIOFound 					; if -ve gone too far
.e69c	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e69f	c9 20		cmp #$20			cmp 	#' '
.e6a1	f0 f6		beq $e699			beq 	_SIOStrip
.e6a3					_SIOFound:
.e6a3	e8		inx				inx
.e6a4	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e6a6	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e6a9	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e6ab	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.e6ae	7a		ply				ply
.e6af	fa		plx				plx
.e6b0	68		pla				pla
.e6b1	60		rts				rts
.e6b2					SIOLoadCursor:
.e6b2	48		pha				pha
.e6b3	ad c9 20	lda $20c9			lda 	yCursor  					; Y Position
.e6b6	0a		asl a				asl 	a 							; x 2 	(80)
.e6b7	0a		asl a				asl 	a 							; x 2 	(160)
.e6b8	6d c9 20	adc $20c9			adc 	yCursor 					; x 5 	(200) (CC)
.e6bb	85 24		sta $24				sta 	zTemp1
.e6bd	a9 00		lda #$00			lda 	#0
.e6bf	85 25		sta $25				sta 	zTemp1+1
.e6c1	06 24		asl $24				asl 	zTemp1						; x 10
.e6c3	26 25		rol $25				rol 	zTemp1+1
.e6c5	06 24		asl $24				asl 	zTemp1						; x 20
.e6c7	26 25		rol $25				rol 	zTemp1+1
.e6c9	06 24		asl $24				asl 	zTemp1						; x 40
.e6cb	26 25		rol $25				rol 	zTemp1+1 					;
.e6cd	06 24		asl $24				asl 	zTemp1						; x 80
.e6cf	26 25		rol $25				rol 	zTemp1+1 					; (CC)
.e6d1	a5 24		lda $24				lda 	zTemp1 						; add X
.e6d3	6d c8 20	adc $20c8			adc 	xCursor
.e6d6	aa		tax				tax
.e6d7	a5 25		lda $25				lda 	zTemp1+1
.e6d9	69 00		adc #$00			adc 	#0
.e6db	a8		tay				tay
.e6dc	68		pla				pla 								; restore and exit
.e6dd	60		rts				rts
.e6de					SIOPrintHex:
.e6de	48		pha				pha
.e6df	48		pha				pha
.e6e0	a9 20		lda #$20			lda 	#32
.e6e2	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.e6e5	68		pla				pla
.e6e6	48		pha				pha
.e6e7	4a		lsr a				lsr 	a
.e6e8	4a		lsr a				lsr 	a
.e6e9	4a		lsr a				lsr 	a
.e6ea	4a		lsr a				lsr 	a
.e6eb	20 f4 e6	jsr $e6f4			jsr 	_SIOPHex
.e6ee	68		pla				pla
.e6ef	20 f4 e6	jsr $e6f4			jsr 	_SIOPHex
.e6f2	68		pla				pla
.e6f3	60		rts				rts
.e6f4					_SIOPHex:
.e6f4	29 0f		and #$0f			and 	#15
.e6f6	c9 0a		cmp #$0a			cmp 	#10
.e6f8	90 02		bcc $e6fc			bcc 	_SIOPHex2
.e6fa	69 06		adc #$06			adc 	#6
.e6fc					_SIOPHex2:
.e6fc	69 30		adc #$30			adc 	#48
.e6fe	4c 42 e5	jmp $e542			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e701					TokeniseString:
.e701	a0 00		ldy #$00			ldy 	#0							; source
.e703	a2 00		ldx #$00			ldx 	#0 							; target
.e705					_TokLoop:
.e705	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get first
.e707	f0 5d		beq $e766			beq 	_TokExit 					; End, exit.
.e709	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e70b	f0 35		beq $e742			beq 	_TokCopy1
.e70d	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e70f	f0 3a		beq $e74b			beq 	_TokCopyString
.e711	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e713	90 22		bcc $e737			bcc 	_TokPunctuation
.e715	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e717	90 29		bcc $e742			bcc 	_TokCopy1
.e719	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e71b	90 1a		bcc $e737			bcc 	_TokPunctuation
.e71d	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e71f	b0 16		bcs $e737			bcs 	_TokPunctuation
.e721					_TokWord:
.e721	20 6c e7	jsr $e76c			jsr 	TokeniseSearch 				; search for tokenised word.
.e724	b0 16		bcs $e73c			bcs 	_TokFound 					; if successful, copy it out.
.e726					_TokSkip:
.e726	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e728	c9 41		cmp #$41			cmp 	#"A"
.e72a	90 d9		bcc $e705			bcc 	_TokLoop
.e72c	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e72e	b0 d5		bcs $e705			bcs 	_TokLoop
.e730	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e733	e8		inx				inx
.e734	c8		iny				iny
.e735	80 ef		bra $e726			bra 	_TokSkip
.e737					_TokPunctuation:
.e737	20 6c e7	jsr $e76c			jsr 	TokeniseSearch 				; find it.
.e73a	90 06		bcc $e742			bcc 	_TokCopy1 					; if found, just copy 1 character
.e73c					_TokFound:
.e73c	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e73f	e8		inx				inx 								; advance target ; source is already advanced.
.e740	80 c3		bra $e705			bra 	_TokLoop 					; do the next character.
.e742					_TokCopy1:
.e742	b1 24		lda ($24),y			lda 	(zTemp1),y
.e744	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e747	e8		inx				inx
.e748	c8		iny				iny
.e749	80 ba		bra $e705			bra 	_TokLoop
.e74b					_TokCopyString:
.e74b	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e74d	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e750	e8		inx				inx 								; skip buffer and first quote.
.e751	c8		iny				iny
.e752					_TokCSLoop:
.e752	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get next character
.e754	f0 10		beq $e766			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e756	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e759	e8		inx				inx 								; advance both.
.e75a	c8		iny				iny
.e75b	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e75d	d0 f3		bne $e752			bne 	_TokCSLoop
.e75f	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e761	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e764	80 9f		bra $e705			bra 	_TokLoop
.e766					_TokExit:
.e766	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e768	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e76b	60		rts				rts
.e76c					TokeniseSearch:
.e76c	48		pha				pha 								; save AXY
.e76d	da		phx				phx
.e76e	5a		phy				phy
.e76f	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e771	85 26		sta $26				sta 	zTemp2
.e773	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e775	bd 7e e0	lda $e07e,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e778	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e77a	d1 24		cmp ($24),y			cmp 	(zTemp1),y 					; do the characters match.
.e77c	f0 13		beq $e791			beq 	_TSTryFullMatch 			; if so, try the full match.
.e77e					_TSGotoNext:
.e77e	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; read it
.e781	e8		inx				inx 								; bump index
.e782	0a		asl a				asl 	a 							; shift into C
.e783	90 f9		bcc $e77e			bcc 	_TSGotoNext 				; keep going until read the end character
.e785	e6 26		inc $26				inc 	zTemp2 						; bump the current token pointer.
.e787	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; look at the first character of the next token
.e78a	d0 e9		bne $e775			bne 	_TSNext 					; if non-zero, go to the next.
.e78c					_TSFail:
.e78c	7a		ply				ply 								; fail.
.e78d	fa		plx				plx
.e78e	68		pla				pla
.e78f	18		clc				clc 				 				; return with carry clear.
.e790	60		rts				rts
.e791					_TSTryFullMatch:
.e791	da		phx				phx									; save X and Y.
.e792	5a		phy				phy
.e793					_TSFullMatch:
.e793	bd 7e e0	lda $e07e,x			lda 	TokenText,x 				; compare the 7 bits.
.e796	29 7f		and #$7f			and 	#$7F
.e798	d1 24		cmp ($24),y			cmp 	(zTemp1),y
.e79a	d0 15		bne $e7b1			bne 	_TSFullFail 				; different, this one doesn't match.
.e79c	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.e79f	e8		inx				inx 								; advance to next character
.e7a0	c8		iny				iny
.e7a1	0a		asl a				asl 	a 							; bit 7 of token text in C
.e7a2	90 ef		bcc $e793			bcc 	_TSFullMatch
.e7a4	84 27		sty $27				sty 	zTemp2+1 					; save the Y after last
.e7a6	68		pla				pla 								; so we don't restore Y
.e7a7	68		pla				pla 								; or X from the full test.
.e7a8	7a		ply				ply 								; restore original Y and X and A
.e7a9	fa		plx				plx
.e7aa	68		pla				pla
.e7ab	a5 26		lda $26				lda 	zTemp2 						; and return token ID in A
.e7ad	a4 27		ldy $27				ldy 	zTemp2+1 					; Y after the tokenised text.
.e7af	38		sec				sec 								; with carry set.
.e7b0	60		rts				rts
.e7b1					_TSFullFail:
.e7b1	7a		ply				ply 								; restore Y and X
.e7b2	fa		plx				plx
.e7b3	80 c9		bra $e77e			bra 	_TSGotoNext 				; and go to the next token to test.
.e7b5					TokeniseTest:
.e7b5	a9 c1		lda #$c1			lda 	#TTString & $FF
.e7b7	85 24		sta $24				sta 	zTemp1
.e7b9	a9 e7		lda #$e7			lda 	#TTString >> 8
.e7bb	85 25		sta $25				sta 	zTemp1+1
.e7bd	20 01 e7	jsr $e701			jsr 	TokeniseString
.e7c0	ea		nop				nop
.e7c1					TTString:
>e7c1	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e7c9	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: general/editor.asm

.e7d6					EditProgram:
.e7d6	a2 00		ldx #$00			ldx 	#0
.e7d8	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; get the line number
.e7db	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; upper bytes must be zero
.e7de	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e7e1	d0 37		bne $e81a			bne 	_EPBadLine
.e7e3	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; lower bytes must be non-zero
.e7e6	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e7e9	f0 2f		beq $e81a			beq 	_EPBadLine
.e7eb	5a		phy				phy 								; save position
.e7ec	20 26 e8	jsr $e826			jsr 	EDFindLine 					; locate the line.
.e7ef	90 12		bcc $e803			bcc 	_EPNotFound 				; skip delete if not found.
.e7f1	a5 24		lda $24				lda 	zTemp1 						; save the target address, as we will
.e7f3	48		pha				pha 								; insert the line, if done, at the same
.e7f4	a5 25		lda $25				lda 	zTemp1+1 					; place
.e7f6	48		pha				pha
.e7f7	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; clear all vars, make sure zLowMemory is right.
.e7fa	20 5d e8	jsr $e85d			jsr 	EDDeleteLine 				; delete the line at zTemp1
.e7fd	68		pla				pla 								; restore the target address.
.e7fe	85 25		sta $25				sta 	zTemp1+1
.e800	68		pla				pla
.e801	85 24		sta $24				sta 	zTemp1
.e803					_EPNotFound
.e803	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e806	7a		ply				ply 								; get pointer back
.e807					_EPSkipSpaces:
.e807	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get character
.e809	f0 0c		beq $e817			beq 	_EPGoWarmStart 				; EOL, just delete, so warm start.
.e80b	c8		iny				iny
.e80c	c9 20		cmp #$20			cmp 	#32
.e80e	f0 f7		beq $e807			beq 	_EPSkipSpaces
.e810	88		dey				dey
.e811	20 7d e8	jsr $e87d			jsr 	EDInsertLine 				; insert the line.
.e814	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e817					_EPGoWarmStart:
.e817	4c 14 f3	jmp $f314			jmp 	WarmStart
.e81a					_EPBadLine:
.e81a	20 72 e1	jsr $e172			jsr 	ReportError
>e81d	42 41 44 20 4c 49 4e 45				.text 	"BAD LINE",$00
>e825	00
.e826					EDFindLine:
.e826	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set zTemp1
.e828	85 24		sta $24				sta 	zTemp1
.e82a	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e82c	85 25		sta $25				sta 	zTemp1+1
.e82e					_EDFLLoop:
.e82e	a0 00		ldy #$00			ldy 	#0 							; reached the end
.e830	b1 24		lda ($24),y			lda 	(zTemp1),y
.e832	f0 25		beq $e859			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.e834	c8		iny				iny
.e835	38		sec				sec
.e836	ad 00 04	lda $0400			lda 	evalStack+0					; subtract the current from the target
.e839	f1 24		sbc ($24),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.e83b	aa		tax				tax	 								; this will return 10.
.e83c	ad 01 04	lda $0401			lda 	evalStack+1
.e83f	c8		iny				iny
.e840	f1 24		sbc ($24),y			sbc 	(zTemp1),y
.e842	90 15		bcc $e859			bcc 	_EDFLFail					; if target < current then failed.
.e844	d0 04		bne $e84a			bne 	_EDFLNext 					; if non-zero then goto next
.e846	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.e848	f0 11		beq $e85b			beq 	_EDFLFound
.e84a					_EDFLNext:
.e84a	a0 00		ldy #$00			ldy 	#0 							; get offset
.e84c	18		clc				clc
.e84d	b1 24		lda ($24),y			lda 	(zTemp1),y
.e84f	65 24		adc $24				adc 	zTemp1 						; add to pointer
.e851	85 24		sta $24				sta 	zTemp1
.e853	90 d9		bcc $e82e			bcc 	_EDFLLoop
.e855	e6 25		inc $25				inc 	zTemp1+1 					; carry out.
.e857	80 d5		bra $e82e			bra 	_EDFLLoop
.e859					_EDFLFail:
.e859	18		clc				clc
.e85a	60		rts				rts
.e85b					_EDFLFound:
.e85b	38		sec				sec
.e85c	60		rts				rts
.e85d					EDDeleteLine:
.e85d	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.e85f	a2 00		ldx #$00			ldx 	#0
.e861	b1 24		lda ($24),y			lda 	(zTemp1),y
.e863	a8		tay				tay 								; put in Y
.e864					_EDDelLoop:
.e864	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get it
.e866	81 24		sta ($24,x)			sta 	(zTemp1,x) 					; write it.
.e868	a5 24		lda $24				lda 	zTemp1 						; check if pointer has reached the end of
.e86a	c5 22		cmp $22				cmp		zLowMemory 					; low memory. We will have copied down an
.e86c	d0 06		bne $e874			bne 	_EDDelNext 					; extra pile of stuff - technically should
.e86e	a5 25		lda $25				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.e870	c5 23		cmp $23				cmp 	zLowMemory+1				; doesn't really matter.
.e872	f0 08		beq $e87c			beq		_EDDelExit
.e874					_EDDelNext:
.e874	e6 24		inc $24				inc 	zTemp1 						; go to next byte.
.e876	d0 ec		bne $e864			bne 	_EDDelLoop
.e878	e6 25		inc $25				inc 	zTemp1+1
.e87a	80 e8		bra $e864			bra 	_EDDelLoop
.e87c					_EDDelExit:
.e87c	60		rts				rts
.e87d					EDInsertLine:
.e87d	98		tya				tya 								; make zCurrentLine point to the actual new line.
.e87e	18		clc				clc
.e87f	65 20		adc $20				adc 	zCurrentLine
.e881	85 20		sta $20				sta 	zCurrentLine
.e883	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.e885					_EDGetLength:
.e885	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e887	c8		iny				iny
.e888	c9 00		cmp #$00			cmp 	#0
.e88a	d0 f9		bne $e885			bne 	_EDGetLength
.e88c	88		dey				dey 								; fix up.
.e88d	98		tya				tya
.e88e	18		clc				clc
.e88f	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.e891	48		pha				pha 								; save total size (e.g. offset)
.e892	a8		tay				tay 								; in Y
.e893	a2 00		ldx #$00			ldx 	#0
.e895					_EDInsLoop:
.e895	a1 22		lda ($22,x)			lda 	(zLowMemory,x)				; copy it up
.e897	91 22		sta ($22),y			sta 	(zLowMemory),y
.e899	a5 22		lda $22				lda 	zLowMemory 					; reached the insert point (zTemp1)
.e89b	c5 24		cmp $24				cmp 	zTemp1
.e89d	d0 06		bne $e8a5			bne 	_EDINextShift
.e89f	a5 23		lda $23				lda 	zLowMemory+1
.e8a1	c5 25		cmp $25				cmp 	zTemp1+1
.e8a3	f0 0a		beq $e8af			beq 	_EDIShiftOver
.e8a5					_EDINextShift:
.e8a5	a5 22		lda $22				lda 	zLowMemory 					; decrement the copy pointer.
.e8a7	d0 02		bne $e8ab			bne 	_EDINoBorrow
.e8a9	c6 23		dec $23				dec 	zLowMemory+1
.e8ab					_EDINoBorrow:
.e8ab	c6 22		dec $22				dec 	zLowMemory
.e8ad	80 e6		bra $e895			bra 	_EDInsLoop
.e8af					_EDIShiftOver:
.e8af	68		pla				pla 								; this is the size + others, e.g. offset
.e8b0	a0 00		ldy #$00			ldy 	#0
.e8b2	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write that out.
.e8b4	ad 00 04	lda $0400			lda 	evalStack+0 				; write LIne# out
.e8b7	c8		iny				iny
.e8b8	91 22		sta ($22),y			sta 	(zLowMemory),y
.e8ba	ad 01 04	lda $0401			lda 	evalStack+1
.e8bd	c8		iny				iny
.e8be	91 22		sta ($22),y			sta 	(zLowMemory),y
.e8c0	c8		iny				iny 								; where the code goes.
.e8c1	a2 00		ldx #$00			ldx 	#0 							; comes from
.e8c3					_EDICopyCode:
.e8c3	a1 20		lda ($20,x)			lda 	(zCurrentLine,x)			; read from the current line
.e8c5	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write out
.e8c7	c8		iny				iny 								; bump pointers
.e8c8	e6 20		inc $20				inc 	zCurrentLine
.e8ca	c9 00		cmp #$00			cmp 	#0 							; until zero copied
.e8cc	d0 f5		bne $e8c3			bne 	_EDICopyCode
.e8ce	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e8cf					BFUNC_Add:
.e8cf	18		clc				clc
.e8d0	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8d3	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e8d6	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8d9	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8dc	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e8df	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8e2	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8e5	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e8e8	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8eb	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8ee	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e8f1	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8f4	60		rts				rts
.e8f5					BFUNC_Subtract:
.e8f5	38		sec				sec
.e8f6	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8f9	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e8fc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8ff	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e902	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e905	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e908	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e90b	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e90e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e911	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e914	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e917	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e91a	60		rts				rts
.e91b					BFUNC_String:
.e91b	20 cf e8	jsr $e8cf			jsr 	BFUNC_Add
.e91e	60		rts				rts
.e91f					BFUNC_ByteInd:
.e91f	20 cf e8	jsr $e8cf			jsr 	BFUNC_Add
.e922	20 fd e3	jsr $e3fd			jsr 	EVALReadByteIndirect
.e925	60		rts				rts
.e926					BFUNC_WordInd:
.e926	20 cf e8	jsr $e8cf			jsr 	BFUNC_Add
.e929	20 33 e4	jsr $e433			jsr 	EVALReadWordIndirect
.e92c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e92d					BFUNC_And:
.e92d	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e930	3d 04 04	and $0404,x			and 	evalStack+4,x
.e933	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e936	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e939	3d 05 04	and $0405,x			and 	evalStack+5,x
.e93c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e93f	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e942	3d 06 04	and $0406,x			and 	evalStack+6,x
.e945	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e948	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e94b	3d 07 04	and $0407,x			and 	evalStack+7,x
.e94e	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e951	60		rts				rts
.e952					BFUNC_Or:
.e952	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e955	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e958	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e95b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e95e	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e961	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e964	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e967	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e96a	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e96d	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e970	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e973	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e976	60		rts				rts
.e977					BFUNC_Xor:
.e977	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e97a	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e97d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e980	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e983	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e986	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e989	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e98c	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e98f	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e992	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e995	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e998	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e99b	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e99c					BFUNC_Equals:
.e99c	18		clc				clc
.e99d	80 01		bra $e9a0			bra 	BFUNC_EqualCheck
.e99f					BFUNC_NotEquals:
.e99f	38		sec				sec
.e9a0					BFUNC_EqualCheck:
.e9a0	08		php				php									; save invert flag
.e9a1	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e9a4	cd 04 04	cmp $0404			cmp 	evalStack+4
.e9a7	d0 1c		bne $e9c5			bne 	COMP_Fail
.e9a9	ad 01 04	lda $0401			lda 	evalStack+1
.e9ac	cd 05 04	cmp $0405			cmp 	evalStack+5
.e9af	d0 14		bne $e9c5			bne 	COMP_Fail
.e9b1	ad 02 04	lda $0402			lda 	evalStack+2
.e9b4	cd 06 04	cmp $0406			cmp 	evalStack+6
.e9b7	d0 0c		bne $e9c5			bne 	COMP_Fail
.e9b9	ad 03 04	lda $0403			lda 	evalStack+3
.e9bc	cd 07 04	cmp $0407			cmp 	evalStack+7
.e9bf	d0 04		bne $e9c5			bne 	COMP_Fail
.e9c1					COMP_Succeed:
.e9c1	a9 ff		lda #$ff			lda 	#$FF
.e9c3	80 02		bra $e9c7			bra 	COMP_SetResult
.e9c5					COMP_Fail:
.e9c5	a9 00		lda #$00			lda 	#0 							; here return 0
.e9c7					COMP_SetResult:
.e9c7	28		plp				plp 								; but if CS
.e9c8	90 02		bcc $e9cc			bcc 	COMP_Accept
.e9ca	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e9cc					COMP_Accept:
.e9cc	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e9cf	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e9d2	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e9d5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e9d8	60		rts				rts
.e9d9					BFUNC_Less:
.e9d9	18		clc				clc
.e9da	80 01		bra $e9dd			bra 	BFUNC_LessCheck
.e9dc					BFUNC_GreaterEqual:
.e9dc	38		sec				sec
.e9dd					BFUNC_LessCheck:
.e9dd	08		php				php
.e9de	38		sec				sec
.e9df	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e9e2	ed 04 04	sbc $0404			sbc 	evalStack+4
.e9e5	ad 01 04	lda $0401			lda 	evalStack+1
.e9e8	ed 05 04	sbc $0405			sbc 	evalStack+5
.e9eb	ad 02 04	lda $0402			lda 	evalStack+2
.e9ee	ed 06 04	sbc $0406			sbc 	evalStack+6
.e9f1	ad 03 04	lda $0403			lda 	evalStack+3
.e9f4	ed 07 04	sbc $0407			sbc 	evalStack+7
.e9f7	30 c8		bmi $e9c1			bmi 	COMP_Succeed
.e9f9	80 ca		bra $e9c5			bra 	COMP_Fail
.e9fb					BFUNC_Greater:
.e9fb	18		clc				clc
.e9fc	80 01		bra $e9ff			bra 	BFUNC_GreaterCheck
.e9fe					BFUNC_LessEqual:
.e9fe	38		sec				sec
.e9ff					BFUNC_GreaterCheck:
.e9ff	08		php				php
.ea00	38		sec				sec
.ea01	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.ea04	ed 00 04	sbc $0400			sbc 	evalStack+0
.ea07	ad 05 04	lda $0405			lda 	evalStack+5
.ea0a	ed 01 04	sbc $0401			sbc 	evalStack+1
.ea0d	ad 06 04	lda $0406			lda 	evalStack+6
.ea10	ed 02 04	sbc $0402			sbc 	evalStack+2
.ea13	ad 07 04	lda $0407			lda 	evalStack+7
.ea16	ed 03 04	sbc $0403			sbc 	evalStack+3
.ea19	30 a6		bmi $e9c1			bmi 	COMP_Succeed
.ea1b	80 a8		bra $e9c5			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.ea1d					BFUNC_Divide:
.ea1d	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.ea20	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.ea23	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.ea26	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.ea29	d0 14		bne $ea3f			bne 	_BFDOkay
.ea2b	20 72 e1	jsr $e172			jsr 	ReportError
>ea2e	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>ea36	20 42 59 20 5a 45 52 4f 00
.ea3f					_BFDOkay:
.ea3f	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.ea41	8d c0 20	sta $20c0			sta 	Temp1 						; Q/Dividend/Left in +0
.ea44	8d c1 20	sta $20c1			sta 	Temp1+1 					; M/Divisor/Right in +4
.ea47	8d c2 20	sta $20c2			sta 	Temp1+2
.ea4a	8d c3 20	sta $20c3			sta 	Temp1+3
.ea4d	8d c4 20	sta $20c4			sta 	SignCount 					; Count of signs.
.ea50	20 bb ea	jsr $eabb			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.ea53	da		phx				phx
.ea54	e8		inx				inx
.ea55	e8		inx				inx
.ea56	e8		inx				inx
.ea57	e8		inx				inx
.ea58	20 bb ea	jsr $eabb			jsr 	BFUNC_Negate
.ea5b	fa		plx				plx
.ea5c	5a		phy				phy 								; Y is the counter
.ea5d	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.ea5f					_BFDLoop:
.ea5f	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.ea62	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.ea65	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.ea68	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.ea6b	2e c0 20	rol $20c0			rol 	Temp1
.ea6e	2e c1 20	rol $20c1			rol 	Temp1+1
.ea71	2e c2 20	rol $20c2			rol 	Temp1+2
.ea74	2e c3 20	rol $20c3			rol 	Temp1+3
.ea77	38		sec				sec
.ea78	ad c0 20	lda $20c0			lda 	Temp1+0 					; Calculate A-M on stack.
.ea7b	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.ea7e	48		pha				pha
.ea7f	ad c1 20	lda $20c1			lda 	Temp1+1
.ea82	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.ea85	48		pha				pha
.ea86	ad c2 20	lda $20c2			lda 	Temp1+2
.ea89	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.ea8c	48		pha				pha
.ea8d	ad c3 20	lda $20c3			lda 	Temp1+3
.ea90	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.ea93	90 19		bcc $eaae			bcc 	_BFDNoAdd
.ea95	8d c3 20	sta $20c3			sta 	Temp1+3 					; update A
.ea98	68		pla				pla
.ea99	8d c2 20	sta $20c2			sta 	Temp1+2
.ea9c	68		pla				pla
.ea9d	8d c1 20	sta $20c1			sta 	Temp1+1
.eaa0	68		pla				pla
.eaa1	8d c0 20	sta $20c0			sta 	Temp1+0
.eaa4	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.eaa7	09 01		ora #$01			ora 	#1
.eaa9	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eaac	80 03		bra $eab1			bra 	_BFDNext
.eaae					_BFDNoAdd:
.eaae	68		pla				pla 								; Throw away the intermediate calculations
.eaaf	68		pla				pla
.eab0	68		pla				pla
.eab1					_BFDNext:
.eab1	88		dey				dey
.eab2	d0 ab		bne $ea5f			bne 	_BFDLoop
.eab4	7a		ply				ply 								; restore Y and exit
.eab5	4e c4 20	lsr $20c4			lsr 	SignCount 					; if sign count odd,
.eab8	b0 06		bcs $eac0			bcs		BFUNC_NegateAlways 			; negate the result
.eaba	60		rts				rts
.eabb					BFUNC_Negate:
.eabb	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eabe	10 24		bpl $eae4			bpl 	BFNExit
.eac0					BFUNC_NegateAlways:
.eac0	38		sec				sec
.eac1	a9 00		lda #$00			lda 	#0
.eac3	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.eac6	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eac9	a9 00		lda #$00			lda 	#0
.eacb	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.eace	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ead1	a9 00		lda #$00			lda 	#0
.ead3	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.ead6	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ead9	a9 00		lda #$00			lda 	#0
.eadb	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.eade	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eae1	ee c4 20	inc $20c4			inc 	SignCount
.eae4					BFNExit:
.eae4	60		rts				rts
.eae5					BFUNC_Modulus:
.eae5	20 1d ea	jsr $ea1d			jsr 	BFUNC_Divide 				; start with division.
.eae8	ad c0 20	lda $20c0			lda 	Temp1+0 					; copy remainder
.eaeb	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eaee	ad c1 20	lda $20c1			lda 	Temp1+1
.eaf1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eaf4	ad c2 20	lda $20c2			lda 	Temp1+2
.eaf7	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eafa	ad c3 20	lda $20c3			lda 	Temp1+3
.eafd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb00	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.eb01					BFUNC_Multiply:
.eb01	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.eb04	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.eb07	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb0a	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.eb0d	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eb10	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.eb13	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eb16	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.eb19	a9 00		lda #$00			lda 	#0
.eb1b	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.eb1e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb21	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb24	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb27					_BFMMultiply:
.eb27	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.eb2a	29 01		and #$01			and 	#1
.eb2c	f0 03		beq $eb31			beq 	_BFMNoAdd
.eb2e	20 cf e8	jsr $e8cf			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.eb31					_BFMNoAdd:
.eb31	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.eb34	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.eb37	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.eb3a	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.eb3d	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.eb40	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.eb43	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.eb46	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.eb49	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.eb4c	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.eb4f	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.eb52	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.eb55	d0 d0		bne $eb27			bne 	_BFMMultiply
.eb57	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.eb58					BFUNC_StringCompare:
.eb58	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.eb5b	85 24		sta $24				sta 	zTemp1
.eb5d	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb60	85 25		sta $25				sta 	zTemp1+1
.eb62	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.eb65	85 26		sta $26				sta 	zTemp2
.eb67	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.eb6a	85 27		sta $27				sta 	zTemp2+1
.eb6c	5a		phy				phy
.eb6d	a0 00		ldy #$00			ldy 	#0
.eb6f					_BFSCLoop:
.eb6f	b1 24		lda ($24),y			lda 	(zTemp1),y 					; comparison
.eb71	38		sec				sec
.eb72	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.eb74	d0 15		bne $eb8b			bne		_BFSCDifferent 				; return different result.
.eb76	c8		iny				iny
.eb77	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.eb79	d0 f4		bne $eb6f			bne 	_BFSCLoop
.eb7b	7a		ply				ply
.eb7c	a9 00		lda #$00			lda 	#0
.eb7e					_BFSCSetAll:
.eb7e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb81	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb84	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb87	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb8a	60		rts				rts
.eb8b					_BFSCDifferent:
.eb8b	7a		ply				ply
.eb8c	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.eb8e	90 ee		bcc $eb7e			bcc 	_BFSCSetAll
.eb90	a9 00		lda #$00			lda 	#0 							; set all zero
.eb92	20 7e eb	jsr $eb7e			jsr 	_BFSCSetAll
.eb95	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.eb98	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.eb99					UNARY_Len:
.eb99	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb9c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb9f	85 24		sta $24				sta 	zTemp1
.eba1	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eba4	85 25		sta $25				sta 	zTemp1+1
.eba6	5a		phy				phy
.eba7	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.eba9					_ULGetLength:
.eba9	b1 24		lda ($24),y			lda 	(zTemp1),y 					; read character
.ebab	f0 1d		beq $ebca			beq 	_ULFoundEOL 				; found end of line.
.ebad	c8		iny				iny
.ebae	d0 f9		bne $eba9			bne 	_ULGetLength 				; scan 256 only.
.ebb0	20 72 e1	jsr $e172			jsr 	ReportError
>ebb3	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>ebbb	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.ebca					_ULFoundEOL:
.ebca	98		tya				tya 								; length in A, restore Y
.ebcb	7a		ply				ply
.ebcc					UNARY_ReturnByte:
.ebcc	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebcf	a9 00		lda #$00			lda 	#0 							; clear the rests
.ebd1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebd4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ebd7	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebda	60		rts				rts
.ebdb					UNARY_Ch:
.ebdb	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.ebde	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.ebe1	85 24		sta $24				sta 	zTemp1
.ebe3	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ebe6	85 25		sta $25				sta 	zTemp1+1
.ebe8	5a		phy				phy
.ebe9	a0 00		ldy #$00			ldy 	#0 							; now get first character
.ebeb	b1 24		lda ($24),y			lda 	(zTemp1),y
.ebed	7a		ply				ply
.ebee	80 dc		bra $ebcc			bra 	UNARY_ReturnByte 			; return that byte.
.ebf0					UNARY_Abs:
.ebf0	ea		nop				nop
.ebf1	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.ebf4	20 bb ea	jsr $eabb			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.ebf7	60		rts				rts
.ebf8					UNARY_Top:
.ebf8	ad be 20	lda $20be			lda 	highMemory
.ebfb	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebfe	ad bf 20	lda $20bf			lda 	highMemory+1
.ec01	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec04	a9 00		lda #$00			lda 	#0
.ec06	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec09	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec0c	60		rts				rts
.ec0d					UNARY_Get:
.ec0d	20 0c b0	jsr $b00c			jsr 	EXTReadKeyPort
.ec10	f0 fb		beq $ec0d			beq 	UNARY_Get
.ec12	20 35 b0	jsr $b035			jsr 	EXTRemoveKeyPressed
.ec15	80 b5		bra $ebcc			bra 	UNARY_ReturnByte
.ec17					UNARY_Page:
.ec17	a9 00		lda #$00			lda 	#BasicProgram & $FF
.ec19	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec1c	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ec1e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec21	a9 00		lda #$00			lda 	#0
.ec23	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec26	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec29	60		rts				rts
.ec2a					UNARY_Rnd:
.ec2a	20 35 ec	jsr $ec35			jsr 	Random16 					; call 16 bit RNG twice
.ec2d	e8		inx				inx
.ec2e	e8		inx				inx
.ec2f	20 35 ec	jsr $ec35			jsr 	Random16
.ec32	ca		dex				dex
.ec33	ca		dex				dex
.ec34	60		rts				rts
.ec35					Random16:
.ec35	ad c6 20	lda $20c6			lda 	RandomSeed 					; initialise if nonzero
.ec38	0d c7 20	ora $20c7			ora 	RandomSeed+1
.ec3b	d0 0d		bne $ec4a			bne 	_R16_NoInit
.ec3d	ee c6 20	inc $20c6			inc 	RandomSeed 					; by setting low to 1
.ec40	5a		phy				phy
.ec41	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.ec43					_R16_Setup:
.ec43	20 35 ec	jsr $ec35			jsr 	Random16
.ec46	88		dey				dey
.ec47	d0 fa		bne $ec43			bne 	_R16_Setup
.ec49	7a		ply				ply
.ec4a					_R16_NoInit:
.ec4a	4e c7 20	lsr $20c7			lsr 	RandomSeed+1				; shift seed right
.ec4d	6e c6 20	ror $20c6			ror 	RandomSeed
.ec50	90 08		bcc $ec5a			bcc 	_R16_NoXor
.ec52	ad c7 20	lda $20c7			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.ec55	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ec57	8d c7 20	sta $20c7			sta 	RandomSeed+1
.ec5a					_R16_NoXor:
.ec5a	ad c6 20	lda $20c6			lda 	RandomSeed					; copy result to evaluate stack.
.ec5d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec60	ad c7 20	lda $20c7			lda 	RandomSeed+1
.ec63	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec66	60		rts				rts
.ec67					UNARY_IOAddr:
.ec67	a9 0f		lda #$0f			lda 	#$0F
.ec69	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec6c	a9 fd		lda #$fd			lda 	#$FD
.ec6e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec71	a9 30		lda #$30			lda 	#$30
.ec73	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec76	a9 00		lda #$00			lda 	#$00
.ec78	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec7b	60		rts				rts
.ec7c					UNARY_CPU:
.ec7c	a9 00		lda #$00			lda 	#$00
.ec7e	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ec81	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ec84	a9 20		lda #$20			lda 	#registers >> 8
.ec86	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ec89	a9 cc		lda #$cc			lda 	#registers & $FF
.ec8b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ec8e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/dim.asm

.ec8f					COMMAND_Dim:
.ec8f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; skip over , and space
.ec91	f0 0f		beq $eca2			beq 	_CDIMExit
.ec93	c9 8e		cmp #$8e			cmp		#KW_COLON
.ec95	f0 0b		beq $eca2			beq 	_CDIMExit
.ec97	c8		iny				iny
.ec98	c9 8b		cmp #$8b			cmp 	#KW_COMMA
.ec9a	f0 f3		beq $ec8f			beq 	COMMAND_Dim
.ec9c	c9 20		cmp #$20			cmp 	#" "
.ec9e	f0 ef		beq $ec8f			beq 	COMMAND_Dim
.eca0	80 04		bra $eca6			bra 	_CDIMDoDim
.eca2					_CDIMExit:
.eca2	60		rts				rts
.eca3					_CDIMSyntax:
.eca3	4c 62 e1	jmp $e162			jmp 	SyntaxError
.eca6					_CDIMDoDim:
.eca6	c9 40		cmp #$40			cmp 	#"@"						; check it is @A-Z
.eca8	90 f9		bcc $eca3			bcc 	_CDIMSyntax
.ecaa	c9 5b		cmp #$5b			cmp 	#"Z"+1
.ecac	b0 f5		bcs $eca3			bcs 	_CDIMSyntax
.ecae	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it followed by a duplicate
.ecb0	d0 03		bne $ecb5			bne 	_CDIMNoDouble
.ecb2	c8		iny				iny 								; yes, so skip it to the size.
.ecb3	09 80		ora #$80			ora 	#$80 						; and set bit 7 to indicate AA(x) e.g. 4 bytes.
.ecb5					_CDIMNoDouble:
.ecb5	48		pha				pha 								; save array 'name'
.ecb6	a2 00		ldx #$00			ldx 	#0 							; count it bottom stack level.
.ecb8	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel
.ecbb	ee 00 04	inc $0400			inc 	evalStack+0 				; add extra element
.ecbe	d0 03		bne $ecc3			bne 	_CDIMAlloc
.ecc0	ee 01 04	inc $0401			inc 	evalStack+1
.ecc3					_CDIMAlloc:
.ecc3	68		pla				pla 								; get bit 7
.ecc4	48		pha				pha
.ecc5	10 0c		bpl $ecd3			bpl 	_CDIMNotWord 				; if not set, then A(x) not AA(x) so use byte size.
.ecc7	0e 00 04	asl $0400			asl 	evalStack+0 				; shift left x 2
.ecca	2e 01 04	rol $0401			rol 	evalStack+1
.eccd	0e 00 04	asl $0400			asl 	evalStack+0 				; won't bother about the upper 16 bits.
.ecd0	2e 01 04	rol $0401			rol 	evalStack+1
.ecd3					_CDIMNotWord:
.ecd3	68		pla				pla 								; variable back
.ecd4	29 1f		and #$1f			and 	#$1F 						; lower 5 bits
.ecd6	0a		asl a				asl 	a 							; x 4 now index into variable.
.ecd7	0a		asl a				asl 	a
.ecd8	aa		tax				tax
.ecd9	a5 22		lda $22				lda 	zLowMemory 					; copy low memory into variable
.ecdb	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.ecde	a5 23		lda $23				lda 	zLowMemory+1
.ece0	9d 01 20	sta $2001,x			sta 	FixedVariables+1,x
.ece3	a9 00		lda #$00			lda 	#0 							; zero upper 2 bytes
.ece5	9d 02 20	sta $2002,x			sta 	FixedVariables+2,x
.ece8	9d 03 20	sta $2003,x			sta 	FixedVariables+3,x
.eceb	18		clc				clc
.ecec	a5 22		lda $22				lda 	zLowMemory
.ecee	6d 00 04	adc $0400			adc 	evalStack+0
.ecf1	85 22		sta $22				sta 	zLowMemory
.ecf3	a5 23		lda $23				lda 	zLowMemory+1
.ecf5	6d 01 04	adc $0401			adc 	evalStack+1
.ecf8	85 23		sta $23				sta 	zLowMemory+1
.ecfa	b0 0f		bcs $ed0b			bcs 	_CDIMMemory					; out of memory ?
.ecfc	ad be 20	lda $20be			lda 	HighMemory
.ecff	38		sec				sec
.ed00	e5 22		sbc $22				sbc 	zLowMemory
.ed02	ad bf 20	lda $20bf			lda 	HighMemory+1
.ed05	e5 23		sbc $23				sbc 	zLowMemory+1
.ed07	90 02		bcc $ed0b			bcc 	_CDIMMemory
.ed09	80 84		bra $ec8f			bra 	Command_DIM 				; go back try another.
.ed0b					_CDIMMemory:
.ed0b	20 72 e1	jsr $e172			jsr 	ReportError
>ed0e	4f 55 54 20 4f 46 20 4d				.text 	"OUT OF MEMORY",$00
>ed16	45 4d 4f 52 59 00

;******  Return to file: basic.asm


;******  Processing file: commands/dountil.asm

.ed1c					COMMAND_Do:
.ed1c	a9 9f		lda #$9f			lda 	#KW_DO						; push position with a DO token.
.ed1e	20 3c ed	jsr $ed3c			jsr 	CDOPushPosOnStack
.ed21	60		rts				rts
.ed22					COMMAND_Until:
.ed22	a9 9f		lda #$9f			lda 	#KW_DO 						; check TOS is a Do.
.ed24	20 7a ed	jsr $ed7a			jsr 	CDOCheckTopStack
.ed27	a2 00		ldx #$00			ldx 	#0 							; evaluate the test
.ed29	20 43 e2	jsr $e243			jsr 	EvaluateBase
.ed2c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check if zero
.ed2f	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ed32	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ed35	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ed38	f0 2a		beq $ed64			beq 	CDOPullPosOffStack 			; zero, restore the position.
.ed3a	80 1e		bra $ed5a			bra 	CDOThrowPosOffStack			; non-zero chuck it.
.ed3c					CDOPushPosOnStack:
.ed3c	ae cb 20	ldx $20cb			ldx 	basicStackIndex
.ed3f	48		pha				pha
.ed40	98		tya				tya
.ed41	9d 01 02	sta $0201,x			sta 	BasicStack+1,x 				; +1 	Y Position
.ed44	a5 20		lda $20				lda 	zCurrentLine
.ed46	9d 02 02	sta $0202,x			sta 	BasicStack+2,x 				; +2 	low of pos
.ed49	a5 21		lda $21				lda 	zCurrentLine+1
.ed4b	9d 03 02	sta $0203,x			sta 	BasicStack+3,x 				; +3 	high of pos
.ed4e	68		pla				pla
.ed4f	9d 04 02	sta $0204,x			sta 	BasicStack+4,x 				; +4 	token on stack
.ed52	e8		inx				inx
.ed53	e8		inx				inx
.ed54	e8		inx				inx
.ed55	e8		inx				inx 								; always points to TOS.
.ed56	8e cb 20	stx $20cb			stx 	basicStackIndex
.ed59	60		rts				rts
.ed5a					CDOThrowPosOffStack:
.ed5a	ad cb 20	lda $20cb			lda 	basicStackIndex
.ed5d	38		sec				sec
.ed5e	e9 04		sbc #$04			sbc 	#4
.ed60	8d cb 20	sta $20cb			sta 	basicStackIndex
.ed63	60		rts				rts
.ed64					CDOPullPosOffStack:
.ed64	ae cb 20	ldx $20cb			ldx 	basicStackIndex
.ed67	ca		dex				dex
.ed68	ca		dex				dex
.ed69	ca		dex				dex
.ed6a	ca		dex				dex
.ed6b	bd 01 02	lda $0201,x			lda 	BasicStack+1,x 					; get position back.
.ed6e	a8		tay				tay
.ed6f	bd 02 02	lda $0202,x			lda 	BasicStack+2,x
.ed72	85 20		sta $20				sta 	zCurrentLine
.ed74	bd 03 02	lda $0203,x			lda 	BasicStack+3,x
.ed77	85 21		sta $21				sta 	zCurrentLine+1
.ed79	60		rts				rts
.ed7a					CDOCheckTopStack:
.ed7a	ae cb 20	ldx $20cb			ldx 	basicStackIndex 			; if match
.ed7d	dd 00 02	cmp $0200,x			cmp 	BasicStack+0,x
.ed80	d0 01		bne $ed83			bne 	_CDOCTSError
.ed82	60		rts				rts
.ed83					_CDOCTSError:
.ed83	20 72 e1	jsr $e172			jsr 	ReportError
>ed86	53 54 52 55 43 54 55 52				.text 	"STRUCTURE MIXED",$00
>ed8e	45 20 4d 49 58 45 44 00

;******  Return to file: basic.asm


;******  Processing file: commands/goto.asm

.ed96					COMMAND_Goto:
.ed96	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.ed98	20 43 e2	jsr $e243			jsr 	EvaluateBase
.ed9b					CMDGoto:
.ed9b	20 c0 ed	jsr $edc0			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.ed9e	a5 28		lda $28				lda 	zTargetAddr 				; new line
.eda0	85 20		sta $20				sta 	zCurrentLine
.eda2	a5 29		lda $29				lda 	zTargetAddr+1
.eda4	85 21		sta $21				sta 	zCurrentLine+1
.eda6	a0 03		ldy #$03			ldy 	#3
.eda8	60		rts				rts
.eda9					COMMAND_Gosub:
.eda9	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.edab	20 43 e2	jsr $e243			jsr 	EvaluateBase
.edae	a9 a3		lda #$a3			lda 	#KW_GOSUB
.edb0	20 3c ed	jsr $ed3c			jsr 	CDOPushPosOnStack 			; save return address on stack.
.edb3	80 e6		bra $ed9b			bra 	CMDGoto
.edb5					COMMAND_Return:
.edb5	a9 a3		lda #$a3			lda 	#KW_GOSUB 					; check GOSUB on BASIC Stack.
.edb7	20 7a ed	jsr $ed7a			jsr 	CDOCheckTopStack
.edba	20 64 ed	jsr $ed64			jsr 	CDOPullPosOffStack 			; restore
.edbd	4c 5a ed	jmp $ed5a			jmp 	CDOThrowPosOffStack 		; and drop it.
.edc0					FindProgramLine:
.edc0	ad 02 04	lda $0402			lda 	evalStack+2 				; check in range 0-65535
.edc3	0d 03 04	ora $0403			ora 	evalStack+3
.edc6	d0 2e		bne $edf6			bne		_FPLFail
.edc8	a9 00		lda #$00			lda 	#BasicProgram & 255 		; start of code
.edca	85 28		sta $28				sta 	zTargetAddr
.edcc	a9 23		lda #$23			lda 	#BasicProgram >> 8
.edce	85 29		sta $29				sta 	zTargetAddr+1
.edd0					_FPLLoop:
.edd0	a0 00		ldy #$00			ldy 	#0 							; reached end
.edd2	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.edd4	f0 20		beq $edf6			beq 	_FPLFail
.edd6	c8		iny				iny 								; check line numbers
.edd7	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.edd9	cd 00 04	cmp $0400			cmp 	evalStack+0
.eddc	d0 09		bne $ede7			bne 	_FPLNext
.edde	c8		iny				iny
.eddf	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ede1	cd 01 04	cmp $0401			cmp 	evalStack+1
.ede4	d0 01		bne $ede7			bne 	_FPLNext
.ede6	60		rts				rts
.ede7					_FPLNext:
.ede7	a0 00		ldy #$00			ldy 	#0 							; go to next
.ede9	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.edeb	18		clc				clc
.edec	65 28		adc $28				adc 	zTargetAddr
.edee	85 28		sta $28				sta 	zTargetAddr
.edf0	90 de		bcc $edd0			bcc 	_FPLLoop
.edf2	e6 29		inc $29				inc 	zTargetAddr+1
.edf4	80 da		bra $edd0			bra 	_FPLLoop
.edf6					_FPLFail:
.edf6	20 72 e1	jsr $e172			jsr 	ReportError
>edf9	4c 49 4e 45 20 4e 4f 54				.text 	"LINE NOT FOUND",$00
>ee01	20 46 4f 55 4e 44 00

;******  Return to file: basic.asm


;******  Processing file: commands/if.asm

.ee08					COMMAND_IF:
.ee08	a2 00		ldx #$00			ldx 	#0 							; do test
.ee0a	20 43 e2	jsr $e243			jsr 	EvaluateBase
.ee0d	ad 00 04	lda $0400			lda 	evalStack+0 				; check if test 0
.ee10	0d 01 04	ora $0401			ora 	evalStack+1
.ee13	0d 02 04	ora $0402			ora 	evalStack+2
.ee16	0d 03 04	ora $0403			ora 	evalStack+3
.ee19	f0 01		beq $ee1c			beq 	_CIFSkip 					; if not, then skip to ELSE token or EOL.
.ee1b					_CIFExit:
.ee1b	60		rts				rts
.ee1c					_CIFSkip:
.ee1c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; found EOL ?
.ee1e	f0 fb		beq $ee1b			beq 	_CIFExit
.ee20	c8		iny				iny 								; is it ELSE
.ee21	c9 a0		cmp #$a0			cmp 	#KW_ELSE
.ee23	d0 f7		bne $ee1c			bne 	_CIFSkip 					; no, keep going
.ee25	60		rts				rts
.ee26					COMMAND_THEN:
.ee26	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; find first non space
.ee28	c8		iny				iny
.ee29	c9 20		cmp #$20			cmp 	#" "
.ee2b	f0 f9		beq $ee26			beq 	COMMAND_THEN
.ee2d	88		dey				dey
.ee2e	c9 30		cmp #$30			cmp 	#"0" 						; THEN x is THEN GOTO x
.ee30	90 07		bcc $ee39			bcc 	_CTHNoBranch
.ee32	c9 3a		cmp #$3a			cmp 	#"9"+1
.ee34	b0 03		bcs $ee39			bcs 	_CTHNoBranch
.ee36	4c 96 ed	jmp $ed96			jmp 	Command_GOTO 				; so do the GOTO code.
.ee39					_CTHNoBranch:
.ee39	60		rts				rts
.ee3a					COMMAND_ELSE:
.ee3a	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ee3c	c8		iny				iny
.ee3d	c9 00		cmp #$00			cmp 	#0
.ee3f	d0 f9		bne $ee3a			bne 	COMMAND_ELSE
.ee41	88		dey				dey
.ee42	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ee43					COMMAND_Let:
.ee43	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ee45	f0 58		beq $ee9f			beq 	_CLESyntax
.ee47	c8		iny				iny
.ee48	c9 20		cmp #$20			cmp 	#32
.ee4a	f0 f7		beq $ee43			beq 	COMMAND_Let
.ee4c	88		dey				dey
.ee4d	c9 96		cmp #$96			cmp 	#KW_QUESTION				; check for first being indirect.
.ee4f	f0 51		beq $eea2			beq 	_CLEIndirect 				; e.g. !x = 42
.ee51	c9 80		cmp #$80			cmp 	#KW_PLING
.ee53	f0 4d		beq $eea2			beq 	_CLEIndirect
.ee55	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ee57	f0 49		beq $eea2			beq 	_CLEIndirect
.ee59	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ee5b	20 88 e4	jsr $e488			jsr 	VARReference 				; get a variable reference.
.ee5e	a5 24		lda $24				lda 	zTemp1 						; copy into target addr
.ee60	85 28		sta $28				sta 	zTargetAddr
.ee62	a5 25		lda $25				lda 	zTemp1+1
.ee64	85 29		sta $29				sta 	zTargetAddr+1
.ee66	a5 26		lda $26				lda 	zTemp1+2
.ee68	85 2a		sta $2a				sta 	zTargetAddr+2
.ee6a	a5 27		lda $27				lda 	zTemp1+3
.ee6c	85 2b		sta $2b				sta 	zTargetAddr+3
.ee6e					_CLEGetBinLHSOp:
.ee6e	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ee70	f0 2d		beq $ee9f			beq 	_CLESyntax
.ee72	c8		iny				iny
.ee73	c9 20		cmp #$20			cmp 	#' '
.ee75	f0 f7		beq $ee6e			beq 	_CLEGetBinLHSOp
.ee77	88		dey				dey
.ee78	c9 96		cmp #$96			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ee7a	f0 45		beq $eec1			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ee7c	c9 80		cmp #$80			cmp 	#KW_PLING
.ee7e	f0 41		beq $eec1			beq 	_CLEBinaryLHTerm
.ee80	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ee82	f0 3d		beq $eec1			beq 	_CLEBinaryLHTerm
.ee84	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ee86					_CLEWriteToAddress:
.ee86	48		pha				pha 								; save write-type.
.ee87	a9 93		lda #$93			lda 	#KW_EQUAL 					; check for '=' sign.
.ee89	20 b8 e1	jsr $e1b8			jsr 	CheckNextCharacter
.ee8c	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; evaluate the RHS.
.ee8f	68		pla				pla
.ee90	c9 80		cmp #$80			cmp 	#KW_PLING
.ee92	f0 7d		beq $ef11			beq 	_CLEWordWrite
.ee94	c9 96		cmp #$96			cmp 	#KW_QUESTION
.ee96	f0 60		beq $eef8			beq 	_CLEByteWrite
.ee98	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ee9a					_ErrorInternal:
.ee9a	d0 fe		bne $ee9a			bne 	_ErrorInternal
.ee9c	4c 51 ef	jmp $ef51			jmp 	_CLEStringWrite
.ee9f					_CLESyntax:
.ee9f	4c 62 e1	jmp $e162			jmp 	SyntaxError
.eea2					_CLEIndirect:
.eea2	48		pha				pha 								; save operator on stack
.eea3	c8		iny				iny									; advance over cursor
.eea4	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.eea6	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel
.eea9	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.eeac	85 28		sta $28				sta 	zTargetAddr+0
.eeae	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eeb1	85 29		sta $29				sta 	zTargetAddr+1
.eeb3	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.eeb6	85 2a		sta $2a				sta 	zTargetAddr+2
.eeb8	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.eebb	85 2b		sta $2b				sta 	zTargetAddr+3
.eebd	68		pla				pla 								; restore operator.
.eebe	4c 86 ee	jmp $ee86			jmp 	_CLEWriteToAddress
.eec1					_CLEBinaryLHTerm:
.eec1	48		pha				pha 								; save operator on stack
.eec2	c8		iny				iny 								; skip over it.
.eec3	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.eec5	20 3f e2	jsr $e23f			jsr 	EvaluateAtomCurrentLevel
.eec8	a5 28		lda $28				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.eeca	85 24		sta $24				sta 	zTemp1 						; a four byte address.....
.eecc	a5 29		lda $29				lda 	zTargetAddr+1
.eece	85 25		sta $25				sta 	zTemp1+1 					; we only worry about 4 byte value
.eed0	5a		phy				phy 								; save Y
.eed1	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.eed2	a0 00		ldy #$00			ldy 	#0
.eed4	b1 24		lda ($24),y			lda 	(zTemp1),y
.eed6	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.eed9	85 28		sta $28				sta 	zTargetAddr+0
.eedb	c8		iny				iny
.eedc	b1 24		lda ($24),y			lda 	(zTemp1),y
.eede	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.eee1	85 29		sta $29				sta 	zTargetAddr+1
.eee3	c8		iny				iny
.eee4	b1 24		lda ($24),y			lda 	(zTemp1),y
.eee6	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.eee9	85 2a		sta $2a				sta 	zTargetAddr+2
.eeeb	c8		iny				iny
.eeec	b1 24		lda ($24),y			lda 	(zTemp1),y
.eeee	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.eef1	85 2b		sta $2b				sta 	zTargetAddr+3
.eef3	7a		ply				ply 								; restore Y
.eef4	68		pla				pla 								; restore the operator.
.eef5	4c 86 ee	jmp $ee86			jmp 	_CLEWriteToAddress
.eef8					_CLEByteWrite:
.eef8	a5 2a		lda $2a				lda 	zTargetAddr+2
.eefa	05 2b		ora $2b				ora 	zTargetAddr+3
.eefc	d0 0a		bne $ef08			bne 	_CLEByteWriteExt
.eefe	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ef01	5a		phy				phy 								; write the byte preserving Y
.ef02	a0 00		ldy #$00			ldy 	#0
.ef04	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef06	7a		ply				ply
.ef07	60		rts				rts
.ef08					_CLEByteWriteExt:
.ef08	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ef0b	a3 00		ldz #$00			ldz 	#0
.ef0d	ea		nop				nop
.ef0e	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ef10	60		rts				rts
.ef11					_CLEWordWrite:
.ef11	a5 2a		lda $2a				lda 	zTargetAddr+2
.ef13	05 2b		ora $2b				ora 	zTargetAddr+3
.ef15	d0 1c		bne $ef33			bne 	_CLEWordWriteExt
.ef17	5a		phy				phy
.ef18	a0 00		ldy #$00			ldy 	#0
.ef1a	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ef1d	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef1f	c8		iny				iny
.ef20	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ef23	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef25	c8		iny				iny
.ef26	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ef29	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef2b	c8		iny				iny
.ef2c	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ef2f	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef31	7a		ply				ply 								; restore Y
.ef32	60		rts				rts
.ef33					_CLEWordWriteExt:
.ef33	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ef36	a3 00		ldz #$00			ldz 	#0
.ef38	ea		nop				nop
.ef39	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ef3b	1b		inz				inz
.ef3c	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ef3f	ea		nop				nop
.ef40	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ef42	1b		inz				inz
.ef43	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ef46	ea		nop				nop
.ef47	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ef49	1b		inz				inz
.ef4a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ef4d	ea		nop				nop
.ef4e	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ef50	60		rts				rts
.ef51					_CLEStringWrite:
.ef51	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.ef54	85 24		sta $24				sta 	zTemp1
.ef56	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ef59	85 25		sta $25				sta 	zTemp1+1
.ef5b	5a		phy				phy
.ef5c	a0 00		ldy #$00			ldy 	#0
.ef5e					_CLEStringCopy:
.ef5e	b1 24		lda ($24),y			lda 	(zTemp1),y
.ef60	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ef62	c9 00		cmp #$00			cmp 	#0
.ef64	f0 16		beq $ef7c			beq	 	_CLEStringWritten
.ef66	c8		iny				iny
.ef67	d0 f5		bne $ef5e			bne 	_CLEStringCopy
.ef69	20 72 e1	jsr $e172			jsr 	ReportError
>ef6c	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>ef74	4e 47 20 43 4f 50 59 00
.ef7c					_CLEStringWritten:
.ef7c	7a		ply				ply
.ef7d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.ef7e					COMMAND_List:
.ef7e	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look first non space
.ef80	c8		iny				iny
.ef81	c9 20		cmp #$20			cmp 	#' '
.ef83	f0 f9		beq $ef7e			beq 	COMMAND_List
.ef85	88		dey				dey
.ef86	c9 30		cmp #$30			cmp 	#"0" 						; not digit, list all
.ef88	90 0e		bcc $ef98			bcc 	_CLIAll
.ef8a	c9 3a		cmp #$3a			cmp 	#"9"+1
.ef8c	b0 0a		bcs $ef98			bcs 	_CLIAll
.ef8e	a2 00		ldx #$00			ldx 	#0 							; evaluate the linenumber
.ef90	20 43 e2	jsr $e243			jsr 	EvaluateBase
.ef93	20 c0 ed	jsr $edc0			jsr 	FindProgramLine 			; find that program Line, put in zTargetAddr
.ef96	80 09		bra $efa1			bra 	_CLIMain 					; list it.
.ef98					_CLIAll:
.ef98	5a		phy				phy
.ef99	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.ef9b	85 28		sta $28				sta 	zTargetAddr
.ef9d	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ef9f	85 29		sta $29				sta 	zTargetAddr+1
.efa1					_CLIMain:
.efa1	a9 10		lda #$10			lda 	#16 						; print 16 lines
.efa3	85 2a		sta $2a				sta 	zTargetAddr+2
.efa5					_CLLILoop:
.efa5	a0 00		ldy #$00			ldy 	#0
.efa7	b1 28		lda ($28),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.efa9	f0 14		beq $efbf			beq 	_CLLIExit
.efab	20 c3 ef	jsr $efc3			jsr 	CLIOneLine 					; list one line.
.efae	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.efb0	18		clc				clc
.efb1	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efb3	65 28		adc $28				adc 	zTargetAddr
.efb5	85 28		sta $28				sta 	zTargetAddr
.efb7	90 02		bcc $efbb			bcc 	_CLLINoCarry
.efb9	e6 29		inc $29				inc 	zTargetAddr+1
.efbb					_CLLINoCarry:
.efbb	c6 2a		dec $2a				dec 	zTargetAddr+2 				; done all of them ?
.efbd	d0 e6		bne $efa5			bne 	_CLLILoop
.efbf					_CLLIExit:
.efbf	7a		ply				ply
.efc0	4c 14 f3	jmp $f314			jmp 	WarmStart
.efc3					CLIOneLine:
.efc3	a0 01		ldy #$01			ldy 	#1 							; get line#
.efc5	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efc7	8d 00 04	sta $0400			sta 	evalStack+0
.efca	c8		iny				iny
.efcb	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efcd	8d 01 04	sta $0401			sta 	evalStack+1
.efd0	a9 00		lda #$00			lda 	#0
.efd2	aa		tax				tax
.efd3	8d 02 04	sta $0402			sta 	evalStack+2
.efd6	8d 03 04	sta $0403			sta 	evalStack+3
.efd9	20 09 f2	jsr $f209			jsr 	CPRPrintInteger 			; print line#
.efdc	a9 20		lda #$20			lda 	#32
.efde	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.efe1	a0 03		ldy #$03			ldy 	#3 							; where to start
.efe3					_CLIOutput:
.efe3	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efe5	c8		iny				iny
.efe6	09 00		ora #$00			ora 	#0
.efe8	f0 0c		beq $eff6			beq 	_CLIExit
.efea	10 05		bpl $eff1			bpl		_CLISingle
.efec	20 fc ef	jsr $effc			jsr 	CLIPrintToken
.efef	80 f2		bra $efe3			bra 	_CLIOutput
.eff1					_CLISingle:
.eff1	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.eff4	80 ed		bra $efe3			bra 	_CLIOutput
.eff6					_CLIExit:
.eff6	a9 0d		lda #$0d			lda 	#13 						; new line.
.eff8	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.effb	60		rts				rts
.effc					CLIPrintToken:
.effc	5a		phy				phy 								; save Y
.effd	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.efff	a8		tay				tay
.f000	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.f002					_CLIFind:
.f002	88		dey				dey 								; decrement counter
.f003	30 09		bmi $f00e			bmi 	_CLIFoundToken 				; if -ve found the token.
.f005					_CLISkip:
.f005	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.f008	e8		inx				inx
.f009	0a		asl a				asl		a
.f00a	90 f9		bcc $f005			bcc 	_CLISkip
.f00c	80 f4		bra $f002			bra 	_CLIFind
.f00e					_CLIFoundToken:
.f00e	7a		ply				ply
.f00f					_CLIPrintIt:
.f00f	bd 7e e0	lda $e07e,x			lda 	TokenText,x
.f012	e8		inx				inx
.f013	48		pha				pha
.f014	29 7f		and #$7f			and 	#$7F
.f016	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.f019	68		pla				pla
.f01a	0a		asl a				asl 	a
.f01b	90 f2		bcc $f00f			bcc 	_CLIPrintIt
.f01d	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.f01e					COMMAND_Assert:
.f01e	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; evaluate the expression
.f021	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.f024	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.f027	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.f02a	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f02d	d0 12		bne $f041			bne 	_CMDAExit
.f02f	ea		nop				nop
.f030	20 72 e1	jsr $e172			jsr 	ReportError
>f033	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>f03b	41 49 4c 45 44 00
.f041					_CMDAExit:
.f041	60		rts				rts
.f042					COMMAND_Rem:
.f042	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.f044	f0 05		beq $f04b			beq 	_CREMExit 					; End of line, then exit.
.f046	c8		iny				iny 								; something to skip
.f047	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; if not a colon
.f049	d0 f7		bne $f042			bne 	COMMAND_Rem 				; keep searching
.f04b					_CREMExit:
.f04b	60		rts				rts
.f04c					COMMAND_NewExec:
.f04c	20 52 f0	jsr $f052			jsr 	COMMAND_NewCode
.f04f	4c 14 f3	jmp $f314			jmp 	WarmStart
.f052					COMMAND_NewCode:
.f052	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.f054	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.f057	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.f05a	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.f05c	8d be 20	sta $20be			sta 	HighMemory
.f05f	a9 80		lda #$80			lda 	#endMemory >> 8
.f061	8d bf 20	sta $20bf			sta 	HighMemory+1
.f064	60		rts				rts
.f065					COMMAND_Clear:
.f065	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.f067					_CCClearVar:
.f067	a9 00		lda #$00			lda 	#$00
.f069	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.f06c	e8		inx				inx
.f06d	e0 6c		cpx #$6c			cpx 	#27*4
.f06f	10 f6		bpl $f067			bpl 	_CCClearVar
.f071	a9 00		lda #$00			lda 	#0 							; reset BASIC stack index
.f073	8d cb 20	sta $20cb			sta 	basicStackIndex
.f076	a9 ff		lda #$ff			lda 	#$FF 						; put invalid token on TOS, so when pulled.
.f078	8d 00 02	sta $0200			sta 	basicStack 					; causes an error.
.f07b	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.f07d	85 22		sta $22				sta 	zLowMemory
.f07f	a9 23		lda #$23			lda 	#BasicProgram >> 8
.f081	85 23		sta $23				sta 	zLowMemory+1
.f083					_CCFindEnd:
.f083	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.f085	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.f087	f0 0b		beq $f094			beq 	_CCFoundEnd
.f089	18		clc				clc 								; go to next line.
.f08a	65 22		adc $22				adc 	zLowMemory
.f08c	85 22		sta $22				sta 	zLowMemory
.f08e	90 f3		bcc $f083			bcc 	_CCFindEnd
.f090	e6 23		inc $23				inc 	zLowMemory+1
.f092	80 ef		bra $f083			bra 	_CCFindEnd
.f094					_CCFoundEnd:
.f094	e6 22		inc $22				inc 	zLowMemory 					; variables etc. start after end of program.
.f096	d0 02		bne $f09a			bne 	_CCNoCarry 					; skip over zero end offset.
.f098	e6 23		inc $23				inc 	zLowMemory+1
.f09a					_CCNoCarry:
.f09a	60		rts				rts
.f09b					COMMAND_OldExec:
.f09b	20 a1 f0	jsr $f0a1			jsr 	COMMAND_OldCode
.f09e	4c 14 f3	jmp $f314			jmp 	WarmStart
.f0a1					COMMAND_OldCode:
.f0a1	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.f0a3	85 22		sta $22				sta 	zLowMemory
.f0a5	a9 23		lda #$23			lda 	#BasicProgram >> 8
.f0a7	85 23		sta $23				sta 	zLowMemory+1
.f0a9	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.f0ab					_COScan:
.f0ab	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; look at next byte pair
.f0ad	c8		iny				iny
.f0ae	f0 0d		beq $f0bd			beq 	_COFail 					; can't find marker, corrupted maybe ?
.f0b0	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.f0b2	d0 f7		bne $f0ab			bne 	_COScan
.f0b4	98		tya				tya 								; Y is the new offset to the next instruction
.f0b5	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.f0b7	91 22		sta ($22),y			sta 	(zLowMemory),y
.f0b9	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.f0bc	60		rts				rts
.f0bd					_COFail:
.f0bd	20 72 e1	jsr $e172			jsr 	ReportError
>f0c0	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>f0c8	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00
.f0d7					COMMAND_RST:
.f0d7	20 d6 b0	jsr $b0d6			jsr 	EXTReset
.f0da	60		rts				rts
.f0db					COMMAND_LINK:
.f0db	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; evaluate the expression, where to call
.f0de	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; check non zero
.f0e1	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f0e4	d0 36		bne $f11c			bne 	_CLKError
.f0e6	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy link address
.f0e9	8d d1 20	sta $20d1			sta 	linkAddress
.f0ec	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.f0ef	8d d2 20	sta $20d2			sta 	linkAddress+1
.f0f2	5a		phy				phy 								; save Y
.f0f3	08		php				php 								; save PSW.
.f0f4	ad d0 20	lda $20d0			lda 	registers+4 				; load P A X Y Z
.f0f7	48		pha				pha
.f0f8	ad cc 20	lda $20cc			lda 	registers+0
.f0fb	ae cd 20	ldx $20cd			ldx 	registers+1
.f0fe	ac ce 20	ldy $20ce			ldy 	registers+2
.f101	ab cf 20	ldz $20cf			ldz 	registers+3
.f104	28		plp				plp
.f105	20 30 f1	jsr $f130			jsr 	_CLKGoLink 					; call code.
.f108	08		php				php 								; save A X Y Z P
.f109	8d cc 20	sta $20cc			sta 	registers+0
.f10c	8e cd 20	stx $20cd			stx 	registers+1
.f10f	8c ce 20	sty $20ce			sty 	registers+2
.f112	9c cf 20	stz $20cf			stz 	registers+3
.f115	68		pla				pla
.f116	8d d0 20	sta $20d0			sta 	registers+4
.f119	28		plp				plp 								; restore PSW and Y, return.
.f11a	7a		ply				ply
.f11b	60		rts				rts
.f11c					_CLKError:
.f11c	20 72 e1	jsr $e172			jsr 	ReportError
>f11f	42 41 44 20 43 4f 44 45				.text 	"BAD CODE ADDRESS",$00
>f127	20 41 44 44 52 45 53 53 00
.f130					_CLKGoLink:
.f130	6c d1 20	jmp ($20d1)			jmp 	(linkAddress)

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.f133					COMMAND_Print:
.f133	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.f135	f0 29		beq $f160			beq 	_CPRExitNL 					; zero end of line.
.f137	c8		iny				iny
.f138	c9 20		cmp #$20			cmp 	#' '
.f13a	f0 f7		beq $f133			beq 	COMMAND_Print
.f13c	c9 8e		cmp #$8e			cmp 	#KW_COLON 					; colon, end of line
.f13e	f0 20		beq $f160			beq 	_CPRExitNL
.f140	c9 8b		cmp #$8b			cmp 	#KW_COMMA 					; comma, tab
.f142	f0 0d		beq $f151			beq 	_CPRTab
.f144	c9 8f		cmp #$8f			cmp 	#KW_SEMICOLON 				; semicolon ?
.f146	d0 1e		bne $f166			bne 	_CPRNotSemicolon
.f148	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.f14a	f0 19		beq $f165			beq 	_CPRExit
.f14c	c9 8e		cmp #$8e			cmp 	#KW_COLON
.f14e	d0 e3		bne $f133			bne 	COMMAND_Print 				; if not, just go back round again
.f150	60		rts				rts
.f151	a9 09		lda #$09	_CPRTab:lda 	#9 							; print tab.
.f153	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.f156	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next.
.f158	f0 0b		beq $f165			beq 	_CPRExit 					; exit if 0 or :
.f15a	c9 8e		cmp #$8e			cmp 	#KW_COLON
.f15c	f0 07		beq $f165			beq 	_CPRExit
.f15e	80 d3		bra $f133			bra 	COMMAND_Print
.f160					_CPRExitNL:
.f160	a9 0d		lda #$0d			lda 	#13
.f162	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.f165					_CPRExit:
.f165	60		rts				rts
.f166					_CPRNotSemicolon:
.f166	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.f168	f0 2b		beq $f195			beq 	_CPRNewLine 				; new line
.f16a	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.f16c	d0 2e		bne $f19c			bne 	_CPRNotQuote
.f16e					_CPRPrintText:
.f16e	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.f170	f0 0a		beq $f17c			beq 	_CPRError 					; if zero no closing quote
.f172	c8		iny				iny
.f173	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.f175	f0 bc		beq $f133			beq 	COMMAND_Print 				; go round again.
.f177	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter 			; print and do next character
.f17a	80 f2		bra $f16e			bra 	_CPRPrintText
.f17c					_CPRError:
.f17c	20 72 e1	jsr $e172			jsr 	ReportError
>f17f	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>f187	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.f195					_CPRNewLine:
.f195	a9 0d		lda #$0d			lda 	#13
.f197	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.f19a	80 97		bra $f133			bra 	COMMAND_Print
.f19c					_CPRNotQuote:
.f19c	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.f19e	d0 11		bne $f1b1			bne 	_CPRNumber 					; print a number.
.f1a0	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; this is the address to print.
.f1a3	5a		phy				phy
.f1a4	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.f1a7	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.f1aa	aa		tax				tax
.f1ab	20 15 e5	jsr $e515			jsr 	SIOPrintString
.f1ae	7a		ply				ply
.f1af	80 82		bra $f133			bra 	COMMAND_Print
.f1b1					_CPRNumber:
.f1b1	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.f1b3	f0 17		beq $f1cc			beq 	_CPRHexadecimal
.f1b5	88		dey				dey 								; must be 1st char of expr
.f1b6	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; this is the value to print.
.f1b9	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.f1bc	10 08		bpl $f1c6			bpl 	_CPRIsPositive
.f1be	20 c0 ea	jsr $eac0			jsr 	BFUNC_NegateAlways 			; negate it
.f1c1	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.f1c3	20 42 e5	jsr $e542			jsr 	SIOPrintCharacter
.f1c6					_CPRIsPositive:
.f1c6	20 09 f2	jsr $f209			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.f1c9	4c 33 f1	jmp $f133			jmp 	COMMAND_Print
.f1cc					_CPRHexadecimal:
.f1cc	20 43 e2	jsr $e243			jsr 	EvaluateBase 				; this is the value to print.
.f1cf	20 d5 f1	jsr $f1d5			jsr 	_CPRPrintRecHex 			; hex version of it.
.f1d2	4c 33 f1	jmp $f133			jmp 	COMMAND_Print
.f1d5					_CPRPrintRecHex:
.f1d5	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.f1d8	29 0f		and #$0f			and 	#15 						; and put on stack
.f1da	48		pha				pha
.f1db	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.f1dd					_CPRShiftDiv:
.f1dd	4e 03 04	lsr $0403			lsr 	evalStack+3
.f1e0	6e 02 04	ror $0402			ror 	evalStack+2
.f1e3	6e 01 04	ror $0401			ror		evalStack+1
.f1e6	6e 00 04	ror $0400			ror		evalStack+0
.f1e9	ca		dex				dex
.f1ea	d0 f1		bne $f1dd			bne 	_CPRShiftDiv
.f1ec	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.f1ef	0d 01 04	ora $0401			ora 	evalStack+1
.f1f2	0d 02 04	ora $0402			ora 	evalStack+2
.f1f5	0d 03 04	ora $0403			ora 	evalStack+3
.f1f8	f0 03		beq $f1fd			beq 	_CPRNoHexRec
.f1fa	20 d5 f1	jsr $f1d5			jsr 	_CPRPrintRecHex
.f1fd					_CPRNoHexRec:
.f1fd	68		pla				pla 								; original remainder.
.f1fe	c9 0a		cmp #$0a			cmp 	#10
.f200	90 02		bcc $f204			bcc		_CPRNH2
.f202	69 06		adc #$06			adc 	#6
.f204	69 30		adc #$30	_CPRNH2:adc 	#48
.f206	4c 42 e5	jmp $e542			jmp 	SIOPrintCharacter
.f209					CPRPrintInteger:
.f209	48		pha				pha 								; save on stack.
.f20a	da		phx				phx
.f20b	5a		phy				phy
.f20c	20 13 f2	jsr $f213			jsr 	_CPRPrintRec 				; recursive print call
.f20f	7a		ply				ply
.f210	fa		plx				plx
.f211	68		pla				pla
.f212	60		rts				rts
.f213					_CPRPrintRec:
.f213	a9 0a		lda #$0a			lda 	#10 						; save base
.f215	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.f218	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.f21a	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.f21d	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.f220	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.f223	20 1d ea	jsr $ea1d			jsr 	BFUNC_Divide 				; divide by 10.
.f226	ad c0 20	lda $20c0			lda 	Temp1+0		 				; push remainder on stack
.f229	48		pha				pha
.f22a	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.f22d	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.f230	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.f233	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f236	f0 03		beq $f23b			beq 	_CPRNoRecurse
.f238	20 13 f2	jsr $f213			jsr 	_CPRPrintRec 				; recursive print.
.f23b					_CPRNoRecurse:
.f23b	68		pla				pla
.f23c	09 30		ora #$30			ora 	#"0"
.f23e	4c 42 e5	jmp $e542			jmp 	SIOPrintCharacter
.f241					COMMAND_CLS:
.f241	4c 07 e5	jmp $e507			jmp 	SIOClearScreen

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.f244					COMMAND_Run:
.f244	20 65 f0	jsr $f065			jsr 	COMMAND_Clear 				; clear everything for a new run.
.f247	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.f249	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.f24b	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.f24d	84 21		sty $21				sty 	zCurrentLine+1
.f24f					CRUNNewLine:
.f24f	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.f251	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f253	f0 78		beq $f2cd			beq 	COMMAND_End 				; if zero, off end of program so stop.
.f255	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.f257					CRUNNextInstruction:
.f257	ee ca 20	inc $20ca			inc 	breakCheckCount 			; don't check every time, might be slow.
.f25a	ad ca 20	lda $20ca			lda 	breakCheckCount
.f25d	29 1f		and #$1f			and 	#$1F 						; checking once in 32.
.f25f	f0 0e		beq $f26f			beq 	_CRUNNoCheck
.f261	20 55 b0	jsr $b055			jsr 	EXTCheckBreak
.f264	f0 09		beq $f26f			beq 	_CRUNNoCheck
.f266	20 72 e1	jsr $e172			jsr 	ReportError
>f269	42 52 45 41 4b 00				.text 	"BREAK",$00
.f26f					_CRUNNoCheck:
.f26f	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.f271	8d c5 20	sta $20c5			sta 	StringBufferPos
.f274	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.f276	f0 0b		beq $f283			beq 	CRUNNextLine 				; if zero, then end of line.
.f278					CRUNNotEndOfLine:
.f278	c9 20		cmp #$20			cmp 	#' '
.f27a	f0 04		beq $f280			beq 	CRUNSkipLoop
.f27c	c9 8e		cmp #$8e			cmp 	#KW_Colon 					; check for a colon first.
.f27e	d0 1b		bne $f29b			bne 	CRUNExecuteOne 				; if not that, execute the token.
.f280					CRUNSkipLoop:
.f280	c8		iny				iny		 							; if colon, skip it and loop round.
.f281	80 d4		bra $f257			bra 	CRUNNextInstruction
.f283					CRUNNextLine:
.f283	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.f285	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.f287	f0 0f		beq $f298			beq		CRUNWarmStart
.f289	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.f28b	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f28d	18		clc				clc
.f28e	65 20		adc $20				adc 	zCurrentLine
.f290	85 20		sta $20				sta 	zCurrentLine
.f292	90 bb		bcc $f24f			bcc 	CRUNNewLine
.f294	e6 21		inc $21				inc 	zCurrentLine+1
.f296	80 b7		bra $f24f			bra 	CRUNNewLine
.f298					CRUNWarmStart:
.f298	4c 14 f3	jmp $f314			jmp 	WarmStart
.f29b					CRUNExecuteOne:
.f29b	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.f29d	10 21		bpl $f2c0			bpl		_CRUNX1TryLet
.f29f	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.f2a1	f0 1d		beq $f2c0			beq 	_CRUNX1TryLet
.f2a3	c9 80		cmp #$80			cmp 	#KW_PLING
.f2a5	f0 19		beq $f2c0			beq 	_CRUNX1TryLet
.f2a7	c9 96		cmp #$96			cmp 	#KW_QUESTION
.f2a9	f0 15		beq $f2c0			beq 	_CRUNX1TryLet
.f2ab	c8		iny				iny 								; skip over loaded token
.f2ac	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.f2ad	8d c1 20	sta $20c1			sta 	Temp1+1 					; this is the low byte into the KVT
.f2b0	8a		txa				txa
.f2b1	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.f2b3	8d c2 20	sta $20c2			sta 	Temp1+2
.f2b6	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.f2b8	8d c0 20	sta $20c0			sta 	Temp1+0
.f2bb	20 c0 20	jsr $20c0			jsr 	Temp1 						; call instruction
.f2be	80 97		bra $f257			bra 	CRUNNextInstruction 		; do next instruction.
.f2c0					_CRUNX1TryLet:
.f2c0	20 43 ee	jsr $ee43			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.f2c3	80 92		bra $f257			bra 	CRUNNextInstruction
.f2c5					COMMAND_Stop:
.f2c5	20 72 e1	jsr $e172			jsr 	ReportError
>f2c8	53 54 4f 50 00					.text 	"STOP",$00
.f2cd					COMMAND_End:
.f2cd	ad b2 b2	lda $b2b2			lda 	StartBehaviour 				; running program
.f2d0	c9 52		cmp #$52			cmp 	#"R"
.f2d2	d0 01		bne $f2d5			bne 	_CEWarmStart
>f2d4	02						.byte 	2
.f2d5					_CEWarmStart:
.f2d5	4c 14 f3	jmp $f314			jmp 	WarmStart

;******  Return to file: basic.asm

.f2d8					Start:
.f2d8	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f2da	9a		txs			txs
.f2db	20 04 e5	jsr $e504			jsr 	SIOInitialise 				; initialise the I/O system.
.f2de	a2 54		ldx #$54			ldx 	#BootMsg1 & 255 			; boot text.
.f2e0	a0 f3		ldy #$f3			ldy 	#BootMsg1 >> 8
.f2e2	20 15 e5	jsr $e515			jsr 	SIOPrintString
.f2e5	a2 ff		ldx #$ff			ldx 	#(endMemory-startMemory-1) & $FF
.f2e7	a0 5f		ldy #$5f			ldy 	#(endMemory-startMemory-1) >> 8
.f2e9	20 a1 e1	jsr $e1a1			jsr 	PrintWordInteger
.f2ec	a2 6b		ldx #$6b			ldx 	#BootMsg2 & 255
.f2ee	a0 f3		ldy #$f3			ldy 	#BootMsg2 >> 8
.f2f0	20 15 e5	jsr $e515			jsr 	SIOPrintString
.f2f3	ad b2 b2	lda $b2b2			lda 	StartBehaviour 				; what to do ?
.f2f6	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.f2f8	f0 17		beq $f311			beq		CommandLine
.f2fa	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.f2fc	f0 07		beq $f305			beq	 	RunProgram
.f2fe	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.f300	f0 46		beq $f348			beq 	TokeniseExec
.f302	4c 62 e1	jmp $e162			jmp		SyntaxError
.f305					RunProgram:
.f305	20 db e1	jsr $e1db			jsr 	CopyBasicCode
.f308	20 52 f0	jsr $f052			jsr 	COMMAND_NewCode 			; do a new
.f30b	20 a1 f0	jsr $f0a1			jsr 	COMMAND_OldCode 			; get back the old program as we're deving.
.f30e	4c 44 f2	jmp $f244			jmp 	COMMAND_Run
.f311					CommandLine:
.f311	20 52 f0	jsr $f052			jsr 	Command_NewCode
.f314					WarmStart:
.f314	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f316	9a		txs			txs
.f317	20 91 e5	jsr $e591			jsr 	SIOReadLine 				; read input line.
.f31a	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.f31c	85 24		sta $24				sta 	zTemp1
.f31e	a9 20		lda #$20			lda 	#InputLine >> 8
.f320	85 25		sta $25				sta 	zTemp1+1
.f322	20 01 e7	jsr $e701			jsr 	TokeniseString
.f325	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.f327	85 20		sta $20				sta 	zCurrentLine
.f329	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.f32b	85 21		sta $21				sta 	zCurrentLine+1
.f32d	a0 00		ldy #$00			ldy 	#0
.f32f					_WSSkipSpace:
.f32f	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f331	c8		iny				iny
.f332	c9 20		cmp #$20			cmp 	#' '
.f334	f0 f9		beq $f32f			beq 	_WSSkipSpace
.f336	88		dey				dey
.f337	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.f339	90 0a		bcc $f345			bcc 	_WSExecute
.f33b	c9 3a		cmp #$3a			cmp 	#"9"+1
.f33d	b0 06		bcs $f345			bcs 	_WSExecute
.f33f	20 d6 e7	jsr $e7d6			jsr 	EditProgram
.f342	4c 14 f3	jmp $f314			jmp 	WarmStart
.f345					_WSExecute:
.f345	4c 57 f2	jmp $f257			jmp 	CRUNNextInstruction
.f348					TokeniseExec:
.f348	a9 75		lda #$75			lda 	#IncludeBasicCode & $FF 	; if so tokenise whatever I've put in the basic code
.f34a	85 24		sta $24				sta 	zTemp1 						; area
.f34c	a9 b1		lda #$b1			lda 	#IncludeBasicCode >> 8
.f34e	85 25		sta $25				sta 	zTemp1+1
.f350	20 01 e7	jsr $e701			jsr 	TokeniseString
>f353	02						.byte 	2
.f354					BootMsg1:
>f354	2a 2a 2a 20 41 54 4f 4d				.text 	"*** ATOMIC BASIC ***",13,13,0
>f35c	49 43 20 42 41 53 49 43 20 2a 2a 2a 0d 0d 00
.f36b					BootMsg2:
>f36b	20 42 59 54 45 53 20 46				.text	" BYTES FREE.",13,13,0
>f373	52 45 45 2e 0d 0d 00

;******  End of listing
