
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q --m4510 -D TARGET=1 -b -L rom.lst -o rom.bin basic.asm
; Tue Jul 30 12:16:59 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=1					TARGET=1

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	78 f0						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_mega65.asm

=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$2000					EXTLowMemory = $2000 						; Workspace RAM starts here
=$8000					EXTHighMemory = $8000 						; Workspace RAM ends here
=$1000					EXTScreen = $1000							; 2k screen RAM here
=$800					EXTCharSet = $800							; 2k character set (0-7F) here
>0000	00 00					.word 	0 								; forces it to be a 64k ROM (at least)
.a000					EXTCBMFont:
>a000	3c 66 6e 6e 60 62 3c 00			.binary "c64-chargen.rom"
>a008	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>a018	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>a028	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>a038	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>a048	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>a058	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>a068	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>a078	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>a088	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>a098	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>a0a8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>a0b8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>a0c8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>a0d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a0e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a0f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a108	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a118	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a128	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a138	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a148	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a158	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a168	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a178	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a188	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a198	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a1a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a1b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a1c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a1d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a1e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a1f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>a208	08 1c 3e 7f 7f 1c 3e 00 18 18 18 18 18 18 18 18
>a218	00 00 00 ff ff 00 00 00 00 00 ff ff 00 00 00 00
>a228	00 ff ff 00 00 00 00 00 00 00 00 00 ff ff 00 00
>a238	30 30 30 30 30 30 30 30 0c 0c 0c 0c 0c 0c 0c 0c
>a248	00 00 00 e0 f0 38 18 18 18 18 1c 0f 07 00 00 00
>a258	18 18 38 f0 e0 00 00 00 c0 c0 c0 c0 c0 c0 ff ff
>a268	c0 e0 70 38 1c 0e 07 03 03 07 0e 1c 38 70 e0 c0
>a278	ff ff c0 c0 c0 c0 c0 c0 ff ff 03 03 03 03 03 03
>a288	00 3c 7e 7e 7e 7e 3c 00 00 00 00 00 00 ff ff 00
>a298	36 7f 7f 7f 3e 1c 08 00 60 60 60 60 60 60 60 60
>a2a8	00 00 00 07 0f 1c 18 18 c3 e7 7e 3c 3c 7e e7 c3
>a2b8	00 3c 7e 66 66 7e 3c 00 18 18 66 66 18 18 3c 00
>a2c8	06 06 06 06 06 06 06 06 08 1c 3e 7f 3e 1c 08 00
>a2d8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>a2e8	18 18 18 18 18 18 18 18 00 00 03 3e 76 36 36 00
>a2f8	ff 7f 3f 1f 0f 07 03 01 00 00 00 00 00 00 00 00
>a308	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>a318	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>a328	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>a338	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>a348	ff fe fc f8 f0 e0 c0 80 03 03 03 03 03 03 03 03
>a358	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>a368	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>a378	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>a388	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>a398	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>a3a8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>a3b8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>a3c8	00 00 00 00 00 ff ff ff 03 03 03 03 03 03 ff ff
>a3d8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>a3e8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>a3f8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>a408	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>a418	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>a428	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>a438	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>a448	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>a458	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>a468	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>a478	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>a488	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>a498	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>a4a8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>a4b8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>a4c8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>a4d8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>a4e8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>a4f8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>a508	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>a518	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>a528	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>a538	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>a548	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>a558	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>a568	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>a578	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>a588	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>a598	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>a5a8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>a5b8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>a5c8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>a5d8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>a5e8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>a5f8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>a608	f7 e3 c1 80 80 e3 c1 ff e7 e7 e7 e7 e7 e7 e7 e7
>a618	ff ff ff 00 00 ff ff ff ff ff 00 00 ff ff ff ff
>a628	ff 00 00 ff ff ff ff ff ff ff ff ff 00 00 ff ff
>a638	cf cf cf cf cf cf cf cf f3 f3 f3 f3 f3 f3 f3 f3
>a648	ff ff ff 1f 0f c7 e7 e7 e7 e7 e3 f0 f8 ff ff ff
>a658	e7 e7 c7 0f 1f ff ff ff 3f 3f 3f 3f 3f 3f 00 00
>a668	3f 1f 8f c7 e3 f1 f8 fc fc f8 f1 e3 c7 8f 1f 3f
>a678	00 00 3f 3f 3f 3f 3f 3f 00 00 fc fc fc fc fc fc
>a688	ff c3 81 81 81 81 c3 ff ff ff ff ff ff 00 00 ff
>a698	c9 80 80 80 c1 e3 f7 ff 9f 9f 9f 9f 9f 9f 9f 9f
>a6a8	ff ff ff f8 f0 e3 e7 e7 3c 18 81 c3 c3 81 18 3c
>a6b8	ff c3 81 99 99 81 c3 ff e7 e7 99 99 e7 e7 c3 ff
>a6c8	f9 f9 f9 f9 f9 f9 f9 f9 f7 e3 c1 80 c1 e3 f7 ff
>a6d8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>a6e8	e7 e7 e7 e7 e7 e7 e7 e7 ff ff fc c1 89 c9 c9 ff
>a6f8	00 80 c0 e0 f0 f8 fc fe ff ff ff ff ff ff ff ff
>a708	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>a718	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>a728	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>a738	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>a748	00 01 03 07 0f 1f 3f 7f fc fc fc fc fc fc fc fc
>a758	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>a768	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>a778	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>a788	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>a798	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>a7a8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>a7b8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>a7c8	ff ff ff ff ff 00 00 00 fc fc fc fc fc fc 00 00
>a7d8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>a7e8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>a7f8	0f 0f 0f 0f f0 f0 f0 f0 3c 66 6e 6e 60 62 3c 00
>a808	00 00 3c 06 3e 66 3e 00 00 60 60 7c 66 66 7c 00
>a818	00 00 3c 60 60 60 3c 00 00 06 06 3e 66 66 3e 00
>a828	00 00 3c 66 7e 60 3c 00 00 0e 18 3e 18 18 18 00
>a838	00 00 3e 66 66 3e 06 7c 00 60 60 7c 66 66 66 00
>a848	00 18 00 38 18 18 3c 00 00 06 00 06 06 06 06 3c
>a858	00 60 60 6c 78 6c 66 00 00 38 18 18 18 18 3c 00
>a868	00 00 66 7f 7f 6b 63 00 00 00 7c 66 66 66 66 00
>a878	00 00 3c 66 66 66 3c 00 00 00 7c 66 66 7c 60 60
>a888	00 00 3e 66 66 3e 06 06 00 00 7c 66 60 60 60 00
>a898	00 00 3e 60 3c 06 7c 00 00 18 7e 18 18 18 0e 00
>a8a8	00 00 66 66 66 66 3e 00 00 00 66 66 66 3c 18 00
>a8b8	00 00 63 6b 7f 3e 36 00 00 00 66 3c 18 3c 66 00
>a8c8	00 00 66 66 66 3e 0c 78 00 00 7e 0c 18 30 7e 00
>a8d8	3c 30 30 30 30 30 3c 00 0c 12 30 7c 30 62 fc 00
>a8e8	3c 0c 0c 0c 0c 0c 3c 00 00 18 3c 7e 18 18 18 18
>a8f8	00 10 30 7f 7f 30 10 00 00 00 00 00 00 00 00 00
>a908	18 18 18 18 00 00 18 00 66 66 66 00 00 00 00 00
>a918	66 66 ff 66 ff 66 66 00 18 3e 60 3c 06 7c 18 00
>a928	62 66 0c 18 30 66 46 00 3c 66 3c 38 67 66 3f 00
>a938	06 0c 18 00 00 00 00 00 0c 18 30 30 30 18 0c 00
>a948	30 18 0c 0c 0c 18 30 00 00 66 3c ff 3c 66 00 00
>a958	00 18 18 7e 18 18 00 00 00 00 00 00 00 18 18 30
>a968	00 00 00 7e 00 00 00 00 00 00 00 00 00 18 18 00
>a978	00 03 06 0c 18 30 60 00 3c 66 6e 76 66 66 3c 00
>a988	18 18 38 18 18 18 7e 00 3c 66 06 0c 30 60 7e 00
>a998	3c 66 06 1c 06 66 3c 00 06 0e 1e 66 7f 06 06 00
>a9a8	7e 60 7c 06 06 66 3c 00 3c 66 60 7c 66 66 3c 00
>a9b8	7e 66 0c 18 18 18 18 00 3c 66 66 3c 66 66 3c 00
>a9c8	3c 66 66 3e 06 66 3c 00 00 00 18 00 00 18 00 00
>a9d8	00 00 18 00 00 18 18 30 0e 18 30 60 30 18 0e 00
>a9e8	00 00 7e 00 7e 00 00 00 70 18 0c 06 0c 18 70 00
>a9f8	3c 66 06 0c 18 00 18 00 00 00 00 ff ff 00 00 00
>aa08	18 3c 66 7e 66 66 66 00 7c 66 66 7c 66 66 7c 00
>aa18	3c 66 60 60 60 66 3c 00 78 6c 66 66 66 6c 78 00
>aa28	7e 60 60 78 60 60 7e 00 7e 60 60 78 60 60 60 00
>aa38	3c 66 60 6e 66 66 3c 00 66 66 66 7e 66 66 66 00
>aa48	3c 18 18 18 18 18 3c 00 1e 0c 0c 0c 0c 6c 38 00
>aa58	66 6c 78 70 78 6c 66 00 60 60 60 60 60 60 7e 00
>aa68	63 77 7f 6b 63 63 63 00 66 76 7e 7e 6e 66 66 00
>aa78	3c 66 66 66 66 66 3c 00 7c 66 66 7c 60 60 60 00
>aa88	3c 66 66 66 66 3c 0e 00 7c 66 66 7c 78 6c 66 00
>aa98	3c 66 60 3c 06 66 3c 00 7e 18 18 18 18 18 18 00
>aaa8	66 66 66 66 66 66 3c 00 66 66 66 66 66 3c 18 00
>aab8	63 63 63 6b 7f 77 63 00 66 66 3c 18 3c 66 66 00
>aac8	66 66 66 3c 18 18 18 00 7e 06 0c 18 30 60 7e 00
>aad8	18 18 18 ff ff 18 18 18 c0 c0 30 30 c0 c0 30 30
>aae8	18 18 18 18 18 18 18 18 33 33 cc cc 33 33 cc cc
>aaf8	33 99 cc 66 33 99 cc 66 00 00 00 00 00 00 00 00
>ab08	f0 f0 f0 f0 f0 f0 f0 f0 00 00 00 00 ff ff ff ff
>ab18	ff 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ff
>ab28	c0 c0 c0 c0 c0 c0 c0 c0 cc cc 33 33 cc cc 33 33
>ab38	03 03 03 03 03 03 03 03 00 00 00 00 cc cc 33 33
>ab48	cc 99 33 66 cc 99 33 66 03 03 03 03 03 03 03 03
>ab58	18 18 18 1f 1f 18 18 18 00 00 00 00 0f 0f 0f 0f
>ab68	18 18 18 1f 1f 00 00 00 00 00 00 f8 f8 18 18 18
>ab78	00 00 00 00 00 00 ff ff 00 00 00 1f 1f 18 18 18
>ab88	18 18 18 ff ff 00 00 00 00 00 00 ff ff 18 18 18
>ab98	18 18 18 f8 f8 18 18 18 c0 c0 c0 c0 c0 c0 c0 c0
>aba8	e0 e0 e0 e0 e0 e0 e0 e0 07 07 07 07 07 07 07 07
>abb8	ff ff 00 00 00 00 00 00 ff ff ff 00 00 00 00 00
>abc8	00 00 00 00 00 ff ff ff 01 03 06 6c 78 70 60 00
>abd8	00 00 00 00 f0 f0 f0 f0 0f 0f 0f 0f 00 00 00 00
>abe8	18 18 18 f8 f8 00 00 00 f0 f0 f0 f0 00 00 00 00
>abf8	f0 f0 f0 f0 0f 0f 0f 0f c3 99 91 91 9f 99 c3 ff
>ac08	ff ff c3 f9 c1 99 c1 ff ff 9f 9f 83 99 99 83 ff
>ac18	ff ff c3 9f 9f 9f c3 ff ff f9 f9 c1 99 99 c1 ff
>ac28	ff ff c3 99 81 9f c3 ff ff f1 e7 c1 e7 e7 e7 ff
>ac38	ff ff c1 99 99 c1 f9 83 ff 9f 9f 83 99 99 99 ff
>ac48	ff e7 ff c7 e7 e7 c3 ff ff f9 ff f9 f9 f9 f9 c3
>ac58	ff 9f 9f 93 87 93 99 ff ff c7 e7 e7 e7 e7 c3 ff
>ac68	ff ff 99 80 80 94 9c ff ff ff 83 99 99 99 99 ff
>ac78	ff ff c3 99 99 99 c3 ff ff ff 83 99 99 83 9f 9f
>ac88	ff ff c1 99 99 c1 f9 f9 ff ff 83 99 9f 9f 9f ff
>ac98	ff ff c1 9f c3 f9 83 ff ff e7 81 e7 e7 e7 f1 ff
>aca8	ff ff 99 99 99 99 c1 ff ff ff 99 99 99 c3 e7 ff
>acb8	ff ff 9c 94 80 c1 c9 ff ff ff 99 c3 e7 c3 99 ff
>acc8	ff ff 99 99 99 c1 f3 87 ff ff 81 f3 e7 cf 81 ff
>acd8	c3 cf cf cf cf cf c3 ff f3 ed cf 83 cf 9d 03 ff
>ace8	c3 f3 f3 f3 f3 f3 c3 ff ff e7 c3 81 e7 e7 e7 e7
>acf8	ff ef cf 80 80 cf ef ff ff ff ff ff ff ff ff ff
>ad08	e7 e7 e7 e7 ff ff e7 ff 99 99 99 ff ff ff ff ff
>ad18	99 99 00 99 00 99 99 ff e7 c1 9f c3 f9 83 e7 ff
>ad28	9d 99 f3 e7 cf 99 b9 ff c3 99 c3 c7 98 99 c0 ff
>ad38	f9 f3 e7 ff ff ff ff ff f3 e7 cf cf cf e7 f3 ff
>ad48	cf e7 f3 f3 f3 e7 cf ff ff 99 c3 00 c3 99 ff ff
>ad58	ff e7 e7 81 e7 e7 ff ff ff ff ff ff ff e7 e7 cf
>ad68	ff ff ff 81 ff ff ff ff ff ff ff ff ff e7 e7 ff
>ad78	ff fc f9 f3 e7 cf 9f ff c3 99 91 89 99 99 c3 ff
>ad88	e7 e7 c7 e7 e7 e7 81 ff c3 99 f9 f3 cf 9f 81 ff
>ad98	c3 99 f9 e3 f9 99 c3 ff f9 f1 e1 99 80 f9 f9 ff
>ada8	81 9f 83 f9 f9 99 c3 ff c3 99 9f 83 99 99 c3 ff
>adb8	81 99 f3 e7 e7 e7 e7 ff c3 99 99 c3 99 99 c3 ff
>adc8	c3 99 99 c1 f9 99 c3 ff ff ff e7 ff ff e7 ff ff
>add8	ff ff e7 ff ff e7 e7 cf f1 e7 cf 9f cf e7 f1 ff
>ade8	ff ff 81 ff 81 ff ff ff 8f e7 f3 f9 f3 e7 8f ff
>adf8	c3 99 f9 f3 e7 ff e7 ff ff ff ff 00 00 ff ff ff
>ae08	e7 c3 99 81 99 99 99 ff 83 99 99 83 99 99 83 ff
>ae18	c3 99 9f 9f 9f 99 c3 ff 87 93 99 99 99 93 87 ff
>ae28	81 9f 9f 87 9f 9f 81 ff 81 9f 9f 87 9f 9f 9f ff
>ae38	c3 99 9f 91 99 99 c3 ff 99 99 99 81 99 99 99 ff
>ae48	c3 e7 e7 e7 e7 e7 c3 ff e1 f3 f3 f3 f3 93 c7 ff
>ae58	99 93 87 8f 87 93 99 ff 9f 9f 9f 9f 9f 9f 81 ff
>ae68	9c 88 80 94 9c 9c 9c ff 99 89 81 81 91 99 99 ff
>ae78	c3 99 99 99 99 99 c3 ff 83 99 99 83 9f 9f 9f ff
>ae88	c3 99 99 99 99 c3 f1 ff 83 99 99 83 87 93 99 ff
>ae98	c3 99 9f c3 f9 99 c3 ff 81 e7 e7 e7 e7 e7 e7 ff
>aea8	99 99 99 99 99 99 c3 ff 99 99 99 99 99 c3 e7 ff
>aeb8	9c 9c 9c 94 80 88 9c ff 99 99 c3 e7 c3 99 99 ff
>aec8	99 99 99 c3 e7 e7 e7 ff 81 f9 f3 e7 cf 9f 81 ff
>aed8	e7 e7 e7 00 00 e7 e7 e7 3f 3f cf cf 3f 3f cf cf
>aee8	e7 e7 e7 e7 e7 e7 e7 e7 cc cc 33 33 cc cc 33 33
>aef8	cc 66 33 99 cc 66 33 99 ff ff ff ff ff ff ff ff
>af08	0f 0f 0f 0f 0f 0f 0f 0f ff ff ff ff 00 00 00 00
>af18	00 ff ff ff ff ff ff ff ff ff ff ff ff ff ff 00
>af28	3f 3f 3f 3f 3f 3f 3f 3f 33 33 cc cc 33 33 cc cc
>af38	fc fc fc fc fc fc fc fc ff ff ff ff 33 33 cc cc
>af48	33 66 cc 99 33 66 cc 99 fc fc fc fc fc fc fc fc
>af58	e7 e7 e7 e0 e0 e7 e7 e7 ff ff ff ff f0 f0 f0 f0
>af68	e7 e7 e7 e0 e0 ff ff ff ff ff ff 07 07 e7 e7 e7
>af78	ff ff ff ff ff ff 00 00 ff ff ff e0 e0 e7 e7 e7
>af88	e7 e7 e7 00 00 ff ff ff ff ff ff 00 00 e7 e7 e7
>af98	e7 e7 e7 07 07 e7 e7 e7 3f 3f 3f 3f 3f 3f 3f 3f
>afa8	1f 1f 1f 1f 1f 1f 1f 1f f8 f8 f8 f8 f8 f8 f8 f8
>afb8	00 00 ff ff ff ff ff ff 00 00 00 ff ff ff ff ff
>afc8	ff ff ff ff ff 00 00 00 fe fc f9 93 87 8f 9f ff
>afd8	ff ff ff ff 0f 0f 0f 0f f0 f0 f0 f0 ff ff ff ff
>afe8	e7 e7 e7 07 07 ff ff ff 0f 0f 0f 0f ff ff ff ff
>aff8	0f 0f 0f 0f f0 f0 f0 f0
.b000					EXTStartPersonalise:
.b000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.b002	9a		txs			txs
.b003	20 b8 b0	jsr $b0b8		jsr 	EXTReset 						; reset video
.b006	20 68 b0	jsr $b068		jsr 	EXTClearScreen 					; clear screen
.b009	4c 78 f0	jmp $f078		jmp 	Start 							; start main application
.b00c					EXTReadKeyPort:
.b00c	db		phz			phz
.b00d	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress
.b010	ea		nop			nop 									; read keyboard
.b011	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b013	fb		plz			plz
.b014	c9 00		cmp #$00		cmp 	#0 								; set Z
.b016	60		rts			rts
.b017					EXTRemoveKeyPressed:
.b017	48		pha			pha
.b018	db		phz			phz
.b019	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress
.b01c	a9 00		lda #$00		lda 	#0
.b01e	ea		nop			nop 									; read keyboard
.b01f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b021	fb		plz			plz
.b022	68		pla			pla
.b023	60		rts			rts
.b024					EXTSetupKeyAddress:
.b024	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to read keyboard.
.b026	85 07		sta $07			sta 	EXTZPWork+3
.b028	a9 fd		lda #$fd		lda 	#$FD
.b02a	85 06		sta $06			sta 	EXTZPWork+2
.b02c	a9 36		lda #$36		lda 	#$36
.b02e	85 05		sta $05			sta 	EXTZPWork+1
.b030	a9 10		lda #$10		lda 	#$10
.b032	85 04		sta $04			sta 	EXTZPWork+0
.b034	a3 00		ldz #$00		ldz 	#0
.b036	60		rts			rts
.b037					EXTCheckBreak:
.b037	db		phz			phz
.b038	20 24 b0	jsr $b024		jsr 	EXTSetupKeyAddress 				; point to keyboard
.b03b	e6 04		inc $04			inc 	EXTZPWork 						; point to modifiers.
.b03d	ea		nop			nop 									; read modifiers.
.b03e	b2 04		lda ($04),z		lda 	(EXTZPWork),z
.b040	fb		plz			plz 									; restore Z
.b041	29 05		and #$05		and 	#5								; break is LeftShift+Ctrl
.b043	c9 05		cmp #$05		cmp 	#5
.b045	f0 03		beq $b04a		beq 	_EXTCBYes
.b047	a9 00		lda #$00		lda 	#0
.b049	60		rts			rts
.b04a					_EXTCBYes:
.b04a	a9 01		lda #$01		lda 	#1
.b04c	60		rts			rts
.b04d					EXTReadScreen:
.b04d	5a		phy			phy 										; save Y
.b04e	8a		txa			txa 										; multiply XY by 2
.b04f	85 04		sta $04			sta 	EXTZPWork							; into EXTZPWork
.b051	98		tya			tya
.b052	09 10		ora #$10		ora 	#EXTScreen>>8 						; move into screen area
.b054	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.b056	a0 00		ldy #$00		ldy 	#0
.b058	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b05a	7a		ply			ply 										; restore Y and exit.
.b05b	60		rts			rts
.b05c					EXTWriteScreen:
.b05c	5a		phy			phy
.b05d	48		pha			pha
.b05e	20 4d b0	jsr $b04d		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.b061	a0 00		ldy #$00		ldy 	#0
.b063	68		pla			pla 										; restore and write.
.b064	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b066	7a		ply			ply
.b067	60		rts			rts
.b068					EXTClearScreen:
.b068	48		pha			pha 										; save registers
.b069	5a		phy			phy
.b06a	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set up pointer
.b06c	85 04		sta $04			sta 	EXTZPWork
.b06e	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b070	85 05		sta $05			sta 	EXTZPWork+1
.b072	a0 00		ldy #$00		ldy 	#0
.b074					_EXTCSLoop:
.b074	a9 20		lda #$20		lda 	#32
.b076	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b078	c8		iny			iny
.b079	d0 f9		bne $b074		bne 	_EXTCSLoop
.b07b	e6 05		inc $05			inc 	EXTZPWork+1 						; next screen page
.b07d	a5 05		lda $05			lda 	EXTZPWork+1
.b07f	c9 18		cmp #$18		cmp 	#(EXTScreen>>8)+8 					; done 2k ?
.b081	d0 f1		bne $b074		bne 	_EXTCSLoop
.b083	7a		ply			ply 										; restore
.b084	68		pla			pla
.b085	60		rts			rts
.b086					EXTScrollDisplay:
.b086	48		pha			pha 										; save registers
.b087	5a		phy			phy
.b088	a9 00		lda #$00		lda 	#EXTScreen & $FF 					; set pointer to screen
.b08a	85 04		sta $04			sta 	EXTZPWork+0
.b08c	a9 10		lda #$10		lda 	#EXTScreen >> 8
.b08e	85 05		sta $05			sta 	EXTZPWork+1
.b090					_EXTScroll:
.b090	a0 28		ldy #$28		ldy 	#EXTWidth 							; x 2 because of two byte format.
.b092	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.b094	a0 00		ldy #$00		ldy 	#0
.b096	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b098	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.b09a	d0 02		bne $b09e		bne 	_EXTNoCarry
.b09c	e6 05		inc $05			inc 	EXTZPWork+1
.b09e					_EXTNoCarry:
.b09e	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.b0a0	c9 c0		cmp #$c0		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) & $FF
.b0a2	d0 ec		bne $b090		bne 	_EXTScroll
.b0a4	a5 05		lda $05			lda 	EXTZPWork+1
.b0a6	c9 13		cmp #$13		cmp	 	#(EXTScreen+EXTWidth*(EXTHeight-1)) >> 8
.b0a8	d0 e6		bne $b090		bne 	_EXTScroll
.b0aa	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.b0ac					_EXTLastLine:
.b0ac	a9 20		lda #$20		lda 	#32
.b0ae	91 04		sta ($04),y		sta 	(EXTZPWork),y
.b0b0	c8		iny			iny
.b0b1	c0 28		cpy #$28		cpy 	#EXTWidth
.b0b3	d0 f7		bne $b0ac		bne 	_EXTLastLine
.b0b5	7a		ply			ply 										; restore and exit.
.b0b6	68		pla			pla
.b0b7	60		rts			rts
.b0b8					EXTReset:
.b0b8	48		pha			pha 									; save registers
.b0b9	da		phx			phx
.b0ba	5a		phy			phy
.b0bb	a9 0f		lda #$0f		lda 	#$0F 							; set up to write to video system.
.b0bd	85 07		sta $07			sta 	EXTZPWork+3
.b0bf	a9 fd		lda #$fd		lda 	#$FD
.b0c1	85 06		sta $06			sta 	EXTZPWork+2
.b0c3	a9 30		lda #$30		lda 	#$30
.b0c5	85 05		sta $05			sta 	EXTZPWork+1
.b0c7	a9 00		lda #$00		lda 	#$00
.b0c9	85 04		sta $04			sta 	EXTZPWork+0
.b0cb	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0cd	a9 47		lda #$47		lda 	#$47
.b0cf	ea		nop			nop
.b0d0	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0d2	a3 2f		ldz #$2f		ldz 	#$2F 							; address already set up
.b0d4	a9 53		lda #$53		lda 	#$53
.b0d6	ea		nop			nop
.b0d7	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0d9	a3 30		ldz #$30		ldz 	#$30 							; address already set up
.b0db	a9 40		lda #$40		lda 	#$40
.b0dd	ea		nop			nop
.b0de	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0e0	a3 31		ldz #$31		ldz 	#$31 							; address already set up
.b0e2	a9 40		lda #$40		lda 	#$40
.b0e4	ea		nop			nop
.b0e5	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0e7	ad 31 d0	lda $d031		lda $d031	; VIC-III Control Register B
.b0ea	29 40		and #$40		and #$40	; bit-6 is 4mhz
.b0ec	8d 31 d0	sta $d031		sta $d031
.b0ef	a3 20		ldz #$20		ldz 	#$20 							; address already set up
.b0f1	a9 00		lda #$00		lda 	#0
.b0f3	ea		nop			nop
.b0f4	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0f6	a3 21		ldz #$21		ldz 	#$21 							; address already set up
.b0f8	a9 00		lda #$00		lda 	#0
.b0fa	ea		nop			nop
.b0fb	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b0fd	a3 6f		ldz #$6f		ldz 	#$6F 							; address already set up
.b0ff	a9 80		lda #$80		lda 	#$80
.b101	ea		nop			nop
.b102	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b104	ad 66 d0	lda $d066		lda $d066
.b107	29 7f		and #$7f		and #$7F
.b109	8d 66 d0	sta $d066		sta $d066
.b10c	a3 6a		ldz #$6a		ldz 	#$6A 							; address already set up
.b10e	a9 00		lda #$00		lda 	#$00
.b110	ea		nop			nop
.b111	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b113	a3 6b		ldz #$6b		ldz 	#$6B 							; address already set up
.b115	a9 00		lda #$00		lda 	#$00
.b117	ea		nop			nop
.b118	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b11a	a3 78		ldz #$78		ldz 	#$78 							; address already set up
.b11c	a9 00		lda #$00		lda 	#$00
.b11e	ea		nop			nop
.b11f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b121	a3 5f		ldz #$5f		ldz 	#$5F 							; address already set up
.b123	a9 00		lda #$00		lda 	#$00
.b125	ea		nop			nop
.b126	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b128	a3 5a		ldz #$5a		ldz 	#$5A 							; address already set up
.b12a	a9 78		lda #$78		lda 	#$78
.b12c	ea		nop			nop
.b12d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b12f	a3 5d		ldz #$5d		ldz 	#$5D 							; address already set up
.b131	a9 c0		lda #$c0		lda 	#$C0
.b133	ea		nop			nop
.b134	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b136	a3 5c		ldz #$5c		ldz 	#$5C 							; address already set up
.b138	a9 50		lda #$50		lda 	#80
.b13a	ea		nop			nop
.b13b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b13d	a9 ff		lda #$ff		lda #$ff
.b13f	8d 01 dd	sta $dd01		sta $DD01
.b142	8d 00 dd	sta $dd00		sta $DD00
.b145	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b147	a9 14		lda #$14		lda 	#$14
.b149	ea		nop			nop
.b14a	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b14c	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b14e	a9 1b		lda #$1b		lda 	#$1B
.b150	ea		nop			nop
.b151	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b153	a3 16		ldz #$16		ldz 	#$16 							; address already set up
.b155	a9 c8		lda #$c8		lda 	#$C8
.b157	ea		nop			nop
.b158	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b15a	a3 c5		ldz #$c5		ldz 	#$C5 							; address already set up
.b15c	a9 54		lda #$54		lda 	#$54
.b15e	ea		nop			nop
.b15f	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b161	a3 58		ldz #$58		ldz 	#$58 							; address already set up
.b163	a9 50		lda #$50		lda 	#80
.b165	ea		nop			nop
.b166	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b168	a3 59		ldz #$59		ldz 	#$59 							; address already set up
.b16a	a9 00		lda #$00		lda 	#0
.b16c	ea		nop			nop
.b16d	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b16f	a3 18		ldz #$18		ldz 	#$18 							; address already set up
.b171	a9 42		lda #$42		lda 	#$42
.b173	ea		nop			nop
.b174	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b176	a3 11		ldz #$11		ldz 	#$11 							; address already set up
.b178	a9 1b		lda #$1b		lda 	#$1B
.b17a	ea		nop			nop
.b17b	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b17d	a9 00		lda #$00		lda 	#$00							; colour RAM at $1F800-1FFFF (2kb)
.b17f	85 07		sta $07			sta 	EXTZPWork+3
.b181	a9 01		lda #$01		lda 	#$01
.b183	85 06		sta $06			sta 	EXTZPWork+2
.b185	a9 f8		lda #$f8		lda 	#$F8
.b187	85 05		sta $05			sta 	EXTZPWork+1
.b189	a9 00		lda #$00		lda 	#$00
.b18b	85 04		sta $04			sta 	EXTZPWork+0
.b18d	a3 00		ldz #$00		ldz 	#0
.b18f					_EXTClearColorRam:
.b18f	a9 08		lda #$08		lda 	#8 								; fill that with this colour.
.b191	ea		nop			nop
.b192	92 04		sta ($04),z		sta 	(EXTZPWork),z
.b194	3b		dez			dez
.b195	d0 f8		bne $b18f		bne 	_EXTClearColorRam
.b197	e6 05		inc $05			inc 	EXTZPWork+1
.b199	d0 f4		bne $b18f		bne 	_EXTClearColorRam
.b19b	a2 00		ldx #$00		ldx 	#0 								; copy PET Font into memory.
.b19d					_EXTCopyCBMFont:
.b19d	bd 00 a0	lda $a000,x		lda 	EXTCBMFont,x
.b1a0	9d 00 08	sta $0800,x		sta 	EXTCharSet,x
.b1a3	bd 00 a1	lda $a100,x		lda 	EXTCBMFont+$100,x
.b1a6	9d 00 09	sta $0900,x		sta 	EXTCharSet+$100,x
.b1a9	bd 00 a2	lda $a200,x		lda 	EXTCBMFont+$200,x
.b1ac	9d 00 0a	sta $0a00,x		sta 	EXTCharSet+$200,x
.b1af	bd 00 a3	lda $a300,x		lda 	EXTCBMFont+$300,x
.b1b2	9d 00 0b	sta $0b00,x		sta 	EXTCharSet+$300,x
.b1b5	ca		dex			dex
.b1b6	d0 e5		bne $b19d		bne 	_EXTCopyCBMFont
.b1b8	7a		ply			ply 									; restore and exit.
.b1b9	fa		plx			plx
.b1ba	68		pla			pla
.b1bb	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	be e8					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	2d e1					.word	SyntaxError                   ; """        ($0081)
>e004	2d e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	b3 e8					.word	BFUNC_String                  ; "$"        ($0083)
>e008	53 ea					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	c5 e8					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	2d e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	2d e1					.word	SyntaxError                   ; "("        ($0087)
>e010	2d e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	34 e9					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	67 e8					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	8d e8					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	8b e9					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	2d e1					.word	SyntaxError                   ; ":"        ($008d)
>e01c	2d e1					.word	SyntaxError                   ; ";"        ($008e)
>e01e	d1 ea					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	72 ea					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	ac ea					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	6f ea					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	af ea					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	ce ea					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	b7 e8					.word	BFUNC_ByteInd                 ; "?"        ($0095)
>e02c	0f e9					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	89 ec					.word	COMMAND_Assert                ; "assert"   ($0097)
>e030	88 eb					.word	UNARY_Abs                     ; "abs"      ($0098)
>e032	d0 ec					.word	COMMAND_Clear                 ; "clear"    ($0099)
>e034	77 ef					.word	COMMAND_CLS                   ; "cls"      ($009a)
>e036	73 eb					.word	UNARY_Ch                      ; "ch"       ($009b)
>e038	fe ef					.word	COMMAND_Do                    ; "do"       ($009c)
>e03a	7e ec					.word	COMMAND_End                   ; "end"      ($009d)
>e03c	2d e1					.word	SyntaxError                   ; "for"      ($009e)
>e03e	2d e1					.word	SyntaxError                   ; "gosub"    ($009f)
>e040	2d e1					.word	SyntaxError                   ; "goto"     ($00a0)
>e042	2d e1					.word	SyntaxError                   ; "input"    ($00a1)
>e044	2d e1					.word	SyntaxError                   ; "if"       ($00a2)
>e046	7a ef					.word	COMMAND_List                  ; "list"     ($00a3)
>e048	2d e1					.word	SyntaxError                   ; "link"     ($00a4)
>e04a	42 ed					.word	COMMAND_Let                   ; "let"      ($00a5)
>e04c	31 eb					.word	UNARY_Len                     ; "len"      ($00a6)
>e04e	2d e1					.word	SyntaxError                   ; "next"     ($00a7)
>e050	b7 ec					.word	COMMAND_NewExec               ; "new"      ($00a8)
>e052	06 ed					.word	COMMAND_OldExec               ; "old"      ($00a9)
>e054	7d ee					.word	COMMAND_Print                 ; "print"    ($00aa)
>e056	a5 eb					.word	UNARY_Page                    ; "page"     ($00ab)
>e058	ad ec					.word	COMMAND_Rem                   ; "rem"      ($00ac)
>e05a	f5 eb					.word	COMMAND_Run                   ; "run"      ($00ad)
>e05c	b8 eb					.word	UNARY_Rnd                     ; "rnd"      ($00ae)
>e05e	76 ec					.word	COMMAND_Stop                  ; "stop"     ($00af)
>e060	2d e1					.word	SyntaxError                   ; "step"     ($00b0)
>e062	2d e1					.word	SyntaxError                   ; "then"     ($00b1)
>e064	90 eb					.word	UNARY_Top                     ; "top"      ($00b2)
>e066	2d e1					.word	SyntaxError                   ; "to"       ($00b3)
>e068	04 f0					.word	COMMAND_Until                 ; "until"    ($00b4)
>e06a	ea e8					.word	BFUNC_Or                      ; "|"        ($00b5)
>e06c	f0 ea					.word	BFUNC_StringCompare           ; "~"        ($00b6)
.e06e					TokenText:
>e06e	a1					.byte $a1                             ; $0080 !
>e06f	a2					.byte $a2                             ; $0081 "
>e070	a3					.byte $a3                             ; $0082 #
>e071	a4					.byte $a4                             ; $0083 $
>e072	a5					.byte $a5                             ; $0084 %
>e073	a6					.byte $a6                             ; $0085 &
>e074	a7					.byte $a7                             ; $0086 '
>e075	a8					.byte $a8                             ; $0087 (
>e076	a9					.byte $a9                             ; $0088 )
>e077	aa					.byte $aa                             ; $0089 *
>e078	ab					.byte $ab                             ; $008a +
>e079	ad					.byte $ad                             ; $008b -
>e07a	af					.byte $af                             ; $008c /
>e07b	ba					.byte $ba                             ; $008d :
>e07c	bb					.byte $bb                             ; $008e ;
>e07d	3c bd					.byte $3c,$bd                         ; $008f <=
>e07f	3c be					.byte $3c,$be                         ; $0090 <>
>e081	bc					.byte $bc                             ; $0091 <
>e082	bd					.byte $bd                             ; $0092 =
>e083	3e bd					.byte $3e,$bd                         ; $0093 >=
>e085	be					.byte $be                             ; $0094 >
>e086	bf					.byte $bf                             ; $0095 ?
>e087	de					.byte $de                             ; $0096 ^
>e088	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0097 assert
>e08e	41 42 d3				.byte $41,$42,$d3                     ; $0098 abs
>e091	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $0099 clear
>e096	43 4c d3				.byte $43,$4c,$d3                     ; $009a cls
>e099	43 c8					.byte $43,$c8                         ; $009b ch
>e09b	44 cf					.byte $44,$cf                         ; $009c do
>e09d	45 4e c4				.byte $45,$4e,$c4                     ; $009d end
>e0a0	46 4f d2				.byte $46,$4f,$d2                     ; $009e for
>e0a3	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $009f gosub
>e0a8	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $00a0 goto
>e0ac	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a1 input
>e0b1	49 c6					.byte $49,$c6                         ; $00a2 if
>e0b3	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a3 list
>e0b7	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00a4 link
>e0bb	4c 45 d4				.byte $4c,$45,$d4                     ; $00a5 let
>e0be	4c 45 ce				.byte $4c,$45,$ce                     ; $00a6 len
>e0c1	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00a7 next
>e0c5	4e 45 d7				.byte $4e,$45,$d7                     ; $00a8 new
>e0c8	4f 4c c4				.byte $4f,$4c,$c4                     ; $00a9 old
>e0cb	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00aa print
>e0d0	50 41 47 c5				.byte $50,$41,$47,$c5                 ; $00ab page
>e0d4	52 45 cd				.byte $52,$45,$cd                     ; $00ac rem
>e0d7	52 55 ce				.byte $52,$55,$ce                     ; $00ad run
>e0da	52 4e c4				.byte $52,$4e,$c4                     ; $00ae rnd
>e0dd	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00af stop
>e0e1	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00b0 step
>e0e5	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b1 then
>e0e9	54 4f d0				.byte $54,$4f,$d0                     ; $00b2 top
>e0ec	54 cf					.byte $54,$cf                         ; $00b3 to
>e0ee	55 4e 54 49 cc				.byte $55,$4e,$54,$49,$cc             ; $00b4 until
>e0f3	fc					.byte $fc                             ; $00b5 |
>e0f4	fe					.byte $fe                             ; $00b6 ~
>e0f5	00					.byte $00
.e0f6					TokenTypeInformation:
>e0f6	04					.byte $04                             ; $0080 !
>e0f7	0a					.byte $0a                             ; $0081 "
>e0f8	0a					.byte $0a                             ; $0082 #
>e0f9	04					.byte $04                             ; $0083 $
>e0fa	03					.byte $03                             ; $0084 %
>e0fb	00					.byte $00                             ; $0085 &
>e0fc	0a					.byte $0a                             ; $0086 '
>e0fd	0a					.byte $0a                             ; $0087 (
>e0fe	0a					.byte $0a                             ; $0088 )
>e0ff	03					.byte $03                             ; $0089 *
>e100	02					.byte $02                             ; $008a +
>e101	02					.byte $02                             ; $008b -
>e102	03					.byte $03                             ; $008c /
>e103	0a					.byte $0a                             ; $008d :
>e104	0a					.byte $0a                             ; $008e ;
>e105	01					.byte $01                             ; $008f <=
>e106	01					.byte $01                             ; $0090 <>
>e107	01					.byte $01                             ; $0091 <
>e108	01					.byte $01                             ; $0092 =
>e109	01					.byte $01                             ; $0093 >=
>e10a	01					.byte $01                             ; $0094 >
>e10b	04					.byte $04                             ; $0095 ?
>e10c	00					.byte $00                             ; $0096 ^
>e10d	04					.byte $04                             ; $0097 assert
>e10e	09					.byte $09                             ; $0098 abs
>e10f	04					.byte $04                             ; $0099 clear
>e110	04					.byte $04                             ; $009a cls
>e111	09					.byte $09                             ; $009b ch
>e112	04					.byte $04                             ; $009c do
>e113	04					.byte $04                             ; $009d end
>e114	04					.byte $04                             ; $009e for
>e115	04					.byte $04                             ; $009f gosub
>e116	04					.byte $04                             ; $00a0 goto
>e117	04					.byte $04                             ; $00a1 input
>e118	04					.byte $04                             ; $00a2 if
>e119	04					.byte $04                             ; $00a3 list
>e11a	04					.byte $04                             ; $00a4 link
>e11b	04					.byte $04                             ; $00a5 let
>e11c	09					.byte $09                             ; $00a6 len
>e11d	04					.byte $04                             ; $00a7 next
>e11e	04					.byte $04                             ; $00a8 new
>e11f	04					.byte $04                             ; $00a9 old
>e120	04					.byte $04                             ; $00aa print
>e121	09					.byte $09                             ; $00ab page
>e122	04					.byte $04                             ; $00ac rem
>e123	04					.byte $04                             ; $00ad run
>e124	09					.byte $09                             ; $00ae rnd
>e125	04					.byte $04                             ; $00af stop
>e126	04					.byte $04                             ; $00b0 step
>e127	04					.byte $04                             ; $00b1 then
>e128	09					.byte $09                             ; $00b2 top
>e129	04					.byte $04                             ; $00b3 to
>e12a	04					.byte $04                             ; $00b4 until
>e12b	00					.byte $00                             ; $00b5 |
>e12c	01					.byte $01                             ; $00b6 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CLS = $009a
=$009b					KW_CH = $009b
=$009c					KW_DO = $009c
=$009d					KW_END = $009d
=$009e					KW_FOR = $009e
=$009f					KW_GOSUB = $009f
=$00a0					KW_GOTO = $00a0
=$00a1					KW_INPUT = $00a1
=$00a2					KW_IF = $00a2
=$00a3					KW_LIST = $00a3
=$00a4					KW_LINK = $00a4
=$00a5					KW_LET = $00a5
=$00a6					KW_LEN = $00a6
=$00a7					KW_NEXT = $00a7
=$00a8					KW_NEW = $00a8
=$00a9					KW_OLD = $00a9
=$00aa					KW_PRINT = $00aa
=$00ab					KW_PAGE = $00ab
=$00ac					KW_REM = $00ac
=$00ad					KW_RUN = $00ad
=$00ae					KW_RND = $00ae
=$00af					KW_STOP = $00af
=$00b0					KW_STEP = $00b0
=$00b1					KW_THEN = $00b1
=$00b2					KW_TOP = $00b2
=$00b3					KW_TO = $00b3
=$00b4					KW_UNTIL = $00b4
=$00b5					KW_BAR = $00b5
=$00b6					KW_TILDE = $00b6

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e12d					SyntaxError:
.e12d	20 3d e1	jsr $e13d			jsr 	ReportError
>e130	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e138	52 52 4f 52 00
.e13d					ReportError:
.e13d	fa		plx				plx
.e13e	7a		ply				ply
.e13f	e8		inx				inx
.e140	d0 01		bne $e143			bne 	_REPrint
.e142	c8		iny				iny
.e143					_REPrint:
.e143	20 c3 e4	jsr $e4c3			jsr 	SIOPrintString
.e146	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e148	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e14a	f0 13		beq $e15f			beq 	_RENoLineNumber
.e14c	a2 67		ldx #$67			ldx 	#_REAt & $FF
.e14e	a0 e1		ldy #$e1			ldy 	#_REAt >> 8
.e150	20 c3 e4	jsr $e4c3			jsr 	SIOPrintString
.e153	a0 01		ldy #$01			ldy 	#1
.e155	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e157	aa		tax				tax
.e158	c8		iny				iny
.e159	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e15b	a8		tay				tay
.e15c	20 6c e1	jsr $e16c			jsr 	PrintWordInteger
.e15f					_RENoLineNumber:
.e15f	a9 0d		lda #$0d			lda 	#13
.e161	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.e164	4c b7 f0	jmp $f0b7			jmp 	WarmStart
>e167	20 41 54 20 00			_REAt:	.text 	" AT ",0
.e16c					PrintWordInteger:
.e16c	8a		txa				txa
.e16d	a2 00		ldx #$00			ldx 	#0
.e16f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e172	98		tya				tya
.e173	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e176	c8		iny				iny
.e177	a9 00		lda #$00			lda 	#0
.e179	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e17c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e17f	20 3f ef	jsr $ef3f			jsr 	CPRPrintInteger
.e182	60		rts				rts
.e183					CheckNextCharacter:
.e183	8d 98 20	sta $2098			sta 	Temp1 						; save character to check
.e186					_CNCLoop:
.e186	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e188	f0 0b		beq $e195			beq 	_CNCFail 					; end of line, so no character
.e18a	c8		iny				iny
.e18b	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e18d	f0 f7		beq $e186			beq 	_CNCLoop
.e18f	cd 98 20	cmp $2098			cmp 	Temp1 						; fail if not what was wanted
.e192	d0 01		bne $e195			bne 	_CNCFail
.e194	60		rts				rts
.e195					_CNCFail:
.e195	20 3d e1	jsr $e13d			jsr 	ReportError
>e198	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e1a0	54 4f 4b 45 4e 00
.e1a6					CopyBasicCode:
.e1a6	a2 00		ldx #$00			ldx 	#0
.e1a8					_CopyLoop:
.e1a8	bd 1d f1	lda $f11d,x			lda 	BasicCode,x
.e1ab	9d 00 23	sta $2300,x			sta 	BasicProgram,x
.e1ae	bd 1d f2	lda $f21d,x			lda 	BasicCode+$100,x
.e1b1	9d 00 24	sta $2400,x			sta 	BasicProgram+$100,x
.e1b4	e8		inx				inx
.e1b5	d0 f1		bne $e1a8			bne 	_CopyLoop
.e1b7	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e1b8							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0024					zTemp1:			.word 	?					; temporary vars
>0026					zTemp2:			.word 	?
>0028					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>2096					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>2098					Temp1:			.dword	?					; 4 byte temporary stores.
>209c					SignCount:		.byte 	? 					; count of signs in divide.
>209d					StringBufferPos:.byte 	? 					; next free slot in string buffer
>209e					RandomSeed 		.word 	? 					; Random Number
>20a0					xCursor 		.byte 	? 					; cursor position
>20a1					yCursor 		.byte 	?
>20a2					breakCheckCount	.byte 	?					; how often check for break.
>20a3					basicStackIndex	.byte 	? 					; index into Basic Stack.
>20a4									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e1b8					EvaluateSNError:
.e1b8	4c 2d e1	jmp $e12d			jmp 	SyntaxError
.e1bb					EvaluateMissingQuote:
.e1bb	20 3d e1	jsr $e13d			jsr 	ReportError
>e1be	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e1c6	51 55 4f 54 45 00
.e1cc					EvaluateStringFull:
.e1cc	20 3d e1	jsr $e13d			jsr 	ReportError
>e1cf	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e1d7	55 46 46 45 52 20 46 55 4c 4c 00
.e1e2					EvaluateBadHex:
.e1e2	20 3d e1	jsr $e13d			jsr 	ReportError
>e1e5	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e1ed					EvaluateAtomCurrentLevel:
.e1ed	a9 07		lda #$07			lda 	#7
.e1ef	80 04		bra $e1f5			bra 	EvaluateAtPrecedenceLevel
.e1f1					EvaluateBase:
.e1f1	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e1f3					EvaluateBaseCurrentLevel:
.e1f3	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e1f5					EvaluateAtPrecedenceLevel:
.e1f5	48		pha				pha 								; save precedence level
.e1f6	a9 00		lda #$00			lda 	#0 							; zero the result.
.e1f8	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1fb	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1fe	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e201	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e204					_EVALSkipSpace1:
.e204	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e206	f0 b0		beq $e1b8			beq 	EvaluateSNError 			; end of line, without token.
.e208	c8		iny				iny
.e209	c9 20		cmp #$20			cmp 	#32
.e20b	f0 f7		beq $e204			beq 	_EVALSkipSpace1
.e20d	88		dey				dey 								; points at the token.
.e20e	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e210	f0 14		beq $e226			beq 	_EVALString  				; if so load in a constant string
.e212	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e214	f0 36		beq $e24c			beq 	_EVALHexadecimal
.e216	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e218	90 04		bcc $e21e			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e21a	c9 3a		cmp #$3a			cmp 	#'9'+1
.e21c	90 03		bcc $e221			bcc 	_EVALDecimal
.e21e					_EVALGoKeywordVariable:
.e21e	4c a3 e2	jmp $e2a3			jmp 	_EVALKeywordVariable
.e221					_EVALDecimal:
.e221	20 00 e3	jsr $e300			jsr 	EVALGetDecConstant 			; get decimal constant
.e224	80 34		bra $e25a			bra 	_EVALGotAtom 				; got atom.
.e226					_EVALString:
.e226	da		phx				phx 								; save X on stack
.e227	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e229	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e22c	ad 9d 20	lda $209d			lda 	StringBufferPos 			; X = Buffer Position.
.e22f	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e232	aa		tax				tax 								; put in X to build the string.
.e233	c8		iny				iny 								; skip over opening quote character
.e234					_EVALStringCopy:
.e234	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e236	c8		iny				iny
.e237	f0 82		beq $e1bb			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e239	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e23c	e8		inx				inx 								; and bump that pointer.
.e23d	f0 8d		beq $e1cc			beq 	EvaluateStringFull 			; buffer is full.
.e23f	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e241	d0 f1		bne $e234			bne 	_EVALStringCopy
.e243	8e 9d 20	stx $209d			stx 	StringBufferPos 			; this is the new next free slot.
.e246	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e249	fa		plx				plx 								; restore X
.e24a	80 0e		bra $e25a			bra 	_EVALGotAtom 				; got the atom.
.e24c					_EVALHexaDecimal
.e24c	c8		iny				iny 								; skip over the '#'
.e24d	5a		phy				phy 								; save Y
.e24e	20 6c e3	jsr $e36c			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e251	8c 98 20	sty $2098			sty 	Temp1 						; has Y changed ?
.e254	68		pla				pla
.e255	cd 98 20	cmp $2098			cmp 	Temp1
.e258	f0 88		beq $e1e2			beq 	EvaluateBadHex 				; if not, error.
.e25a					_EVALGotAtom:
.e25a					_EVALGetOperator:
.e25a	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e25c	c8		iny				iny 								; this should be binary operator
.e25d	c9 20		cmp #$20			cmp 	#$20
.e25f	f0 f9		beq $e25a			beq 	_EVALGetOperator
.e261	88		dey				dey
.e262	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e264	10 3b		bpl $e2a1			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e266	da		phx				phx 								; save X
.e267	aa		tax				tax 								; token in X
.e268	bd 76 e0	lda $e076,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e26b	8d 98 20	sta $2098			sta 	Temp1 						; save precedence in Temp1
.e26e	fa		plx				plx 								; restore X
.e26f	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e271	b0 2e		bcs $e2a1			bcs 	_EVALExitPullA
.e273	68		pla				pla 								; get and save precedence level.
.e274	48		pha				pha
.e275	cd 98 20	cmp $2098			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e278	f0 02		beq $e27c			beq 	_EVALDoCalc					; equal, do it.
.e27a	b0 25		bcs $e2a1			bcs 	_EVALExitPullA				; too high, then exit.
.e27c					_EVALDoCalc:
.e27c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e27e	c8		iny				iny
.e27f	48		pha				pha
.e280	da		phx				phx
.e281	e8		inx				inx 								; work out right hand side.
.e282	e8		inx				inx
.e283	e8		inx				inx
.e284	e8		inx				inx
.e285	ad 98 20	lda $2098			lda 	Temp1 						; get current operator precedence level.
.e288	1a		inc a				inc 	a 							; so work it out at the next level.
.e289	20 f5 e1	jsr $e1f5			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e28c	fa		plx				plx 								; fix X back.
.e28d	68		pla				pla 								; get keyword
.e28e					_EVALExecuteA:
.e28e	0a		asl a				asl 	a 							; shift left, drop bit 7
.e28f	8d 99 20	sta $2099			sta 	Temp1+1						; save in Temp1.1
.e292	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e294	8d 9a 20	sta $209a			sta 	Temp1+2 					; set at Temp1.2
.e297	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e299	8d 98 20	sta $2098			sta 	Temp1+0
.e29c	20 98 20	jsr $2098			jsr 	Temp1 						; call that routine.
.e29f	80 b9		bra $e25a			bra 	_EVALGotAtom 				; and loop back again.
.e2a1					_EVALExitPullA:
.e2a1	68		pla				pla 								; restore precedence.
.e2a2	60		rts				rts
.e2a3					_EVALKeywordVariable:
.e2a3	09 00		ora #$00			ora 	#0 							; check bit 7
.e2a5	10 0f		bpl $e2b6			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e2a7	da		phx				phx
.e2a8	aa		tax				tax
.e2a9	bd 76 e0	lda $e076,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e2ac	fa		plx				plx
.e2ad	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e2af	d0 05		bne $e2b6			bne 	_EVALNotUnaryFunction
.e2b1	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e2b3	c8		iny				iny 								; consume it
.e2b4	80 d8		bra $e28e			bra 	_EVALExecuteA 				; execute TOS.
.e2b6					_EVALNotUnaryFunction:
.e2b6	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e2b8	10 3d		bpl $e2f7			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e2ba	c9 8b		cmp #$8b			cmp 	#KW_MINUS 					; check negation
.e2bc	f0 0f		beq $e2cd			beq 	_EVALUnaryNegation
.e2be	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e2c0	d0 14		bne $e2d6			bne		_EVALCheckUnaryOperator
.e2c2	c8		iny				iny 								; skip left bracket.
.e2c3	20 f3 e1	jsr $e1f3			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e2c6	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e2c8	20 83 e1	jsr $e183			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e2cb	80 8d		bra $e25a			bra 	_EVALGotAtom
.e2cd					_EVALUnaryNegation:
.e2cd	c8		iny				iny 								; skip over the - sign.
.e2ce	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e2d1	20 2e ea	jsr $ea2e			jsr 	BFUNC_NegateAlways 			; negate it.
.e2d4	80 84		bra $e25a			bra 	_EVALGotAtom
.e2d6					_EVALCheckUnaryOperator:
.e2d6	48		pha				pha 								; save indirection operator.
.e2d7	c8		iny				iny 								; skip over the operator
.e2d8	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e2db	68		pla				pla 								; restore the operator
.e2dc	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e2de	f0 0e		beq $e2ee			beq 	_EVALGoGotAtom
.e2e0	c9 95		cmp #$95			cmp 	#KW_QUESTION				; byte indirection
.e2e2	f0 07		beq $e2eb			beq 	_EVALByteRead
.e2e4	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e2e6	f0 09		beq $e2f1			beq 	_EVALWordRead
.e2e8	4c 2d e1	jmp $e12d			jmp 	SyntaxError 				; give up.
.e2eb					_EVALByteRead:
.e2eb	20 ab e3	jsr $e3ab			jsr 	EVALReadByteIndirect
.e2ee					_EVALGoGotAtom:
.e2ee	4c 5a e2	jmp $e25a			jmp 	_EVALGotAtom
.e2f1					_EVALWordRead:
.e2f1	20 e1 e3	jsr $e3e1			jsr 	EVALReadWordIndirect
.e2f4	4c 5a e2	jmp $e25a			jmp 	_EVALGotAtom
.e2f7					_EVALCheckVariable:
.e2f7	20 36 e4	jsr $e436			jsr 	VARReference 				; get variable reference to ZTemp1
.e2fa	20 f5 e3	jsr $e3f5			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e2fd	4c 5a e2	jmp $e25a			jmp 	_EVALGotAtom 				; and go round.
.e300					EVALGetDecConstant:
.e300	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e302	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e304	90 04		bcc $e30a			bcc 	_EVGDExit
.e306	c9 3a		cmp #$3a			cmp 	#'9'+1
.e308	90 01		bcc $e30b			bcc 	_EVGDValue 					; if so has legal value
.e30a					_EVGDExit:
.e30a	60		rts				rts
.e30b					_EVGDValue:
.e30b	48		pha				pha 								; save value, Y on stack
.e30c	5a		phy				phy
.e30d	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e30f	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e312	48		pha				pha
.e313	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e316	48		pha				pha
.e317	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e31a	48		pha				pha
.e31b	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e31e	48		pha				pha
.e31f					_EVGDLoop:
.e31f	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e322	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e325	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e328	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e32b	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e32d	d0 1d		bne $e34c			bne 	_EVGDNoAdd
.e32f	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e330	68		pla				pla
.e331	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e334	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e337	68		pla				pla
.e338	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e33b	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e33e	68		pla				pla
.e33f	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e342	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e345	68		pla				pla
.e346	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e349	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e34c					_EVGDNoAdd:
.e34c	88		dey				dey
.e34d	d0 d0		bne $e31f			bne 	_EVGDLoop
.e34f	7a		ply				ply 								; restore YA
.e350	68		pla				pla
.e351	c8		iny				iny 								; next character
.e352	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e354	18		clc				clc
.e355	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e358	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e35b	90 a3		bcc $e300			bcc 	EVALGetDecConstant 			; propogate constant through
.e35d	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e360	d0 9e		bne $e300			bne 	EVALGetDecConstant
.e362	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e365	d0 99		bne $e300			bne 	EVALGetDecConstant
.e367	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e36a	80 94		bra $e300			bra 	EVALGetDecConstant 			; go back and try again.
.e36c					EVALGetHexConstant:
.e36c	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e36e	20 a0 e3	jsr $e3a0			jsr 	EVALToUpper 				; make upper case
.e371	38		sec				sec
.e372	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e374	90 0a		bcc $e380			bcc 	_EVGHExit 					; exit if CC
.e376	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e378	90 07		bcc $e381			bcc 	_EVGHValue
.e37a	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e37c	c9 10		cmp #$10			cmp 	#15+1
.e37e	90 01		bcc $e381			bcc 	_EVGHValue
.e380					_EVGHExit:
.e380	60		rts				rts
.e381					_EVGHValue:
.e381	5a		phy				phy 								; save Y and new digit.
.e382	48		pha				pha
.e383	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e385					_EVGHRotate:
.e385	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e388	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e38b	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e38e	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e391	88		dey				dey
.e392	d0 f1		bne $e385			bne 	_EVGHRotate
.e394	68		pla				pla 								; restore digit and X
.e395	7a		ply				ply
.e396	c8		iny				iny 								; next character
.e397	18		clc				clc
.e398	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e39b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e39e	80 cc		bra $e36c			bra 	EVALGetHexConstant 			; go back and try again.
.e3a0					EVALToUpper:
.e3a0	c9 61		cmp #$61			cmp 	#'a'
.e3a2	90 06		bcc $e3aa			bcc 	_EVTUExit
.e3a4	c9 7b		cmp #$7b			cmp 	#'z'+1
.e3a6	b0 02		bcs $e3aa			bcs 	_EVTUExit
.e3a8	49 20		eor #$20			eor 	#32
.e3aa					_EVTUExit:
.e3aa	60		rts				rts
.e3ab					EVALReadByteIndirect:
.e3ab	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3ae	85 24		sta $24				sta 	zTemp1
.e3b0	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3b3	85 25		sta $25				sta 	zTemp1+1
.e3b5	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3b8	85 26		sta $26				sta 	zTemp1+2
.e3ba	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3bd	85 27		sta $27				sta 	zTemp1+3
.e3bf	a5 26		lda $26				lda 	zTemp1+2 					; address $0000xxxx
.e3c1	05 27		ora $27				ora 	zTemp1+3
.e3c3	f0 07		beq $e3cc			beq 	_ERBBase
.e3c5	a3 00		ldz #$00			ldz 	#0 							; read from far memory.
.e3c7	ea		nop				nop
.e3c8	b2 24		lda ($24),z			lda 	(zTemp1),z
.e3ca	80 06		bra $e3d2			bra 	_ERBExit
.e3cc					_ERBBase:
.e3cc	5a		phy				phy
.e3cd	a0 00		ldy #$00			ldy 	#0 							; read byte
.e3cf	b1 24		lda ($24),y			lda 	(zTemp1),y
.e3d1	7a		ply				ply
.e3d2					_ERBExit:
.e3d2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3d5	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e3d7	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3da	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3dd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3e0	60		rts				rts
.e3e1					EVALReadWordIndirect:
.e3e1	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3e4	85 24		sta $24				sta 	zTemp1
.e3e6	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3e9	85 25		sta $25				sta 	zTemp1+1
.e3eb	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3ee	85 26		sta $26				sta 	zTemp1+2
.e3f0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3f3	85 27		sta $27				sta 	zTemp1+3
.e3f5					EVALReadWordIndirectZTemp:
.e3f5	a5 26		lda $26				lda 	zTemp1+2 					; address $0000xxxx
.e3f7	05 27		ora $27				ora 	zTemp1+3
.e3f9	f0 1f		beq $e41a			beq 	_ERWBase
.e3fb	a3 00		ldz #$00			ldz 	#0 							; read from far memory.
.e3fd	ea		nop				nop
.e3fe	b2 24		lda ($24),z			lda 	(zTemp1),z
.e400	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e403	1b		inz				inz
.e404	ea		nop				nop
.e405	b2 24		lda ($24),z			lda 	(zTemp1),z
.e407	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e40a	1b		inz				inz
.e40b	ea		nop				nop
.e40c	b2 24		lda ($24),z			lda 	(zTemp1),z
.e40e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e411	1b		inz				inz
.e412	ea		nop				nop
.e413	b2 24		lda ($24),z			lda 	(zTemp1),z
.e415	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e418	80 1b		bra $e435			bra 	_ERWExit
.e41a					_ERWBase
.e41a	5a		phy				phy
.e41b	a0 00		ldy #$00			ldy 	#0 							; read word
.e41d	b1 24		lda ($24),y			lda 	(zTemp1),y
.e41f	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e422	c8		iny				iny
.e423	b1 24		lda ($24),y			lda 	(zTemp1),y
.e425	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e428	c8		iny				iny
.e429	b1 24		lda ($24),y			lda 	(zTemp1),y
.e42b	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e42e	c8		iny				iny
.e42f	b1 24		lda ($24),y			lda 	(zTemp1),y
.e431	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e434	7a		ply				ply
.e435					_ERWExit:
.e435	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e436					VARReference:
.e436	38		sec				sec 								; check range @-Z there
.e437	c9 40		cmp #$40			cmp 	#'@'
.e439	90 04		bcc $e43f			bcc 	_VARRError
.e43b	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e43d	90 03		bcc $e442			bcc 	_VARROkay
.e43f					_VARRError:
.e43f	4c 2d e1	jmp $e12d			jmp		SyntaxError
.e442					_VARROkay:
.e442	c8		iny				iny 								; consume the variable.
.e443	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e445	f0 1b		beq $e462			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e447	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e449	88		dey				dey 								; point back to the first character
.e44a	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e44c	f0 14		beq $e462			beq 	_VARArrayAccess
.e44e	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e450	c8		iny				iny
.e451	29 1f		and #$1f			and		#31 						; mask out
.e453	0a		asl a				asl 	a 							; x 4
.e454	0a		asl a				asl 	a
.e455	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e457	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e459	85 25		sta $25				sta 	zTemp1+1
.e45b	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e45d	85 26		sta $26				sta 	zTemp1+2
.e45f	85 27		sta $27				sta 	zTemp1+3 					; return with address set.
.e461	60		rts				rts
.e462					_VARArrayAccess:
.e462	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e464	c8		iny				iny
.e465	29 1f		and #$1f			and 	#31 						; mask it off
.e467	48		pha				pha 								; save on the stack.
.e468	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e46b	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e46e	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e471	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e474	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e477	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e47a	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e47d	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e480	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e483	68		pla				pla 								; put address in zTemp1
.e484	0a		asl a				asl 	a 							; x 4
.e485	0a		asl a				asl 	a
.e486	85 24		sta $24				sta 	zTemp1+0 					; rely on variables being page aligned.
.e488	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e48a	85 25		sta $25				sta 	zTemp1+1
.e48c	5a		phy				phy
.e48d	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e48f	b1 24		lda ($24),y			lda 	(zTemp1),y
.e491	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e494	48		pha				pha 								; save first result as we need the indirection.
.e495	c8		iny				iny 								; 2nd byte
.e496	b1 24		lda ($24),y			lda 	(zTemp1),y
.e498	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e49b	85 25		sta $25				sta 	zTemp1+1
.e49d	68		pla				pla 								; save the low byte.
.e49e	85 24		sta $24				sta 	zTemp1+0
.e4a0	a9 00		lda #$00			lda 	#0
.e4a2	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e4a5	85 26		sta $26				sta 	zTemp1+2
.e4a7	a9 00		lda #$00			lda 	#0
.e4a9	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e4ac	85 27		sta $27				sta 	zTemp1+3
.e4ae	7a		ply				ply 								; restore Y, address setup
.e4af	60		rts				rts
.e4b0	80 fe		bra $e4b0	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e4b2					SIOInitialise:
.e4b2	20 b8 b0	jsr $b0b8			jsr 	EXTReset 					; reset video
.e4b5					SIOClearScreen:
.e4b5	20 68 b0	jsr $b068			jsr 	EXTClearScreen 				; clear screen
.e4b8					SIOHomeCursor:
.e4b8	48		pha				pha 								; home cursor
.e4b9	a9 00		lda #$00			lda 	#0
.e4bb	8d a0 20	sta $20a0			sta 	xCursor
.e4be	8d a1 20	sta $20a1			sta 	yCursor
.e4c1	68		pla				pla
.e4c2	60		rts				rts
.e4c3					SIOPrintString:
.e4c3	48		pha				pha 								; save registers
.e4c4	da		phx				phx
.e4c5	5a		phy				phy
.e4c6	86 26		stx $26				stx 	zTemp2 						; set up indirect pointer
.e4c8	84 27		sty $27				sty 	zTemp2+1
.e4ca	a0 00		ldy #$00			ldy 	#0
.e4cc					_SIOPSLoop:
.e4cc	b1 26		lda ($26),y			lda 	(zTemp2),y 					; read next, exit if 0
.e4ce	f0 1c		beq $e4ec			beq 	_SIOPSExit
.e4d0	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter 			; print and bump
.e4d3	c8		iny				iny
.e4d4	d0 f6		bne $e4cc			bne 	_SIOPSLoop
.e4d6	20 3d e1	jsr $e13d			jsr 	ReportError
>e4d9	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e4e1	4e 47 20 50 52 49 4e 54 45 44 00
.e4ec					_SIOPSExit:
.e4ec	7a		ply				ply 								; restore and exit.
.e4ed	fa		plx				plx
.e4ee	68		pla				pla
.e4ef	60		rts				rts
.e4f0					SIOPrintCharacter:
.e4f0	48		pha				pha 								; save AXY
.e4f1	da		phx				phx
.e4f2	5a		phy				phy
.e4f3	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e4f5	f0 12		beq $e509			beq 	_SIOPReturn
.e4f7	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor 				; load cursor position in.
.e4fa	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e4fc	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen 				; write character out.
.e4ff	ee a0 20	inc $20a0			inc 	xCursor 					; move right
.e502	ad a0 20	lda $20a0			lda 	xCursor 					; reached the RHS
.e505	c9 28		cmp #$28			cmp 	#EXTWidth
.e507	90 15		bcc $e51e			bcc 	_SIOPExit
.e509					_SIOPReturn:
.e509	a9 00		lda #$00			lda 	#0 							; zero x
.e50b	8d a0 20	sta $20a0			sta 	xCursor
.e50e	ee a1 20	inc $20a1			inc 	yCursor 					; go down
.e511	ad a1 20	lda $20a1			lda 	yCursor
.e514	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e516	90 06		bcc $e51e			bcc 	_SIOPExit
.e518	20 86 b0	jsr $b086			jsr 	EXTScrollDisplay 			; scroll display up
.e51b	ce a1 20	dec $20a1			dec 	yCursor 					; cursor on bottom line.
.e51e					_SIOPExit:
.e51e	7a		ply				ply 								; restore and exit.
.e51f	fa		plx				plx
.e520	68		pla				pla
.e521	60		rts				rts
.e522					SIOGetKey:
.e522	20 0c b0	jsr $b00c			jsr 	EXTReadKeyPort 				; wait for a key
.e525	f0 fb		beq $e522			beq 	SIOGetKey
.e527	20 a0 e3	jsr $e3a0			jsr 	EVALToUpper 				; capitalise it.
.e52a	4c 17 b0	jmp $b017			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e52d					SIOReadLine:
.e52d	48		pha				pha 								; save registers
.e52e	da		phx				phx
.e52f	5a		phy				phy
.e530					_SIORLoop:
.e530	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor 				; cursor in XY
.e533	20 4d b0	jsr $b04d			jsr 	EXTReadScreen 				; read the display.
.e536	48		pha				pha 								; save on stack.
.e537	a9 66		lda #$66			lda 	#102 						; write cursor out
.e539	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e53c	20 22 e5	jsr $e522			jsr 	SIOGetKey
.e53f	aa		tax				tax 								; save in X
.e540	68		pla				pla 								; old character
.e541	da		phx				phx 								; save key pressed
.e542	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor 				; cursor in XY
.e545	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e548	68		pla				pla
.e549	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e54b	f0 29		beq $e576			beq 	_SIOCursorLeft
.e54d	c9 13		cmp #$13			cmp 	#"S"-64
.e54f	f0 49		beq $e59a			beq 	_SIOCursorDown
.e551	c9 04		cmp #$04			cmp 	#"D"-64
.e553	f0 2d		beq $e582			beq 	_SIOCursorRight
.e555	c9 17		cmp #$17			cmp 	#"W"-64
.e557	f0 35		beq $e58e			beq 	_SIOCursorUp
.e559	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e55b	f0 49		beq $e5a6			beq 	_SIOClearScreen
.e55d	c9 08		cmp #$08			cmp 	#"H"-64
.e55f	f0 4a		beq $e5ab			beq 	_SIOBackspace
.e561	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e563	f0 0e		beq $e573			beq 	_SIOGoReturn
.e565	c9 20		cmp #$20			cmp 	#32 						; any control
.e567	90 c7		bcc $e530			bcc 	_SIORLoop
.e569	48		pha				pha
.e56a	20 e9 e5	jsr $e5e9			jsr 	_SIOInsert 					; insert a space for new character
.e56d	68		pla				pla
.e56e	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter 			; print character in A
.e571	80 bd		bra $e530			bra 	_SIORLoop
.e573					_SIOGoReturn:
.e573	4c 14 e6	jmp $e614			jmp 	_SIOReturn
.e576					_SIOCursorLeft:
.e576	ce a0 20	dec $20a0			dec 	xCursor
.e579	10 b5		bpl $e530			bpl 	_SIORLoop
.e57b	a9 27		lda #$27			lda 	#EXTWidth-1
.e57d					_SIOWXLoop:
.e57d	8d a0 20	sta $20a0			sta 	xCursor
.e580	80 ae		bra $e530			bra 	_SIORLoop
.e582					_SIOCursorRight:
.e582	ee a0 20	inc $20a0			inc 	xCursor
.e585	ad a0 20	lda $20a0			lda 	xCursor
.e588	49 28		eor #$28			eor 	#EXTWidth
.e58a	d0 a4		bne $e530			bne 	_SIORLoop
.e58c	80 ef		bra $e57d			bra 	_SIOWXLoop
.e58e					_SIOCursorUp:
.e58e	ce a1 20	dec $20a1			dec 	yCursor
.e591	10 9d		bpl $e530			bpl 	_SIORLoop
.e593	a9 18		lda #$18			lda 	#EXTHeight-1
.e595					_SIOWYLoop:
.e595	8d a1 20	sta $20a1			sta 	yCursor
.e598	80 96		bra $e530			bra 	_SIORLoop
.e59a					_SIOCursorDown:
.e59a	ee a1 20	inc $20a1			inc 	yCursor
.e59d	ad a1 20	lda $20a1			lda 	yCursor
.e5a0	49 19		eor #$19			eor 	#EXTHeight
.e5a2	d0 8c		bne $e530			bne 	_SIORLoop
.e5a4	80 ef		bra $e595			bra 	_SIOWYLoop
.e5a6					_SIOClearScreen:
.e5a6	20 b5 e4	jsr $e4b5			jsr 	SIOClearScreen
.e5a9	80 85		bra $e530			bra 	_SIORLoop
.e5ab					_SIOBackspace:
.e5ab	ad a0 20	lda $20a0			lda 	xCursor 					; backspace possible ?
.e5ae	f0 80		beq $e530			beq 	_SIORLoop 					; start of line, no.
.e5b0	48		pha				pha 								; save position.
.e5b1	c9 27		cmp #$27			cmp 	#EXTWidth-1 				; not required
.e5b3	f0 1f		beq $e5d4			beq 	_SIONoShift
.e5b5	ce a0 20	dec $20a0			dec 	xCursor
.e5b8					_SIOShift2:
.e5b8	ee a0 20	inc $20a0			inc 	xCursor 					; copy character backward
.e5bb	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e5be	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e5c1	ce a0 20	dec $20a0			dec 	xCursor
.e5c4	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e5c7	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e5ca	ee a0 20	inc $20a0			inc 	xCursor
.e5cd	ad a0 20	lda $20a0			lda 	xCursor
.e5d0	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e5d2	d0 e4		bne $e5b8			bne 	_SIOShift2
.e5d4					_SIONoShift:
.e5d4	a9 27		lda #$27			lda 	#EXTWidth-1 				; space on far end.
.e5d6	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e5d9	a9 20		lda #$20			lda 	#32
.e5db	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e5de	68		pla				pla 								; restore cursor, back one.
.e5df	3a		dec a				dec 	a
.e5e0	8d a0 20	sta $20a0			sta 	xCursor
.e5e3	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor 				; overwrite
.e5e6	4c 30 e5	jmp $e530			jmp	 	_SIORLoop
.e5e9					_SIOInsert:
.e5e9	ad a0 20	lda $20a0			lda 	xCursor 					; at far right, nothing to do.
.e5ec	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e5ee	f0 23		beq $e613			beq 	_SIOIExit
.e5f0	85 26		sta $26				sta 	zTemp2 						; save in temporary workspace.
.e5f2	a9 27		lda #$27			lda 	#EXTWidth-1 				; cursor at far right.
.e5f4	8d a0 20	sta $20a0			sta 	xCursor
.e5f7					_SIOShift:
.e5f7	ce a0 20	dec $20a0			dec 	xCursor 					; copy character forward
.e5fa	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e5fd	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e600	ee a0 20	inc $20a0			inc 	xCursor
.e603	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e606	20 5c b0	jsr $b05c			jsr 	EXTWriteScreen
.e609	ce a0 20	dec $20a0			dec 	xCursor
.e60c	ad a0 20	lda $20a0			lda 	xCursor						; until shifted line to this point.
.e60f	c5 26		cmp $26				cmp 	zTemp2
.e611	d0 e4		bne $e5f7			bne 	_SIOShift
.e613					_SIOIExit:
.e613	60		rts				rts
.e614					_SIOReturn:
.e614	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e616	8d a0 20	sta $20a0			sta 	xCursor
.e619					_SIOCopy:
.e619	20 4e e6	jsr $e64e			jsr 	SIOLoadCursor
.e61c	20 4d b0	jsr $b04d			jsr 	EXTReadScreen
.e61f	49 20		eor #$20			eor 	#$20
.e621	18		clc				clc
.e622	69 20		adc #$20			adc 	#$20
.e624	ae a0 20	ldx $20a0			ldx 	xCursor
.e627	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e62a	ee a0 20	inc $20a0			inc 	xCursor
.e62d	ad a0 20	lda $20a0			lda 	xCursor
.e630	c9 28		cmp #$28			cmp 	#EXTWidth
.e632	d0 e5		bne $e619			bne 	_SIOCopy
.e634	aa		tax				tax 								; X contains width
.e635					_SIOStrip:
.e635	ca		dex				dex									; back one
.e636	30 07		bmi $e63f			bmi		_SIOFound 					; if -ve gone too far
.e638	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e63b	c9 20		cmp #$20			cmp 	#' '
.e63d	f0 f6		beq $e635			beq 	_SIOStrip
.e63f					_SIOFound:
.e63f	e8		inx				inx
.e640	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e642	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e645	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e647	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.e64a	7a		ply				ply
.e64b	fa		plx				plx
.e64c	68		pla				pla
.e64d	60		rts				rts
.e64e					SIOLoadCursor:
.e64e	48		pha				pha
.e64f	ad a1 20	lda $20a1			lda 	yCursor  					; Y Position
.e652	0a		asl a				asl 	a 							; x 2 	(80)
.e653	0a		asl a				asl 	a 							; x 2 	(160)
.e654	6d a1 20	adc $20a1			adc 	yCursor 					; x 5 	(200) (CC)
.e657	85 24		sta $24				sta 	zTemp1
.e659	a9 00		lda #$00			lda 	#0
.e65b	85 25		sta $25				sta 	zTemp1+1
.e65d	06 24		asl $24				asl 	zTemp1						; x 10
.e65f	26 25		rol $25				rol 	zTemp1+1
.e661	06 24		asl $24				asl 	zTemp1						; x 20
.e663	26 25		rol $25				rol 	zTemp1+1
.e665	06 24		asl $24				asl 	zTemp1						; x 40
.e667	26 25		rol $25				rol 	zTemp1+1 					; (CC)
.e669	a5 24		lda $24				lda 	zTemp1 						; add X
.e66b	6d a0 20	adc $20a0			adc 	xCursor
.e66e	aa		tax				tax
.e66f	a5 25		lda $25				lda 	zTemp1+1
.e671	69 00		adc #$00			adc 	#0
.e673	a8		tay				tay
.e674	68		pla				pla 								; restore and exit
.e675	60		rts				rts
.e676					SIOPrintHex:
.e676	48		pha				pha
.e677	48		pha				pha
.e678	a9 20		lda #$20			lda 	#32
.e67a	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.e67d	68		pla				pla
.e67e	48		pha				pha
.e67f	4a		lsr a				lsr 	a
.e680	4a		lsr a				lsr 	a
.e681	4a		lsr a				lsr 	a
.e682	4a		lsr a				lsr 	a
.e683	20 8c e6	jsr $e68c			jsr 	_SIOPHex
.e686	68		pla				pla
.e687	20 8c e6	jsr $e68c			jsr 	_SIOPHex
.e68a	68		pla				pla
.e68b	60		rts				rts
.e68c					_SIOPHex:
.e68c	29 0f		and #$0f			and 	#15
.e68e	c9 0a		cmp #$0a			cmp 	#10
.e690	90 02		bcc $e694			bcc 	_SIOPHex2
.e692	69 06		adc #$06			adc 	#6
.e694					_SIOPHex2:
.e694	69 30		adc #$30			adc 	#48
.e696	4c f0 e4	jmp $e4f0			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e699					TokeniseString:
.e699	a0 00		ldy #$00			ldy 	#0							; source
.e69b	a2 00		ldx #$00			ldx 	#0 							; target
.e69d					_TokLoop:
.e69d	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get first
.e69f	f0 5d		beq $e6fe			beq 	_TokExit 					; End, exit.
.e6a1	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e6a3	f0 35		beq $e6da			beq 	_TokCopy1
.e6a5	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e6a7	f0 3a		beq $e6e3			beq 	_TokCopyString
.e6a9	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e6ab	90 22		bcc $e6cf			bcc 	_TokPunctuation
.e6ad	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e6af	90 29		bcc $e6da			bcc 	_TokCopy1
.e6b1	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e6b3	90 1a		bcc $e6cf			bcc 	_TokPunctuation
.e6b5	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e6b7	b0 16		bcs $e6cf			bcs 	_TokPunctuation
.e6b9					_TokWord:
.e6b9	20 04 e7	jsr $e704			jsr 	TokeniseSearch 				; search for tokenised word.
.e6bc	b0 16		bcs $e6d4			bcs 	_TokFound 					; if successful, copy it out.
.e6be					_TokSkip:
.e6be	b1 24		lda ($24),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e6c0	c9 41		cmp #$41			cmp 	#"A"
.e6c2	90 d9		bcc $e69d			bcc 	_TokLoop
.e6c4	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e6c6	b0 d5		bcs $e69d			bcs 	_TokLoop
.e6c8	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6cb	e8		inx				inx
.e6cc	c8		iny				iny
.e6cd	80 ef		bra $e6be			bra 	_TokSkip
.e6cf					_TokPunctuation:
.e6cf	20 04 e7	jsr $e704			jsr 	TokeniseSearch 				; find it.
.e6d2	90 06		bcc $e6da			bcc 	_TokCopy1 					; if found, just copy 1 character
.e6d4					_TokFound:
.e6d4	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e6d7	e8		inx				inx 								; advance target ; source is already advanced.
.e6d8	80 c3		bra $e69d			bra 	_TokLoop 					; do the next character.
.e6da					_TokCopy1:
.e6da	b1 24		lda ($24),y			lda 	(zTemp1),y
.e6dc	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6df	e8		inx				inx
.e6e0	c8		iny				iny
.e6e1	80 ba		bra $e69d			bra 	_TokLoop
.e6e3					_TokCopyString:
.e6e3	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e6e5	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6e8	e8		inx				inx 								; skip buffer and first quote.
.e6e9	c8		iny				iny
.e6ea					_TokCSLoop:
.e6ea	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get next character
.e6ec	f0 10		beq $e6fe			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e6ee	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e6f1	e8		inx				inx 								; advance both.
.e6f2	c8		iny				iny
.e6f3	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e6f5	d0 f3		bne $e6ea			bne 	_TokCSLoop
.e6f7	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e6f9	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e6fc	80 9f		bra $e69d			bra 	_TokLoop
.e6fe					_TokExit:
.e6fe	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e700	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e703	60		rts				rts
.e704					TokeniseSearch:
.e704	48		pha				pha 								; save AXY
.e705	da		phx				phx
.e706	5a		phy				phy
.e707	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e709	85 26		sta $26				sta 	zTemp2
.e70b	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e70d	bd 6e e0	lda $e06e,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e710	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e712	d1 24		cmp ($24),y			cmp 	(zTemp1),y 					; do the characters match.
.e714	f0 13		beq $e729			beq 	_TSTryFullMatch 			; if so, try the full match.
.e716					_TSGotoNext:
.e716	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; read it
.e719	e8		inx				inx 								; bump index
.e71a	0a		asl a				asl 	a 							; shift into C
.e71b	90 f9		bcc $e716			bcc 	_TSGotoNext 				; keep going until read the end character
.e71d	e6 26		inc $26				inc 	zTemp2 						; bump the current token pointer.
.e71f	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; look at the first character of the next token
.e722	d0 e9		bne $e70d			bne 	_TSNext 					; if non-zero, go to the next.
.e724					_TSFail:
.e724	7a		ply				ply 								; fail.
.e725	fa		plx				plx
.e726	68		pla				pla
.e727	18		clc				clc 				 				; return with carry clear.
.e728	60		rts				rts
.e729					_TSTryFullMatch:
.e729	da		phx				phx									; save X and Y.
.e72a	5a		phy				phy
.e72b					_TSFullMatch:
.e72b	bd 6e e0	lda $e06e,x			lda 	TokenText,x 				; compare the 7 bits.
.e72e	29 7f		and #$7f			and 	#$7F
.e730	d1 24		cmp ($24),y			cmp 	(zTemp1),y
.e732	d0 15		bne $e749			bne 	_TSFullFail 				; different, this one doesn't match.
.e734	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.e737	e8		inx				inx 								; advance to next character
.e738	c8		iny				iny
.e739	0a		asl a				asl 	a 							; bit 7 of token text in C
.e73a	90 ef		bcc $e72b			bcc 	_TSFullMatch
.e73c	84 27		sty $27				sty 	zTemp2+1 					; save the Y after last
.e73e	68		pla				pla 								; so we don't restore Y
.e73f	68		pla				pla 								; or X from the full test.
.e740	7a		ply				ply 								; restore original Y and X and A
.e741	fa		plx				plx
.e742	68		pla				pla
.e743	a5 26		lda $26				lda 	zTemp2 						; and return token ID in A
.e745	a4 27		ldy $27				ldy 	zTemp2+1 					; Y after the tokenised text.
.e747	38		sec				sec 								; with carry set.
.e748	60		rts				rts
.e749					_TSFullFail:
.e749	7a		ply				ply 								; restore Y and X
.e74a	fa		plx				plx
.e74b	80 c9		bra $e716			bra 	_TSGotoNext 				; and go to the next token to test.
.e74d					TokeniseTest:
.e74d	a9 59		lda #$59			lda 	#TTString & $FF
.e74f	85 24		sta $24				sta 	zTemp1
.e751	a9 e7		lda #$e7			lda 	#TTString >> 8
.e753	85 25		sta $25				sta 	zTemp1+1
.e755	20 99 e6	jsr $e699			jsr 	TokeniseString
.e758	ea		nop				nop
.e759					TTString:
>e759	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e761	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: general/editor.asm

.e76e					EditProgram:
.e76e	a2 00		ldx #$00			ldx 	#0
.e770	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; get the line number
.e773	bd 02 04	lda $0402,x			lda 	evalStack+2,x 				; upper bytes must be zero
.e776	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.e779	d0 37		bne $e7b2			bne 	_EPBadLine
.e77b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; lower bytes must be non-zero
.e77e	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.e781	f0 2f		beq $e7b2			beq 	_EPBadLine
.e783	5a		phy				phy 								; save position
.e784	20 be e7	jsr $e7be			jsr 	EDFindLine 					; locate the line.
.e787	90 12		bcc $e79b			bcc 	_EPNotFound 				; skip delete if not found.
.e789	a5 24		lda $24				lda 	zTemp1 						; save the target address, as we will
.e78b	48		pha				pha 								; insert the line, if done, at the same
.e78c	a5 25		lda $25				lda 	zTemp1+1 					; place
.e78e	48		pha				pha
.e78f	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; clear all vars, make sure zLowMemory is right.
.e792	20 f5 e7	jsr $e7f5			jsr 	EDDeleteLine 				; delete the line at zTemp1
.e795	68		pla				pla 								; restore the target address.
.e796	85 25		sta $25				sta 	zTemp1+1
.e798	68		pla				pla
.e799	85 24		sta $24				sta 	zTemp1
.e79b					_EPNotFound
.e79b	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e79e	7a		ply				ply 								; get pointer back
.e79f					_EPSkipSpaces:
.e79f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get character
.e7a1	f0 0c		beq $e7af			beq 	_EPGoWarmStart 				; EOL, just delete, so warm start.
.e7a3	c8		iny				iny
.e7a4	c9 20		cmp #$20			cmp 	#32
.e7a6	f0 f7		beq $e79f			beq 	_EPSkipSpaces
.e7a8	88		dey				dey
.e7a9	20 15 e8	jsr $e815			jsr 	EDInsertLine 				; insert the line.
.e7ac	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; set up all the pointers again and reset everything.
.e7af					_EPGoWarmStart:
.e7af	4c b7 f0	jmp $f0b7			jmp 	WarmStart
.e7b2					_EPBadLine:
.e7b2	20 3d e1	jsr $e13d			jsr 	ReportError
>e7b5	42 41 44 20 4c 49 4e 45				.text 	"BAD LINE",$00
>e7bd	00
.e7be					EDFindLine:
.e7be	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set zTemp1
.e7c0	85 24		sta $24				sta 	zTemp1
.e7c2	a9 23		lda #$23			lda 	#BasicProgram >> 8
.e7c4	85 25		sta $25				sta 	zTemp1+1
.e7c6					_EDFLLoop:
.e7c6	a0 00		ldy #$00			ldy 	#0 							; reached the end
.e7c8	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7ca	f0 25		beq $e7f1			beq 	_EDFLFail 					; then obviously that's the end ;-) (great comment !)
.e7cc	c8		iny				iny
.e7cd	38		sec				sec
.e7ce	ad 00 04	lda $0400			lda 	evalStack+0					; subtract the current from the target
.e7d1	f1 24		sbc ($24),y			sbc 	(zTemp1),y 					; so if searching for 100 and this one is 90,
.e7d3	aa		tax				tax	 								; this will return 10.
.e7d4	ad 01 04	lda $0401			lda 	evalStack+1
.e7d7	c8		iny				iny
.e7d8	f1 24		sbc ($24),y			sbc 	(zTemp1),y
.e7da	90 15		bcc $e7f1			bcc 	_EDFLFail					; if target < current then failed.
.e7dc	d0 04		bne $e7e2			bne 	_EDFLNext 					; if non-zero then goto next
.e7de	e0 00		cpx #$00			cpx 	#0 							; same for the LSB - zero if match found.
.e7e0	f0 11		beq $e7f3			beq 	_EDFLFound
.e7e2					_EDFLNext:
.e7e2	a0 00		ldy #$00			ldy 	#0 							; get offset
.e7e4	18		clc				clc
.e7e5	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7e7	65 24		adc $24				adc 	zTemp1 						; add to pointer
.e7e9	85 24		sta $24				sta 	zTemp1
.e7eb	90 d9		bcc $e7c6			bcc 	_EDFLLoop
.e7ed	e6 25		inc $25				inc 	zTemp1+1 					; carry out.
.e7ef	80 d5		bra $e7c6			bra 	_EDFLLoop
.e7f1					_EDFLFail:
.e7f1	18		clc				clc
.e7f2	60		rts				rts
.e7f3					_EDFLFound:
.e7f3	38		sec				sec
.e7f4	60		rts				rts
.e7f5					EDDeleteLine:
.e7f5	a0 00		ldy #$00			ldy 	#0 							; this is the offset to copy down.
.e7f7	a2 00		ldx #$00			ldx 	#0
.e7f9	b1 24		lda ($24),y			lda 	(zTemp1),y
.e7fb	a8		tay				tay 								; put in Y
.e7fc					_EDDelLoop:
.e7fc	b1 24		lda ($24),y			lda 	(zTemp1),y 					; get it
.e7fe	81 24		sta ($24,x)			sta 	(zTemp1,x) 					; write it.
.e800	a5 24		lda $24				lda 	zTemp1 						; check if pointer has reached the end of
.e802	c5 22		cmp $22				cmp		zLowMemory 					; low memory. We will have copied down an
.e804	d0 06		bne $e80c			bne 	_EDDelNext 					; extra pile of stuff - technically should
.e806	a5 25		lda $25				lda 	zTemp1+1 					; check the upper value (e.g. zTemp1+y)
.e808	c5 23		cmp $23				cmp 	zLowMemory+1				; doesn't really matter.
.e80a	f0 08		beq $e814			beq		_EDDelExit
.e80c					_EDDelNext:
.e80c	e6 24		inc $24				inc 	zTemp1 						; go to next byte.
.e80e	d0 ec		bne $e7fc			bne 	_EDDelLoop
.e810	e6 25		inc $25				inc 	zTemp1+1
.e812	80 e8		bra $e7fc			bra 	_EDDelLoop
.e814					_EDDelExit:
.e814	60		rts				rts
.e815					EDInsertLine:
.e815	98		tya				tya 								; make zCurrentLine point to the actual new line.
.e816	18		clc				clc
.e817	65 20		adc $20				adc 	zCurrentLine
.e819	85 20		sta $20				sta 	zCurrentLine
.e81b	a0 00		ldy #$00			ldy 	#0 							; work out the line length.
.e81d					_EDGetLength:
.e81d	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e81f	c8		iny				iny
.e820	c9 00		cmp #$00			cmp 	#0
.e822	d0 f9		bne $e81d			bne 	_EDGetLength
.e824	88		dey				dey 								; fix up.
.e825	98		tya				tya
.e826	18		clc				clc
.e827	69 04		adc #$04			adc 	#1+2+1 						; size required. 1 for offset, 2 for line#, 1 for end.
.e829	48		pha				pha 								; save total size (e.g. offset)
.e82a	a8		tay				tay 								; in Y
.e82b	a2 00		ldx #$00			ldx 	#0
.e82d					_EDInsLoop:
.e82d	a1 22		lda ($22,x)			lda 	(zLowMemory,x)				; copy it up
.e82f	91 22		sta ($22),y			sta 	(zLowMemory),y
.e831	a5 22		lda $22				lda 	zLowMemory 					; reached the insert point (zTemp1)
.e833	c5 24		cmp $24				cmp 	zTemp1
.e835	d0 06		bne $e83d			bne 	_EDINextShift
.e837	a5 23		lda $23				lda 	zLowMemory+1
.e839	c5 25		cmp $25				cmp 	zTemp1+1
.e83b	f0 0a		beq $e847			beq 	_EDIShiftOver
.e83d					_EDINextShift:
.e83d	a5 22		lda $22				lda 	zLowMemory 					; decrement the copy pointer.
.e83f	d0 02		bne $e843			bne 	_EDINoBorrow
.e841	c6 23		dec $23				dec 	zLowMemory+1
.e843					_EDINoBorrow:
.e843	c6 22		dec $22				dec 	zLowMemory
.e845	80 e6		bra $e82d			bra 	_EDInsLoop
.e847					_EDIShiftOver:
.e847	68		pla				pla 								; this is the size + others, e.g. offset
.e848	a0 00		ldy #$00			ldy 	#0
.e84a	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write that out.
.e84c	ad 00 04	lda $0400			lda 	evalStack+0 				; write LIne# out
.e84f	c8		iny				iny
.e850	91 22		sta ($22),y			sta 	(zLowMemory),y
.e852	ad 01 04	lda $0401			lda 	evalStack+1
.e855	c8		iny				iny
.e856	91 22		sta ($22),y			sta 	(zLowMemory),y
.e858	c8		iny				iny 								; where the code goes.
.e859	a2 00		ldx #$00			ldx 	#0 							; comes from
.e85b					_EDICopyCode:
.e85b	a1 20		lda ($20,x)			lda 	(zCurrentLine,x)			; read from the current line
.e85d	91 22		sta ($22),y			sta 	(zLowMemory),y 				; write out
.e85f	c8		iny				iny 								; bump pointers
.e860	e6 20		inc $20				inc 	zCurrentLine
.e862	c9 00		cmp #$00			cmp 	#0 							; until zero copied
.e864	d0 f5		bne $e85b			bne 	_EDICopyCode
.e866	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e867					BFUNC_Add:
.e867	18		clc				clc
.e868	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e86b	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e86e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e871	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e874	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e877	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e87a	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e87d	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e880	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e883	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e886	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e889	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e88c	60		rts				rts
.e88d					BFUNC_Subtract:
.e88d	38		sec				sec
.e88e	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e891	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e894	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e897	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e89a	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e89d	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8a0	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8a3	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e8a6	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8a9	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8ac	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e8af	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8b2	60		rts				rts
.e8b3					BFUNC_String:
.e8b3	20 67 e8	jsr $e867			jsr 	BFUNC_Add
.e8b6	60		rts				rts
.e8b7					BFUNC_ByteInd:
.e8b7	20 67 e8	jsr $e867			jsr 	BFUNC_Add
.e8ba	20 ab e3	jsr $e3ab			jsr 	EVALReadByteIndirect
.e8bd	60		rts				rts
.e8be					BFUNC_WordInd:
.e8be	20 67 e8	jsr $e867			jsr 	BFUNC_Add
.e8c1	20 e1 e3	jsr $e3e1			jsr 	EVALReadWordIndirect
.e8c4	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e8c5					BFUNC_And:
.e8c5	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8c8	3d 04 04	and $0404,x			and 	evalStack+4,x
.e8cb	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8ce	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8d1	3d 05 04	and $0405,x			and 	evalStack+5,x
.e8d4	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8d7	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8da	3d 06 04	and $0406,x			and 	evalStack+6,x
.e8dd	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8e0	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8e3	3d 07 04	and $0407,x			and 	evalStack+7,x
.e8e6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8e9	60		rts				rts
.e8ea					BFUNC_Or:
.e8ea	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e8ed	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e8f0	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8f3	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e8f6	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e8f9	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8fc	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e8ff	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e902	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e905	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e908	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e90b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e90e	60		rts				rts
.e90f					BFUNC_Xor:
.e90f	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e912	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e915	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e918	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e91b	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e91e	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e921	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e924	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e927	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e92a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e92d	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e930	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e933	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e934					BFUNC_Multiply:
.e934	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e937	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e93a	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e93d	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e940	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e943	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e946	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e949	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e94c	a9 00		lda #$00			lda 	#0
.e94e	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e951	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e954	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e957	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e95a					_BFMMultiply:
.e95a	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e95d	29 01		and #$01			and 	#1
.e95f	f0 03		beq $e964			beq 	_BFMNoAdd
.e961	20 67 e8	jsr $e867			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e964					_BFMNoAdd:
.e964	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e967	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e96a	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e96d	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e970	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e973	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e976	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e979	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e97c	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e97f	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e982	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e985	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e988	d0 d0		bne $e95a			bne 	_BFMMultiply
.e98a	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e98b					BFUNC_Divide:
.e98b	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e98e	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e991	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e994	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e997	d0 14		bne $e9ad			bne 	_BFDOkay
.e999	20 3d e1	jsr $e13d			jsr 	ReportError
>e99c	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>e9a4	20 42 59 20 5a 45 52 4f 00
.e9ad					_BFDOkay:
.e9ad	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e9af	8d 98 20	sta $2098			sta 	Temp1 						; Q/Dividend/Left in +0
.e9b2	8d 99 20	sta $2099			sta 	Temp1+1 					; M/Divisor/Right in +4
.e9b5	8d 9a 20	sta $209a			sta 	Temp1+2
.e9b8	8d 9b 20	sta $209b			sta 	Temp1+3
.e9bb	8d 9c 20	sta $209c			sta 	SignCount 					; Count of signs.
.e9be	20 29 ea	jsr $ea29			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e9c1	da		phx				phx
.e9c2	e8		inx				inx
.e9c3	e8		inx				inx
.e9c4	e8		inx				inx
.e9c5	e8		inx				inx
.e9c6	20 29 ea	jsr $ea29			jsr 	BFUNC_Negate
.e9c9	fa		plx				plx
.e9ca	5a		phy				phy 								; Y is the counter
.e9cb	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e9cd					_BFDLoop:
.e9cd	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e9d0	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e9d3	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e9d6	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e9d9	2e 98 20	rol $2098			rol 	Temp1
.e9dc	2e 99 20	rol $2099			rol 	Temp1+1
.e9df	2e 9a 20	rol $209a			rol 	Temp1+2
.e9e2	2e 9b 20	rol $209b			rol 	Temp1+3
.e9e5	38		sec				sec
.e9e6	ad 98 20	lda $2098			lda 	Temp1+0 					; Calculate A-M on stack.
.e9e9	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e9ec	48		pha				pha
.e9ed	ad 99 20	lda $2099			lda 	Temp1+1
.e9f0	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e9f3	48		pha				pha
.e9f4	ad 9a 20	lda $209a			lda 	Temp1+2
.e9f7	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e9fa	48		pha				pha
.e9fb	ad 9b 20	lda $209b			lda 	Temp1+3
.e9fe	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.ea01	90 19		bcc $ea1c			bcc 	_BFDNoAdd
.ea03	8d 9b 20	sta $209b			sta 	Temp1+3 					; update A
.ea06	68		pla				pla
.ea07	8d 9a 20	sta $209a			sta 	Temp1+2
.ea0a	68		pla				pla
.ea0b	8d 99 20	sta $2099			sta 	Temp1+1
.ea0e	68		pla				pla
.ea0f	8d 98 20	sta $2098			sta 	Temp1+0
.ea12	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.ea15	09 01		ora #$01			ora 	#1
.ea17	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea1a	80 03		bra $ea1f			bra 	_BFDNext
.ea1c					_BFDNoAdd:
.ea1c	68		pla				pla 								; Throw away the intermediate calculations
.ea1d	68		pla				pla
.ea1e	68		pla				pla
.ea1f					_BFDNext:
.ea1f	88		dey				dey
.ea20	d0 ab		bne $e9cd			bne 	_BFDLoop
.ea22	7a		ply				ply 								; restore Y and exit
.ea23	4e 9c 20	lsr $209c			lsr 	SignCount 					; if sign count odd,
.ea26	b0 06		bcs $ea2e			bcs		BFUNC_NegateAlways 			; negate the result
.ea28	60		rts				rts
.ea29					BFUNC_Negate:
.ea29	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ea2c	10 24		bpl $ea52			bpl 	BFNExit
.ea2e					BFUNC_NegateAlways:
.ea2e	38		sec				sec
.ea2f	a9 00		lda #$00			lda 	#0
.ea31	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.ea34	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea37	a9 00		lda #$00			lda 	#0
.ea39	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.ea3c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea3f	a9 00		lda #$00			lda 	#0
.ea41	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.ea44	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea47	a9 00		lda #$00			lda 	#0
.ea49	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.ea4c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea4f	ee 9c 20	inc $209c			inc 	SignCount
.ea52					BFNExit:
.ea52	60		rts				rts
.ea53					BFUNC_Modulus:
.ea53	20 8b e9	jsr $e98b			jsr 	BFUNC_Divide 				; start with division.
.ea56	ad 98 20	lda $2098			lda 	Temp1+0 					; copy remainder
.ea59	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea5c	ad 99 20	lda $2099			lda 	Temp1+1
.ea5f	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea62	ad 9a 20	lda $209a			lda 	Temp1+2
.ea65	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea68	ad 9b 20	lda $209b			lda 	Temp1+3
.ea6b	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea6e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.ea6f					BFUNC_Equals:
.ea6f	18		clc				clc
.ea70	80 01		bra $ea73			bra 	BFUNC_EqualCheck
.ea72					BFUNC_NotEquals:
.ea72	38		sec				sec
.ea73					BFUNC_EqualCheck:
.ea73	08		php				php									; save invert flag
.ea74	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.ea77	cd 04 04	cmp $0404			cmp 	evalStack+4
.ea7a	d0 1c		bne $ea98			bne 	COMP_Fail
.ea7c	ad 01 04	lda $0401			lda 	evalStack+1
.ea7f	cd 05 04	cmp $0405			cmp 	evalStack+5
.ea82	d0 14		bne $ea98			bne 	COMP_Fail
.ea84	ad 02 04	lda $0402			lda 	evalStack+2
.ea87	cd 06 04	cmp $0406			cmp 	evalStack+6
.ea8a	d0 0c		bne $ea98			bne 	COMP_Fail
.ea8c	ad 03 04	lda $0403			lda 	evalStack+3
.ea8f	cd 07 04	cmp $0407			cmp 	evalStack+7
.ea92	d0 04		bne $ea98			bne 	COMP_Fail
.ea94					COMP_Succeed:
.ea94	a9 ff		lda #$ff			lda 	#$FF
.ea96	80 02		bra $ea9a			bra 	COMP_SetResult
.ea98					COMP_Fail:
.ea98	a9 00		lda #$00			lda 	#0 							; here return 0
.ea9a					COMP_SetResult:
.ea9a	28		plp				plp 								; but if CS
.ea9b	90 02		bcc $ea9f			bcc 	COMP_Accept
.ea9d	49 ff		eor #$ff			eor 	#$FF 						; invert that
.ea9f					COMP_Accept:
.ea9f	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.eaa2	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eaa5	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eaa8	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eaab	60		rts				rts
.eaac					BFUNC_Less:
.eaac	18		clc				clc
.eaad	80 01		bra $eab0			bra 	BFUNC_LessCheck
.eaaf					BFUNC_GreaterEqual:
.eaaf	38		sec				sec
.eab0					BFUNC_LessCheck:
.eab0	08		php				php
.eab1	38		sec				sec
.eab2	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.eab5	ed 04 04	sbc $0404			sbc 	evalStack+4
.eab8	ad 01 04	lda $0401			lda 	evalStack+1
.eabb	ed 05 04	sbc $0405			sbc 	evalStack+5
.eabe	ad 02 04	lda $0402			lda 	evalStack+2
.eac1	ed 06 04	sbc $0406			sbc 	evalStack+6
.eac4	ad 03 04	lda $0403			lda 	evalStack+3
.eac7	ed 07 04	sbc $0407			sbc 	evalStack+7
.eaca	30 c8		bmi $ea94			bmi 	COMP_Succeed
.eacc	80 ca		bra $ea98			bra 	COMP_Fail
.eace					BFUNC_Greater:
.eace	18		clc				clc
.eacf	80 01		bra $ead2			bra 	BFUNC_GreaterCheck
.ead1					BFUNC_LessEqual:
.ead1	38		sec				sec
.ead2					BFUNC_GreaterCheck:
.ead2	08		php				php
.ead3	38		sec				sec
.ead4	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.ead7	ed 00 04	sbc $0400			sbc 	evalStack+0
.eada	ad 05 04	lda $0405			lda 	evalStack+5
.eadd	ed 01 04	sbc $0401			sbc 	evalStack+1
.eae0	ad 06 04	lda $0406			lda 	evalStack+6
.eae3	ed 02 04	sbc $0402			sbc 	evalStack+2
.eae6	ad 07 04	lda $0407			lda 	evalStack+7
.eae9	ed 03 04	sbc $0403			sbc 	evalStack+3
.eaec	30 a6		bmi $ea94			bmi 	COMP_Succeed
.eaee	80 a8		bra $ea98			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.eaf0					BFUNC_StringCompare:
.eaf0	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.eaf3	85 24		sta $24				sta 	zTemp1
.eaf5	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eaf8	85 25		sta $25				sta 	zTemp1+1
.eafa	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.eafd	85 26		sta $26				sta 	zTemp2
.eaff	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.eb02	85 27		sta $27				sta 	zTemp2+1
.eb04	5a		phy				phy
.eb05	a0 00		ldy #$00			ldy 	#0
.eb07					_BFSCLoop:
.eb07	b1 24		lda ($24),y			lda 	(zTemp1),y 					; comparison
.eb09	38		sec				sec
.eb0a	d1 26		cmp ($26),y			cmp 	(zTemp2),y
.eb0c	d0 15		bne $eb23			bne		_BFSCDifferent 				; return different result.
.eb0e	c8		iny				iny
.eb0f	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.eb11	d0 f4		bne $eb07			bne 	_BFSCLoop
.eb13	7a		ply				ply
.eb14	a9 00		lda #$00			lda 	#0
.eb16					_BFSCSetAll:
.eb16	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb19	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb1c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb1f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb22	60		rts				rts
.eb23					_BFSCDifferent:
.eb23	7a		ply				ply
.eb24	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.eb26	90 ee		bcc $eb16			bcc 	_BFSCSetAll
.eb28	a9 00		lda #$00			lda 	#0 							; set all zero
.eb2a	20 16 eb	jsr $eb16			jsr 	_BFSCSetAll
.eb2d	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.eb30	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.eb31					UNARY_Len:
.eb31	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb34	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb37	85 24		sta $24				sta 	zTemp1
.eb39	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb3c	85 25		sta $25				sta 	zTemp1+1
.eb3e	5a		phy				phy
.eb3f	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.eb41					_ULGetLength:
.eb41	b1 24		lda ($24),y			lda 	(zTemp1),y 					; read character
.eb43	f0 1d		beq $eb62			beq 	_ULFoundEOL 				; found end of line.
.eb45	c8		iny				iny
.eb46	d0 f9		bne $eb41			bne 	_ULGetLength 				; scan 256 only.
.eb48	20 3d e1	jsr $e13d			jsr 	ReportError
>eb4b	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>eb53	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.eb62					_ULFoundEOL:
.eb62	98		tya				tya 								; length in A, restore Y
.eb63	7a		ply				ply
.eb64					UNARY_ReturnByte:
.eb64	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb67	a9 00		lda #$00			lda 	#0 							; clear the rests
.eb69	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb6c	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eb6f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eb72	60		rts				rts
.eb73					UNARY_Ch:
.eb73	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb76	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.eb79	85 24		sta $24				sta 	zTemp1
.eb7b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.eb7e	85 25		sta $25				sta 	zTemp1+1
.eb80	5a		phy				phy
.eb81	a0 00		ldy #$00			ldy 	#0 							; now get first character
.eb83	b1 24		lda ($24),y			lda 	(zTemp1),y
.eb85	7a		ply				ply
.eb86	80 dc		bra $eb64			bra 	UNARY_ReturnByte 			; return that byte.
.eb88					UNARY_Abs:
.eb88	ea		nop				nop
.eb89	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.eb8c	20 29 ea	jsr $ea29			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.eb8f	60		rts				rts
.eb90					UNARY_Top:
.eb90	ad 96 20	lda $2096			lda 	highMemory
.eb93	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.eb96	ad 97 20	lda $2097			lda 	highMemory+1
.eb99	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.eb9c	a9 00		lda #$00			lda 	#0
.eb9e	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.eba1	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.eba4	60		rts				rts
.eba5					UNARY_Page:
.eba5	a9 00		lda #$00			lda 	#BasicProgram & $FF
.eba7	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebaa	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ebac	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebaf	a9 00		lda #$00			lda 	#0
.ebb1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ebb4	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ebb7	60		rts				rts
.ebb8					UNARY_Rnd:
.ebb8	20 c3 eb	jsr $ebc3			jsr 	Random16 					; call 16 bit RNG twice
.ebbb	e8		inx				inx
.ebbc	e8		inx				inx
.ebbd	20 c3 eb	jsr $ebc3			jsr 	Random16
.ebc0	ca		dex				dex
.ebc1	ca		dex				dex
.ebc2	60		rts				rts
.ebc3					Random16:
.ebc3	ad 9e 20	lda $209e			lda 	RandomSeed 					; initialise if nonzero
.ebc6	0d 9f 20	ora $209f			ora 	RandomSeed+1
.ebc9	d0 0d		bne $ebd8			bne 	_R16_NoInit
.ebcb	ee 9e 20	inc $209e			inc 	RandomSeed 					; by setting low to 1
.ebce	5a		phy				phy
.ebcf	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.ebd1					_R16_Setup:
.ebd1	20 c3 eb	jsr $ebc3			jsr 	Random16
.ebd4	88		dey				dey
.ebd5	d0 fa		bne $ebd1			bne 	_R16_Setup
.ebd7	7a		ply				ply
.ebd8					_R16_NoInit:
.ebd8	4e 9f 20	lsr $209f			lsr 	RandomSeed+1				; shift seed right
.ebdb	6e 9e 20	ror $209e			ror 	RandomSeed
.ebde	90 08		bcc $ebe8			bcc 	_R16_NoXor
.ebe0	ad 9f 20	lda $209f			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.ebe3	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ebe5	8d 9f 20	sta $209f			sta 	RandomSeed+1
.ebe8					_R16_NoXor:
.ebe8	ad 9e 20	lda $209e			lda 	RandomSeed					; copy result to evaluate stack.
.ebeb	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ebee	ad 9f 20	lda $209f			lda 	RandomSeed+1
.ebf1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ebf4	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.ebf5					COMMAND_Run:
.ebf5	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; clear everything for a new run.
.ebf8	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.ebfa	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.ebfc	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.ebfe	84 21		sty $21				sty 	zCurrentLine+1
.ec00					CRUNNewLine:
.ec00	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.ec02	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ec04	f0 78		beq $ec7e			beq 	COMMAND_End 				; if zero, off end of program so stop.
.ec06	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.ec08					CRUNNextInstruction:
.ec08	ee a2 20	inc $20a2			inc 	breakCheckCount 			; don't check every time, might be slow.
.ec0b	ad a2 20	lda $20a2			lda 	breakCheckCount
.ec0e	29 1f		and #$1f			and 	#$1F 						; checking once in 32.
.ec10	f0 0e		beq $ec20			beq 	_CRUNNoCheck
.ec12	20 37 b0	jsr $b037			jsr 	EXTCheckBreak
.ec15	f0 09		beq $ec20			beq 	_CRUNNoCheck
.ec17	20 3d e1	jsr $e13d			jsr 	ReportError
>ec1a	42 52 45 41 4b 00				.text 	"BREAK",$00
.ec20					_CRUNNoCheck:
.ec20	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.ec22	8d 9d 20	sta $209d			sta 	StringBufferPos
.ec25	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.ec27	f0 0b		beq $ec34			beq 	CRUNNextLine 				; if zero, then end of line.
.ec29					CRUNNotEndOfLine:
.ec29	c9 20		cmp #$20			cmp 	#' '
.ec2b	f0 04		beq $ec31			beq 	CRUNSkipLoop
.ec2d	c9 8d		cmp #$8d			cmp 	#KW_Colon 					; check for a colon first.
.ec2f	d0 1b		bne $ec4c			bne 	CRUNExecuteOne 				; if not that, execute the token.
.ec31					CRUNSkipLoop:
.ec31	c8		iny				iny		 							; if colon, skip it and loop round.
.ec32	80 d4		bra $ec08			bra 	CRUNNextInstruction
.ec34					CRUNNextLine:
.ec34	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.ec36	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.ec38	f0 0f		beq $ec49			beq		CRUNWarmStart
.ec3a	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.ec3c	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ec3e	18		clc				clc
.ec3f	65 20		adc $20				adc 	zCurrentLine
.ec41	85 20		sta $20				sta 	zCurrentLine
.ec43	90 bb		bcc $ec00			bcc 	CRUNNewLine
.ec45	e6 21		inc $21				inc 	zCurrentLine+1
.ec47	80 b7		bra $ec00			bra 	CRUNNewLine
.ec49					CRUNWarmStart:
.ec49	4c b7 f0	jmp $f0b7			jmp 	WarmStart
.ec4c					CRUNExecuteOne:
.ec4c	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.ec4e	10 21		bpl $ec71			bpl		_CRUNX1TryLet
.ec50	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.ec52	f0 1d		beq $ec71			beq 	_CRUNX1TryLet
.ec54	c9 80		cmp #$80			cmp 	#KW_PLING
.ec56	f0 19		beq $ec71			beq 	_CRUNX1TryLet
.ec58	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ec5a	f0 15		beq $ec71			beq 	_CRUNX1TryLet
.ec5c	c8		iny				iny 								; skip over loaded token
.ec5d	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.ec5e	8d 99 20	sta $2099			sta 	Temp1+1 					; this is the low byte into the KVT
.ec61	8a		txa				txa
.ec62	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.ec64	8d 9a 20	sta $209a			sta 	Temp1+2
.ec67	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.ec69	8d 98 20	sta $2098			sta 	Temp1+0
.ec6c	20 98 20	jsr $2098			jsr 	Temp1 						; call instruction
.ec6f	80 97		bra $ec08			bra 	CRUNNextInstruction 		; do next instruction.
.ec71					_CRUNX1TryLet:
.ec71	20 42 ed	jsr $ed42			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.ec74	80 92		bra $ec08			bra 	CRUNNextInstruction
.ec76					COMMAND_Stop:
.ec76	20 3d e1	jsr $e13d			jsr 	ReportError
>ec79	53 54 4f 50 00					.text 	"STOP",$00
.ec7e					COMMAND_End:
.ec7e	ad 2e f1	lda $f12e			lda 	StartBehaviour 				; running program
.ec81	c9 52		cmp #$52			cmp 	#"R"
.ec83	d0 01		bne $ec86			bne 	_CEWarmStart
>ec85	02						.byte 	2
.ec86					_CEWarmStart:
.ec86	4c b7 f0	jmp $f0b7			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.ec89					COMMAND_Assert:
.ec89	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase 				; evaluate the expression
.ec8c	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.ec8f	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ec92	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ec95	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ec98	d0 12		bne $ecac			bne 	_CMDAExit
.ec9a	ea		nop				nop
.ec9b	20 3d e1	jsr $e13d			jsr 	ReportError
>ec9e	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>eca6	41 49 4c 45 44 00
.ecac					_CMDAExit:
.ecac	60		rts				rts
.ecad					COMMAND_Rem:
.ecad	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.ecaf	f0 05		beq $ecb6			beq 	_CREMExit 					; End of line, then exit.
.ecb1	c8		iny				iny 								; something to skip
.ecb2	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; if not a colon
.ecb4	d0 f7		bne $ecad			bne 	COMMAND_Rem 				; keep searching
.ecb6					_CREMExit:
.ecb6	60		rts				rts
.ecb7					COMMAND_NewExec:
.ecb7	20 bd ec	jsr $ecbd			jsr 	COMMAND_NewCode
.ecba	4c b7 f0	jmp $f0b7			jmp 	WarmStart
.ecbd					COMMAND_NewCode:
.ecbd	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.ecbf	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.ecc2	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.ecc5	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.ecc7	8d 96 20	sta $2096			sta 	HighMemory
.ecca	a9 80		lda #$80			lda 	#endMemory >> 8
.eccc	8d 97 20	sta $2097			sta 	HighMemory+1
.eccf	60		rts				rts
.ecd0					COMMAND_Clear:
.ecd0	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.ecd2					_CCClearVar:
.ecd2	a9 00		lda #$00			lda 	#$00
.ecd4	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.ecd7	e8		inx				inx
.ecd8	e0 6c		cpx #$6c			cpx 	#27*4
.ecda	10 f6		bpl $ecd2			bpl 	_CCClearVar
.ecdc	a9 00		lda #$00			lda 	#0 							; reset BASIC stack index
.ecde	8d a3 20	sta $20a3			sta 	basicStackIndex
.ece1	a9 ff		lda #$ff			lda 	#$FF 						; put invalid token on TOS, so when pulled.
.ece3	8d 00 02	sta $0200			sta 	basicStack 					; causes an error.
.ece6	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.ece8	85 22		sta $22				sta 	zLowMemory
.ecea	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ecec	85 23		sta $23				sta 	zLowMemory+1
.ecee					_CCFindEnd:
.ecee	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.ecf0	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.ecf2	f0 0b		beq $ecff			beq 	_CCFoundEnd
.ecf4	18		clc				clc 								; go to next line.
.ecf5	65 22		adc $22				adc 	zLowMemory
.ecf7	85 22		sta $22				sta 	zLowMemory
.ecf9	90 f3		bcc $ecee			bcc 	_CCFindEnd
.ecfb	e6 23		inc $23				inc 	zLowMemory+1
.ecfd	80 ef		bra $ecee			bra 	_CCFindEnd
.ecff					_CCFoundEnd:
.ecff	e6 22		inc $22				inc 	zLowMemory 					; variables etc. start after end of program.
.ed01	d0 02		bne $ed05			bne 	_CCNoCarry 					; skip over zero end offset.
.ed03	e6 23		inc $23				inc 	zLowMemory+1
.ed05					_CCNoCarry:
.ed05	60		rts				rts
.ed06					COMMAND_OldExec:
.ed06	20 0c ed	jsr $ed0c			jsr 	COMMAND_OldCode
.ed09	4c b7 f0	jmp $f0b7			jmp 	WarmStart
.ed0c					COMMAND_OldCode:
.ed0c	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.ed0e	85 22		sta $22				sta 	zLowMemory
.ed10	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ed12	85 23		sta $23				sta 	zLowMemory+1
.ed14	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.ed16					_COScan:
.ed16	b1 22		lda ($22),y			lda 	(zLowMemory),y 				; look at next byte pair
.ed18	c8		iny				iny
.ed19	f0 0d		beq $ed28			beq 	_COFail 					; can't find marker, corrupted maybe ?
.ed1b	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.ed1d	d0 f7		bne $ed16			bne 	_COScan
.ed1f	98		tya				tya 								; Y is the new offset to the next instruction
.ed20	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.ed22	91 22		sta ($22),y			sta 	(zLowMemory),y
.ed24	20 d0 ec	jsr $ecd0			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.ed27	60		rts				rts
.ed28					_COFail:
.ed28	20 3d e1	jsr $e13d			jsr 	ReportError
>ed2b	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>ed33	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ed42					COMMAND_Let:
.ed42	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ed44	f0 58		beq $ed9e			beq 	_CLESyntax
.ed46	c8		iny				iny
.ed47	c9 20		cmp #$20			cmp 	#32
.ed49	f0 f7		beq $ed42			beq 	COMMAND_Let
.ed4b	88		dey				dey
.ed4c	c9 95		cmp #$95			cmp 	#KW_QUESTION				; check for first being indirect.
.ed4e	f0 51		beq $eda1			beq 	_CLEIndirect 				; e.g. !x = 42
.ed50	c9 80		cmp #$80			cmp 	#KW_PLING
.ed52	f0 4d		beq $eda1			beq 	_CLEIndirect
.ed54	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed56	f0 49		beq $eda1			beq 	_CLEIndirect
.ed58	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ed5a	20 36 e4	jsr $e436			jsr 	VARReference 				; get a variable reference.
.ed5d	a5 24		lda $24				lda 	zTemp1 						; copy into target addr
.ed5f	85 28		sta $28				sta 	zTargetAddr
.ed61	a5 25		lda $25				lda 	zTemp1+1
.ed63	85 29		sta $29				sta 	zTargetAddr+1
.ed65	a5 26		lda $26				lda 	zTemp1+2
.ed67	85 2a		sta $2a				sta 	zTargetAddr+2
.ed69	a5 27		lda $27				lda 	zTemp1+3
.ed6b	85 2b		sta $2b				sta 	zTargetAddr+3
.ed6d					_CLEGetBinLHSOp:
.ed6d	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ed6f	f0 2d		beq $ed9e			beq 	_CLESyntax
.ed71	c8		iny				iny
.ed72	c9 20		cmp #$20			cmp 	#' '
.ed74	f0 f7		beq $ed6d			beq 	_CLEGetBinLHSOp
.ed76	88		dey				dey
.ed77	c9 95		cmp #$95			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ed79	f0 45		beq $edc0			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ed7b	c9 80		cmp #$80			cmp 	#KW_PLING
.ed7d	f0 41		beq $edc0			beq 	_CLEBinaryLHTerm
.ed7f	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed81	f0 3d		beq $edc0			beq 	_CLEBinaryLHTerm
.ed83	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ed85					_CLEWriteToAddress:
.ed85	48		pha				pha 								; save write-type.
.ed86	a9 92		lda #$92			lda 	#KW_EQUAL 					; check for '=' sign.
.ed88	20 83 e1	jsr $e183			jsr 	CheckNextCharacter
.ed8b	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase 				; evaluate the RHS.
.ed8e	68		pla				pla
.ed8f	c9 80		cmp #$80			cmp 	#KW_PLING
.ed91	f0 7d		beq $ee10			beq 	_CLEWordWrite
.ed93	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ed95	f0 60		beq $edf7			beq 	_CLEByteWrite
.ed97	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ed99					_ErrorInternal:
.ed99	d0 fe		bne $ed99			bne 	_ErrorInternal
.ed9b	4c 50 ee	jmp $ee50			jmp 	_CLEStringWrite
.ed9e					_CLESyntax:
.ed9e	4c 2d e1	jmp $e12d			jmp 	SyntaxError
.eda1					_CLEIndirect:
.eda1	48		pha				pha 								; save operator on stack
.eda2	c8		iny				iny									; advance over cursor
.eda3	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.eda5	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel
.eda8	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.edab	85 28		sta $28				sta 	zTargetAddr+0
.edad	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.edb0	85 29		sta $29				sta 	zTargetAddr+1
.edb2	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.edb5	85 2a		sta $2a				sta 	zTargetAddr+2
.edb7	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.edba	85 2b		sta $2b				sta 	zTargetAddr+3
.edbc	68		pla				pla 								; restore operator.
.edbd	4c 85 ed	jmp $ed85			jmp 	_CLEWriteToAddress
.edc0					_CLEBinaryLHTerm:
.edc0	48		pha				pha 								; save operator on stack
.edc1	c8		iny				iny 								; skip over it.
.edc2	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.edc4	20 ed e1	jsr $e1ed			jsr 	EvaluateAtomCurrentLevel
.edc7	a5 28		lda $28				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.edc9	85 24		sta $24				sta 	zTemp1 						; a four byte address.....
.edcb	a5 29		lda $29				lda 	zTargetAddr+1
.edcd	85 25		sta $25				sta 	zTemp1+1 					; we only worry about 4 byte value
.edcf	5a		phy				phy 								; save Y
.edd0	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.edd1	a0 00		ldy #$00			ldy 	#0
.edd3	b1 24		lda ($24),y			lda 	(zTemp1),y
.edd5	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.edd8	85 28		sta $28				sta 	zTargetAddr+0
.edda	c8		iny				iny
.eddb	b1 24		lda ($24),y			lda 	(zTemp1),y
.eddd	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.ede0	85 29		sta $29				sta 	zTargetAddr+1
.ede2	c8		iny				iny
.ede3	b1 24		lda ($24),y			lda 	(zTemp1),y
.ede5	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.ede8	85 2a		sta $2a				sta 	zTargetAddr+2
.edea	c8		iny				iny
.edeb	b1 24		lda ($24),y			lda 	(zTemp1),y
.eded	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.edf0	85 2b		sta $2b				sta 	zTargetAddr+3
.edf2	7a		ply				ply 								; restore Y
.edf3	68		pla				pla 								; restore the operator.
.edf4	4c 85 ed	jmp $ed85			jmp 	_CLEWriteToAddress
.edf7					_CLEByteWrite:
.edf7	a5 2a		lda $2a				lda 	zTargetAddr+2
.edf9	05 2b		ora $2b				ora 	zTargetAddr+3
.edfb	d0 0a		bne $ee07			bne 	_CLEByteWriteExt
.edfd	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ee00	5a		phy				phy 								; write the byte preserving Y
.ee01	a0 00		ldy #$00			ldy 	#0
.ee03	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee05	7a		ply				ply
.ee06	60		rts				rts
.ee07					_CLEByteWriteExt:
.ee07	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ee0a	a3 00		ldz #$00			ldz 	#0
.ee0c	ea		nop				nop
.ee0d	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ee0f	60		rts				rts
.ee10					_CLEWordWrite:
.ee10	a5 2a		lda $2a				lda 	zTargetAddr+2
.ee12	05 2b		ora $2b				ora 	zTargetAddr+3
.ee14	d0 1c		bne $ee32			bne 	_CLEWordWriteExt
.ee16	5a		phy				phy
.ee17	a0 00		ldy #$00			ldy 	#0
.ee19	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ee1c	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee1e	c8		iny				iny
.ee1f	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee22	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee24	c8		iny				iny
.ee25	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ee28	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee2a	c8		iny				iny
.ee2b	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ee2e	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee30	7a		ply				ply 								; restore Y
.ee31	60		rts				rts
.ee32					_CLEWordWriteExt:
.ee32	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ee35	a3 00		ldz #$00			ldz 	#0
.ee37	ea		nop				nop
.ee38	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ee3a	1b		inz				inz
.ee3b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee3e	ea		nop				nop
.ee3f	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ee41	1b		inz				inz
.ee42	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ee45	ea		nop				nop
.ee46	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ee48	1b		inz				inz
.ee49	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ee4c	ea		nop				nop
.ee4d	92 28		sta ($28),z			sta 	(zTargetAddr),z
.ee4f	60		rts				rts
.ee50					_CLEStringWrite:
.ee50	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.ee53	85 24		sta $24				sta 	zTemp1
.ee55	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ee58	85 25		sta $25				sta 	zTemp1+1
.ee5a	5a		phy				phy
.ee5b	a0 00		ldy #$00			ldy 	#0
.ee5d					_CLEStringCopy:
.ee5d	b1 24		lda ($24),y			lda 	(zTemp1),y
.ee5f	91 28		sta ($28),y			sta 	(zTargetAddr),y
.ee61	c9 00		cmp #$00			cmp 	#0
.ee63	f0 16		beq $ee7b			beq	 	_CLEStringWritten
.ee65	c8		iny				iny
.ee66	d0 f5		bne $ee5d			bne 	_CLEStringCopy
.ee68	20 3d e1	jsr $e13d			jsr 	ReportError
>ee6b	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>ee73	4e 47 20 43 4f 50 59 00
.ee7b					_CLEStringWritten:
.ee7b	7a		ply				ply
.ee7c	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.ee7d					COMMAND_Print:
.ee7d	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.ee7f	f0 15		beq $ee96			beq 	_CPRExitNL 					; zero end of line.
.ee81	c8		iny				iny
.ee82	c9 20		cmp #$20			cmp 	#' '
.ee84	f0 f7		beq $ee7d			beq 	COMMAND_Print
.ee86	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; colon, end of line
.ee88	f0 0c		beq $ee96			beq 	_CPRExitNL
.ee8a	c9 8e		cmp #$8e			cmp 	#KW_SEMICOLON 				; semicolon ?
.ee8c	d0 0e		bne $ee9c			bne 	_CPRNotSemicolon
.ee8e	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.ee90	f0 09		beq $ee9b			beq 	_CPRExit
.ee92	c9 8d		cmp #$8d			cmp 	#KW_COLON
.ee94	d0 e7		bne $ee7d			bne 	COMMAND_Print 				; if not, just go back round again
.ee96					_CPRExitNL:
.ee96	a9 0d		lda #$0d			lda 	#13
.ee98	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.ee9b					_CPRExit:
.ee9b	60		rts				rts
.ee9c					_CPRNotSemicolon:
.ee9c	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.ee9e	f0 2b		beq $eecb			beq 	_CPRNewLine 				; new line
.eea0	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.eea2	d0 2e		bne $eed2			bne 	_CPRNotQuote
.eea4					_CPRPrintText:
.eea4	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.eea6	f0 0a		beq $eeb2			beq 	_CPRError 					; if zero no closing quote
.eea8	c8		iny				iny
.eea9	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.eeab	f0 d0		beq $ee7d			beq 	COMMAND_Print 				; go round again.
.eead	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter 			; print and do next character
.eeb0	80 f2		bra $eea4			bra 	_CPRPrintText
.eeb2					_CPRError:
.eeb2	20 3d e1	jsr $e13d			jsr 	ReportError
>eeb5	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>eebd	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.eecb					_CPRNewLine:
.eecb	a9 0d		lda #$0d			lda 	#13
.eecd	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.eed0	80 ab		bra $ee7d			bra 	COMMAND_Print
.eed2					_CPRNotQuote:
.eed2	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.eed4	d0 11		bne $eee7			bne 	_CPRNumber 					; print a number.
.eed6	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase 				; this is the address to print.
.eed9	5a		phy				phy
.eeda	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.eedd	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.eee0	aa		tax				tax
.eee1	20 c3 e4	jsr $e4c3			jsr 	SIOPrintString
.eee4	7a		ply				ply
.eee5	80 96		bra $ee7d			bra 	COMMAND_Print
.eee7					_CPRNumber:
.eee7	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.eee9	f0 17		beq $ef02			beq 	_CPRHexadecimal
.eeeb	88		dey				dey 								; must be 1st char of expr
.eeec	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase 				; this is the value to print.
.eeef	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.eef2	10 08		bpl $eefc			bpl 	_CPRIsPositive
.eef4	20 2e ea	jsr $ea2e			jsr 	BFUNC_NegateAlways 			; negate it
.eef7	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.eef9	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.eefc					_CPRIsPositive:
.eefc	20 3f ef	jsr $ef3f			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.eeff	4c 7d ee	jmp $ee7d			jmp 	COMMAND_Print
.ef02					_CPRHexadecimal:
.ef02	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase 				; this is the value to print.
.ef05	20 0b ef	jsr $ef0b			jsr 	_CPRPrintRecHex 			; hex version of it.
.ef08	4c 7d ee	jmp $ee7d			jmp 	COMMAND_Print
.ef0b					_CPRPrintRecHex:
.ef0b	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.ef0e	29 0f		and #$0f			and 	#15 						; and put on stack
.ef10	48		pha				pha
.ef11	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.ef13					_CPRShiftDiv:
.ef13	4e 03 04	lsr $0403			lsr 	evalStack+3
.ef16	6e 02 04	ror $0402			ror 	evalStack+2
.ef19	6e 01 04	ror $0401			ror		evalStack+1
.ef1c	6e 00 04	ror $0400			ror		evalStack+0
.ef1f	ca		dex				dex
.ef20	d0 f1		bne $ef13			bne 	_CPRShiftDiv
.ef22	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.ef25	0d 01 04	ora $0401			ora 	evalStack+1
.ef28	0d 02 04	ora $0402			ora 	evalStack+2
.ef2b	0d 03 04	ora $0403			ora 	evalStack+3
.ef2e	f0 03		beq $ef33			beq 	_CPRNoHexRec
.ef30	20 0b ef	jsr $ef0b			jsr 	_CPRPrintRecHex
.ef33					_CPRNoHexRec:
.ef33	68		pla				pla 								; original remainder.
.ef34	c9 0a		cmp #$0a			cmp 	#10
.ef36	90 02		bcc $ef3a			bcc		_CPRNH2
.ef38	69 06		adc #$06			adc 	#6
.ef3a	69 30		adc #$30	_CPRNH2:adc 	#48
.ef3c	4c f0 e4	jmp $e4f0			jmp 	SIOPrintCharacter
.ef3f					CPRPrintInteger:
.ef3f	48		pha				pha 								; save on stack.
.ef40	da		phx				phx
.ef41	5a		phy				phy
.ef42	20 49 ef	jsr $ef49			jsr 	_CPRPrintRec 				; recursive print call
.ef45	7a		ply				ply
.ef46	fa		plx				plx
.ef47	68		pla				pla
.ef48	60		rts				rts
.ef49					_CPRPrintRec:
.ef49	a9 0a		lda #$0a			lda 	#10 						; save base
.ef4b	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.ef4e	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.ef50	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.ef53	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.ef56	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.ef59	20 8b e9	jsr $e98b			jsr 	BFUNC_Divide 				; divide by 10.
.ef5c	ad 98 20	lda $2098			lda 	Temp1+0		 				; push remainder on stack
.ef5f	48		pha				pha
.ef60	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.ef63	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.ef66	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.ef69	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.ef6c	f0 03		beq $ef71			beq 	_CPRNoRecurse
.ef6e	20 49 ef	jsr $ef49			jsr 	_CPRPrintRec 				; recursive print.
.ef71					_CPRNoRecurse:
.ef71	68		pla				pla
.ef72	09 30		ora #$30			ora 	#"0"
.ef74	4c f0 e4	jmp $e4f0			jmp 	SIOPrintCharacter
.ef77					COMMAND_CLS:
.ef77	4c b5 e4	jmp $e4b5			jmp 	SIOClearScreen

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.ef7a					COMMAND_List:
.ef7a	5a		phy				phy
.ef7b	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.ef7d	85 28		sta $28				sta 	zTargetAddr
.ef7f	a9 23		lda #$23			lda 	#BasicProgram >> 8
.ef81	85 29		sta $29				sta 	zTargetAddr+1
.ef83	a9 10		lda #$10			lda 	#16 						; print 16 lines
.ef85	85 2a		sta $2a				sta 	zTargetAddr+2
.ef87					_CLLILoop:
.ef87	a0 00		ldy #$00			ldy 	#0
.ef89	b1 28		lda ($28),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.ef8b	f0 14		beq $efa1			beq 	_CLLIExit
.ef8d	20 a3 ef	jsr $efa3			jsr 	CLIOneLine 					; list one line.
.ef90	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.ef92	18		clc				clc
.ef93	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.ef95	65 28		adc $28				adc 	zTargetAddr
.ef97	85 28		sta $28				sta 	zTargetAddr
.ef99	90 02		bcc $ef9d			bcc 	_CLLINoCarry
.ef9b	e6 29		inc $29				inc 	zTargetAddr+1
.ef9d					_CLLINoCarry:
.ef9d	c6 2a		dec $2a				dec 	zTargetAddr+2 				; done all of them ?
.ef9f	d0 e6		bne $ef87			bne 	_CLLILoop
.efa1					_CLLIExit:
.efa1	7a		ply				ply
.efa2	60		rts				rts
.efa3					CLIOneLine:
.efa3	a0 01		ldy #$01			ldy 	#1 							; get line#
.efa5	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efa7	8d 00 04	sta $0400			sta 	evalStack+0
.efaa	c8		iny				iny
.efab	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efad	8d 01 04	sta $0401			sta 	evalStack+1
.efb0	a9 00		lda #$00			lda 	#0
.efb2	aa		tax				tax
.efb3	8d 02 04	sta $0402			sta 	evalStack+2
.efb6	8d 03 04	sta $0403			sta 	evalStack+3
.efb9	20 3f ef	jsr $ef3f			jsr 	CPRPrintInteger 			; print line#
.efbc	a9 20		lda #$20			lda 	#32
.efbe	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.efc1	a0 03		ldy #$03			ldy 	#3 							; where to start
.efc3					_CLIOutput:
.efc3	b1 28		lda ($28),y			lda 	(zTargetAddr),y
.efc5	c8		iny				iny
.efc6	09 00		ora #$00			ora 	#0
.efc8	f0 0c		beq $efd6			beq 	_CLIExit
.efca	10 05		bpl $efd1			bpl		_CLISingle
.efcc	20 dc ef	jsr $efdc			jsr 	CLIPrintToken
.efcf	80 f2		bra $efc3			bra 	_CLIOutput
.efd1					_CLISingle:
.efd1	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.efd4	80 ed		bra $efc3			bra 	_CLIOutput
.efd6					_CLIExit:
.efd6	a9 0d		lda #$0d			lda 	#13 						; new line.
.efd8	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.efdb	60		rts				rts
.efdc					CLIPrintToken:
.efdc	5a		phy				phy 								; save Y
.efdd	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.efdf	a8		tay				tay
.efe0	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.efe2					_CLIFind:
.efe2	88		dey				dey 								; decrement counter
.efe3	30 09		bmi $efee			bmi 	_CLIFoundToken 				; if -ve found the token.
.efe5					_CLISkip:
.efe5	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.efe8	e8		inx				inx
.efe9	0a		asl a				asl		a
.efea	90 f9		bcc $efe5			bcc 	_CLISkip
.efec	80 f4		bra $efe2			bra 	_CLIFind
.efee					_CLIFoundToken:
.efee	7a		ply				ply
.efef					_CLIPrintIt:
.efef	bd 6e e0	lda $e06e,x			lda 	TokenText,x
.eff2	e8		inx				inx
.eff3	48		pha				pha
.eff4	29 7f		and #$7f			and 	#$7F
.eff6	20 f0 e4	jsr $e4f0			jsr 	SIOPrintCharacter
.eff9	68		pla				pla
.effa	0a		asl a				asl 	a
.effb	90 f2		bcc $efef			bcc 	_CLIPrintIt
.effd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/dountil.asm

.effe					COMMAND_Do:
.effe	a9 9c		lda #$9c			lda 	#KW_DO						; push position with a DO token.
.f000	20 1e f0	jsr $f01e			jsr 	CDOPushPosOnStack
.f003	60		rts				rts
.f004					COMMAND_Until:
.f004	a9 9c		lda #$9c			lda 	#KW_DO 						; check TOS is a Do.
.f006	20 5c f0	jsr $f05c			jsr 	CDOCheckTopStack
.f009	a2 00		ldx #$00			ldx 	#0 							; evaluate the test
.f00b	20 f1 e1	jsr $e1f1			jsr 	EvaluateBase
.f00e	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check if zero
.f011	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.f014	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.f017	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.f01a	f0 2a		beq $f046			beq 	CDOPullPosOffStack 			; zero, restore the position.
.f01c	80 1e		bra $f03c			bra 	CDOThrowPosOffStack			; non-zero chuck it.
.f01e					CDOPushPosOnStack:
.f01e	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.f021	48		pha				pha
.f022	98		tya				tya
.f023	9d 01 02	sta $0201,x			sta 	BasicStack+1,x 				; +1 	Y Position
.f026	a5 20		lda $20				lda 	zCurrentLine
.f028	9d 02 02	sta $0202,x			sta 	BasicStack+2,x 				; +2 	low of pos
.f02b	a5 21		lda $21				lda 	zCurrentLine+1
.f02d	9d 03 02	sta $0203,x			sta 	BasicStack+3,x 				; +3 	high of pos
.f030	68		pla				pla
.f031	9d 04 02	sta $0204,x			sta 	BasicStack+4,x 				; +4 	token on stack
.f034	e8		inx				inx
.f035	e8		inx				inx
.f036	e8		inx				inx
.f037	e8		inx				inx 								; always points to TOS.
.f038	8e a3 20	stx $20a3			stx 	basicStackIndex
.f03b	60		rts				rts
.f03c					CDOThrowPosOffStack:
.f03c	ad a3 20	lda $20a3			lda 	basicStackIndex
.f03f	38		sec				sec
.f040	e9 04		sbc #$04			sbc 	#4
.f042	8d a3 20	sta $20a3			sta 	basicStackIndex
.f045	60		rts				rts
.f046					CDOPullPosOffStack:
.f046	ae a3 20	ldx $20a3			ldx 	basicStackIndex
.f049	ca		dex				dex
.f04a	ca		dex				dex
.f04b	ca		dex				dex
.f04c	ca		dex				dex
.f04d	bd 01 02	lda $0201,x			lda 	BasicStack+1,x 					; get position back.
.f050	a8		tay				tay
.f051	bd 02 02	lda $0202,x			lda 	BasicStack+2,x
.f054	85 20		sta $20				sta 	zCurrentLine
.f056	bd 03 02	lda $0203,x			lda 	BasicStack+3,x
.f059	85 21		sta $21				sta 	zCurrentLine+1
.f05b	60		rts				rts
.f05c					CDOCheckTopStack:
.f05c	ae a3 20	ldx $20a3			ldx 	basicStackIndex 			; if match
.f05f	dd 00 02	cmp $0200,x			cmp 	BasicStack+0,x
.f062	d0 01		bne $f065			bne 	_CDOCTSError
.f064	60		rts				rts
.f065					_CDOCTSError:
.f065	20 3d e1	jsr $e13d			jsr 	ReportError
>f068	53 54 52 55 43 54 55 52				.text 	"STRUCTURE MIXED",$00
>f070	45 20 4d 49 58 45 44 00

;******  Return to file: basic.asm

.f078					Start:
.f078	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f07a	9a		txs			txs
.f07b	20 b2 e4	jsr $e4b2			jsr 	SIOInitialise 				; initialise the I/O system.
.f07e	a2 f7		ldx #$f7			ldx 	#BootMsg1 & 255 			; boot text.
.f080	a0 f0		ldy #$f0			ldy 	#BootMsg1 >> 8
.f082	20 c3 e4	jsr $e4c3			jsr 	SIOPrintString
.f085	a2 ff		ldx #$ff			ldx 	#(endMemory-startMemory-1) & $FF
.f087	a0 5f		ldy #$5f			ldy 	#(endMemory-startMemory-1) >> 8
.f089	20 6c e1	jsr $e16c			jsr 	PrintWordInteger
.f08c	a2 0e		ldx #$0e			ldx 	#BootMsg2 & 255
.f08e	a0 f1		ldy #$f1			ldy 	#BootMsg2 >> 8
.f090	20 c3 e4	jsr $e4c3			jsr 	SIOPrintString
.f093	20 a6 e1	jsr $e1a6			jsr 	CopyBasicCode 				; it into the BASIC area.
.f096	ad 2e f1	lda $f12e			lda 	StartBehaviour 				; what to do ?
.f099	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.f09b	f0 17		beq $f0b4			beq		CommandLine
.f09d	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.f09f	f0 07		beq $f0a8			beq	 	RunProgram
.f0a1	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.f0a3	f0 46		beq $f0eb			beq 	TokeniseExec
.f0a5	4c 2d e1	jmp $e12d			jmp		SyntaxError
.f0a8					RunProgram:
.f0a8	20 a6 e1	jsr $e1a6			jsr 	CopyBasicCode
.f0ab	20 bd ec	jsr $ecbd			jsr 	COMMAND_NewCode 			; do a new
.f0ae	20 0c ed	jsr $ed0c			jsr 	COMMAND_OldCode 			; get back the old program as we're deving.
.f0b1	4c f5 eb	jmp $ebf5			jmp 	COMMAND_Run
.f0b4					CommandLine:
.f0b4	20 bd ec	jsr $ecbd			jsr 	Command_NewCode
.f0b7					WarmStart:
.f0b7	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.f0b9	9a		txs			txs
.f0ba	20 2d e5	jsr $e52d			jsr 	SIOReadLine 				; read input line.
.f0bd	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.f0bf	85 24		sta $24				sta 	zTemp1
.f0c1	a9 20		lda #$20			lda 	#InputLine >> 8
.f0c3	85 25		sta $25				sta 	zTemp1+1
.f0c5	20 99 e6	jsr $e699			jsr 	TokeniseString
.f0c8	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.f0ca	85 20		sta $20				sta 	zCurrentLine
.f0cc	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.f0ce	85 21		sta $21				sta 	zCurrentLine+1
.f0d0	a0 00		ldy #$00			ldy 	#0
.f0d2					_WSSkipSpace:
.f0d2	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.f0d4	c8		iny				iny
.f0d5	c9 20		cmp #$20			cmp 	#' '
.f0d7	f0 f9		beq $f0d2			beq 	_WSSkipSpace
.f0d9	88		dey				dey
.f0da	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.f0dc	90 0a		bcc $f0e8			bcc 	_WSExecute
.f0de	c9 3a		cmp #$3a			cmp 	#"9"+1
.f0e0	b0 06		bcs $f0e8			bcs 	_WSExecute
.f0e2	20 6e e7	jsr $e76e			jsr 	EditProgram
.f0e5	4c b7 f0	jmp $f0b7			jmp 	WarmStart
.f0e8					_WSExecute:
.f0e8	4c 08 ec	jmp $ec08			jmp 	CRUNNextInstruction
.f0eb					TokeniseExec:
.f0eb	a9 1d		lda #$1d			lda 	#BasicCode & $FF 			; if so tokenise whatever I've put in the basic code
.f0ed	85 24		sta $24				sta 	zTemp1 						; area
.f0ef	a9 f1		lda #$f1			lda 	#BasicCode >> 8
.f0f1	85 25		sta $25				sta 	zTemp1+1
.f0f3	20 99 e6	jsr $e699			jsr 	TokeniseString
>f0f6	02						.byte 	2
.f0f7					BootMsg1:
>f0f7	2a 2a 2a 20 41 54 4f 4d				.text 	"*** ATOMIC BASIC ***",13,13,0
>f0ff	49 43 20 42 41 53 49 43 20 2a 2a 2a 0d 0d 00
.f10e					BootMsg2:
>f10e	20 42 59 54 45 53 20 46				.text	" BYTES FREE.",13,13,0
>f116	52 45 45 2e 0d 0d 00
.f11d					BasicCode:

;******  Processing file: include/basic_generated.inc

>f11d	10 01 00 4d 92 82 46 46			.byte $10,$01,$00,$4d,$92,$82,$46,$46,$44,$33,$30,$30,$30,$8d,$af,$00,$00
>f125	44 33 30 30 30 8d af 00 00
.f12e					StartBehaviour:
>f12e	52					.text "R"

;******  Return to file: basic.asm


;******  End of listing
