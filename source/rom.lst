
; 64tass Turbo Assembler Macro V1.54.1900 listing file
; 64tass -q -c -D TARGET=2 -b -L rom.lst -o rom.bin basic.asm
; Mon Jul 29 16:01:12 2019

;Offset	;Hex		;Monitor	;Source

;******  Command line definitions

=2					TARGET=2

;******  Processing input file: basic.asm


;******  Processing file: porting.asm

.fff8					EXTDummyInterrupt:
.fff8	40		rti				rti
>fffa	f8 ff						.word 	EXTDummyInterrupt
>fffc	3a ee						.word 	Start
>fffe	f8 ff						.word 	EXTDummyInterrupt
=4					EXTZPWork = 4								; Zero Page work for Personality (4 bytes)
=8					IOCursorX = 8 								; Cursor position
=9					IOCursorY = 9
=$20							zeroPage 	= $20 					; first ZP byte to use
=$2000							startMemory = $2000 				; first non ZP byte to use
=$8000							endMemory   = $8000 				; last non ZP byte to use
=$200							basicStack  = $200 					; stack for BASIC
=$400							evalStack   = $400 					; stack for evaluation of expressions

;******  Processing file: personalities/personality_6502.asm

>0000	00					.byte 	0
=40					EXTWidth = 40 								; screen width
=25					EXTHeight = 25 								; screen height
=$0800					EXTLowMemory = $0800 						; Workspace RAM starts here
=$6000					EXTHighMemory = $6000 						; Workspace RAM ends here
=$b000					PScreen = $B000								; 1k screen RAM here
=$b800					PKeyboard = $B800							; Keyboard port.
=$b801					PBreak = $B801 								; Break key.
.a000					EXTStartPersonalise:
.a000	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.a002	9a		txs			txs
.a003	20 82 a0	jsr $a082		jsr 	EXTReset 						; reset video
.a006	20 38 a0	jsr $a038		jsr 	EXTClearScreen 					; clear screen
.a009	4c 3a ee	jmp $ee3a		jmp 	Start 							; start main application
.a00c					EXTReadKeyPort:
.a00c	ad 00 b8	lda $b800		lda 	PKeyboard							; read key
.a00f	09 00		ora #$00		ora 	#0
.a011	60		rts			rts
.a012					EXTRemoveKeyPressed:
.a012	48		pha			pha 										; key pressed clear queue byte.
.a013	a9 00		lda #$00		lda 	#0
.a015	8d 00 b8	sta $b800		sta 	PKeyboard
.a018	68		pla			pla
.a019	60		rts			rts
.a01a					EXTCheckBreak:
.a01a	ad 01 b8	lda $b801		lda 	PBreak
.a01d	60		rts			rts
.a01e					EXTReadScreen:
.a01e	5a		phy			phy 										; save Y
.a01f	86 04		stx $04			stx 	EXTZPWork							; into EXTZPWork
.a021	98		tya			tya
.a022	09 b0		ora #$b0		ora 	#PScreen>>8 						; move into screen area
.a024	85 05		sta $05			sta 	EXTZPWork+1 						; read character there
.a026	a0 00		ldy #$00		ldy 	#0
.a028	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a02a	7a		ply			ply 										; restore Y and exit.
.a02b	60		rts			rts
.a02c					EXTWriteScreen:
.a02c	5a		phy			phy
.a02d	48		pha			pha
.a02e	20 1e a0	jsr $a01e		jsr		EXTReadScreen 						; set up the address into EXTZPWork
.a031	a0 00		ldy #$00		ldy 	#0
.a033	68		pla			pla 										; restore and write.
.a034	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a036	7a		ply			ply
.a037	60		rts			rts
.a038					EXTClearScreen:
.a038	48		pha			pha 										; save registers
.a039	da		phx			phx
.a03a	a2 00		ldx #$00		ldx 	#0
.a03c					_EXTCSLoop:
.a03c	a9 20		lda #$20		lda 	#32
.a03e	9d 00 b0	sta $b000,x		sta 	PScreen+0,x
.a041	9d 00 b1	sta $b100,x		sta 	PScreen+$100,x
.a044	9d 00 b2	sta $b200,x		sta 	PScreen+$200,x
.a047	9d 00 b3	sta $b300,x		sta 	PScreen+$300,x
.a04a	e8		inx			inx
.a04b	d0 ef		bne $a03c		bne 	_EXTCSLoop
.a04d	fa		plx			plx 										; restore
.a04e	68		pla			pla
.a04f	60		rts			rts
.a050					EXTScrollDisplay:
.a050	48		pha			pha 										; save registers
.a051	5a		phy			phy
.a052	a9 00		lda #$00		lda 	#PScreen & $FF 					; set pointer to screen
.a054	85 04		sta $04			sta 	EXTZPWork+0
.a056	a9 b0		lda #$b0		lda 	#PScreen >> 8
.a058	85 05		sta $05			sta 	EXTZPWork+1
.a05a					_EXTScroll:
.a05a	a0 28		ldy #$28		ldy 	#EXTWidth
.a05c	b1 04		lda ($04),y		lda 	(EXTZPWork),y
.a05e	a0 00		ldy #$00		ldy 	#0
.a060	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a062	e6 04		inc $04			inc 	EXTZPWork 							; bump address
.a064	d0 02		bne $a068		bne 	_EXTNoCarry
.a066	e6 05		inc $05			inc 	EXTZPWork+1
.a068					_EXTNoCarry:
.a068	a5 04		lda $04			lda 	EXTZPWork 							; done ?
.a06a	c9 c0		cmp #$c0		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) & $FF
.a06c	d0 ec		bne $a05a		bne 	_EXTScroll
.a06e	a5 05		lda $05			lda 	EXTZPWork+1
.a070	c9 b3		cmp #$b3		cmp	 	#(PScreen+EXTWidth*(EXTHeight-1)) >> 8
.a072	d0 e6		bne $a05a		bne 	_EXTScroll
.a074	a0 00		ldy #$00		ldy 	#0									; clear bottom line.
.a076					_EXTLastLine:
.a076	a9 20		lda #$20		lda 	#32
.a078	91 04		sta ($04),y		sta 	(EXTZPWork),y
.a07a	c8		iny			iny
.a07b	c0 28		cpy #$28		cpy 	#EXTWidth
.a07d	d0 f7		bne $a076		bne 	_EXTLastLine
.a07f	7a		ply			ply 										; restore and exit.
.a080	68		pla			pla
.a081	60		rts			rts
.a082					EXTReset:
.a082	60		rts			rts

;******  Return to file: porting.asm


;******  Return to file: basic.asm


;******  Processing file: include/tokens.inc

.e000					KeywordVectorTable:
>e000	6b e7					.word	BFUNC_WordInd                 ; "!"        ($0080)
>e002	1f e1					.word	SyntaxError                   ; """        ($0081)
>e004	1f e1					.word	SyntaxError                   ; "#"        ($0082)
>e006	60 e7					.word	BFUNC_String                  ; "$"        ($0083)
>e008	00 e9					.word	BFUNC_Modulus                 ; "%"        ($0084)
>e00a	72 e7					.word	BFUNC_And                     ; "&"        ($0085)
>e00c	1f e1					.word	SyntaxError                   ; "'"        ($0086)
>e00e	1f e1					.word	SyntaxError                   ; "("        ($0087)
>e010	1f e1					.word	SyntaxError                   ; ")"        ($0088)
>e012	e1 e7					.word	BFUNC_Multiply                ; "*"        ($0089)
>e014	14 e7					.word	BFUNC_Add                     ; "+"        ($008a)
>e016	3a e7					.word	BFUNC_Subtract                ; "-"        ($008b)
>e018	38 e8					.word	BFUNC_Divide                  ; "/"        ($008c)
>e01a	1f e1					.word	SyntaxError                   ; ":"        ($008d)
>e01c	1f e1					.word	SyntaxError                   ; ";"        ($008e)
>e01e	7e e9					.word	BFUNC_LessEqual               ; "<="       ($008f)
>e020	1f e9					.word	BFUNC_NotEquals               ; "<>"       ($0090)
>e022	59 e9					.word	BFUNC_Less                    ; "<"        ($0091)
>e024	1c e9					.word	BFUNC_Equals                  ; "="        ($0092)
>e026	5c e9					.word	BFUNC_GreaterEqual            ; ">="       ($0093)
>e028	7b e9					.word	BFUNC_Greater                 ; ">"        ($0094)
>e02a	64 e7					.word	BFUNC_ByteInd                 ; "?"        ($0095)
>e02c	bc e7					.word	BFUNC_Xor                     ; "^"        ($0096)
>e02e	0b eb					.word	COMMAND_Assert                ; "assert"   ($0097)
>e030	35 ea					.word	UNARY_Abs                     ; "abs"      ($0098)
>e032	4c eb					.word	COMMAND_Clear                 ; "clear"    ($0099)
>e034	20 ea					.word	UNARY_Ch                      ; "ch"       ($009a)
>e036	1f e1					.word	SyntaxError                   ; "do"       ($009b)
>e038	00 eb					.word	COMMAND_End                   ; "end"      ($009c)
>e03a	1f e1					.word	SyntaxError                   ; "for"      ($009d)
>e03c	1f e1					.word	SyntaxError                   ; "gosub"    ($009e)
>e03e	1f e1					.word	SyntaxError                   ; "goto"     ($009f)
>e040	1f e1					.word	SyntaxError                   ; "input"    ($00a0)
>e042	1f e1					.word	SyntaxError                   ; "if"       ($00a1)
>e044	b8 ed					.word	COMMAND_List                  ; "list"     ($00a2)
>e046	1f e1					.word	SyntaxError                   ; "loop"     ($00a3)
>e048	1f e1					.word	SyntaxError                   ; "link"     ($00a4)
>e04a	b6 eb					.word	COMMAND_Let                   ; "let"      ($00a5)
>e04c	de e9					.word	UNARY_Len                     ; "len"      ($00a6)
>e04e	1f e1					.word	SyntaxError                   ; "next"     ($00a7)
>e050	39 eb					.word	COMMAND_New                   ; "new"      ($00a8)
>e052	80 eb					.word	COMMAND_Old                   ; "old"      ($00a9)
>e054	be ec					.word	COMMAND_Print                 ; "print"    ($00aa)
>e056	2f eb					.word	COMMAND_Rem                   ; "rem"      ($00ab)
>e058	8f ea					.word	COMMAND_Run                   ; "run"      ($00ac)
>e05a	52 ea					.word	UNARY_Rnd                     ; "rnd"      ($00ad)
>e05c	f8 ea					.word	COMMAND_Stop                  ; "stop"     ($00ae)
>e05e	1f e1					.word	SyntaxError                   ; "step"     ($00af)
>e060	1f e1					.word	SyntaxError                   ; "then"     ($00b0)
>e062	3d ea					.word	UNARY_Top                     ; "top"      ($00b1)
>e064	1f e1					.word	SyntaxError                   ; "to"       ($00b2)
>e066	97 e7					.word	BFUNC_Or                      ; "|"        ($00b3)
>e068	9d e9					.word	BFUNC_StringCompare           ; "~"        ($00b4)
.e06a					TokenText:
>e06a	a1					.byte $a1                             ; $0080 !
>e06b	a2					.byte $a2                             ; $0081 "
>e06c	a3					.byte $a3                             ; $0082 #
>e06d	a4					.byte $a4                             ; $0083 $
>e06e	a5					.byte $a5                             ; $0084 %
>e06f	a6					.byte $a6                             ; $0085 &
>e070	a7					.byte $a7                             ; $0086 '
>e071	a8					.byte $a8                             ; $0087 (
>e072	a9					.byte $a9                             ; $0088 )
>e073	aa					.byte $aa                             ; $0089 *
>e074	ab					.byte $ab                             ; $008a +
>e075	ad					.byte $ad                             ; $008b -
>e076	af					.byte $af                             ; $008c /
>e077	ba					.byte $ba                             ; $008d :
>e078	bb					.byte $bb                             ; $008e ;
>e079	3c bd					.byte $3c,$bd                         ; $008f <=
>e07b	3c be					.byte $3c,$be                         ; $0090 <>
>e07d	bc					.byte $bc                             ; $0091 <
>e07e	bd					.byte $bd                             ; $0092 =
>e07f	3e bd					.byte $3e,$bd                         ; $0093 >=
>e081	be					.byte $be                             ; $0094 >
>e082	bf					.byte $bf                             ; $0095 ?
>e083	de					.byte $de                             ; $0096 ^
>e084	41 53 53 45 52 d4			.byte $41,$53,$53,$45,$52,$d4         ; $0097 assert
>e08a	41 42 d3				.byte $41,$42,$d3                     ; $0098 abs
>e08d	43 4c 45 41 d2				.byte $43,$4c,$45,$41,$d2             ; $0099 clear
>e092	43 c8					.byte $43,$c8                         ; $009a ch
>e094	44 cf					.byte $44,$cf                         ; $009b do
>e096	45 4e c4				.byte $45,$4e,$c4                     ; $009c end
>e099	46 4f d2				.byte $46,$4f,$d2                     ; $009d for
>e09c	47 4f 53 55 c2				.byte $47,$4f,$53,$55,$c2             ; $009e gosub
>e0a1	47 4f 54 cf				.byte $47,$4f,$54,$cf                 ; $009f goto
>e0a5	49 4e 50 55 d4				.byte $49,$4e,$50,$55,$d4             ; $00a0 input
>e0aa	49 c6					.byte $49,$c6                         ; $00a1 if
>e0ac	4c 49 53 d4				.byte $4c,$49,$53,$d4                 ; $00a2 list
>e0b0	4c 4f 4f d0				.byte $4c,$4f,$4f,$d0                 ; $00a3 loop
>e0b4	4c 49 4e cb				.byte $4c,$49,$4e,$cb                 ; $00a4 link
>e0b8	4c 45 d4				.byte $4c,$45,$d4                     ; $00a5 let
>e0bb	4c 45 ce				.byte $4c,$45,$ce                     ; $00a6 len
>e0be	4e 45 58 d4				.byte $4e,$45,$58,$d4                 ; $00a7 next
>e0c2	4e 45 d7				.byte $4e,$45,$d7                     ; $00a8 new
>e0c5	4f 4c c4				.byte $4f,$4c,$c4                     ; $00a9 old
>e0c8	50 52 49 4e d4				.byte $50,$52,$49,$4e,$d4             ; $00aa print
>e0cd	52 45 cd				.byte $52,$45,$cd                     ; $00ab rem
>e0d0	52 55 ce				.byte $52,$55,$ce                     ; $00ac run
>e0d3	52 4e c4				.byte $52,$4e,$c4                     ; $00ad rnd
>e0d6	53 54 4f d0				.byte $53,$54,$4f,$d0                 ; $00ae stop
>e0da	53 54 45 d0				.byte $53,$54,$45,$d0                 ; $00af step
>e0de	54 48 45 ce				.byte $54,$48,$45,$ce                 ; $00b0 then
>e0e2	54 4f d0				.byte $54,$4f,$d0                     ; $00b1 top
>e0e5	54 cf					.byte $54,$cf                         ; $00b2 to
>e0e7	fc					.byte $fc                             ; $00b3 |
>e0e8	fe					.byte $fe                             ; $00b4 ~
>e0e9	00					.byte $00
.e0ea					TokenTypeInformation:
>e0ea	04					.byte $04                             ; $0080 !
>e0eb	0a					.byte $0a                             ; $0081 "
>e0ec	0a					.byte $0a                             ; $0082 #
>e0ed	04					.byte $04                             ; $0083 $
>e0ee	03					.byte $03                             ; $0084 %
>e0ef	00					.byte $00                             ; $0085 &
>e0f0	0a					.byte $0a                             ; $0086 '
>e0f1	0a					.byte $0a                             ; $0087 (
>e0f2	0a					.byte $0a                             ; $0088 )
>e0f3	03					.byte $03                             ; $0089 *
>e0f4	02					.byte $02                             ; $008a +
>e0f5	02					.byte $02                             ; $008b -
>e0f6	03					.byte $03                             ; $008c /
>e0f7	0a					.byte $0a                             ; $008d :
>e0f8	0a					.byte $0a                             ; $008e ;
>e0f9	01					.byte $01                             ; $008f <=
>e0fa	01					.byte $01                             ; $0090 <>
>e0fb	01					.byte $01                             ; $0091 <
>e0fc	01					.byte $01                             ; $0092 =
>e0fd	01					.byte $01                             ; $0093 >=
>e0fe	01					.byte $01                             ; $0094 >
>e0ff	04					.byte $04                             ; $0095 ?
>e100	00					.byte $00                             ; $0096 ^
>e101	04					.byte $04                             ; $0097 assert
>e102	09					.byte $09                             ; $0098 abs
>e103	04					.byte $04                             ; $0099 clear
>e104	09					.byte $09                             ; $009a ch
>e105	04					.byte $04                             ; $009b do
>e106	04					.byte $04                             ; $009c end
>e107	04					.byte $04                             ; $009d for
>e108	04					.byte $04                             ; $009e gosub
>e109	04					.byte $04                             ; $009f goto
>e10a	04					.byte $04                             ; $00a0 input
>e10b	04					.byte $04                             ; $00a1 if
>e10c	04					.byte $04                             ; $00a2 list
>e10d	04					.byte $04                             ; $00a3 loop
>e10e	04					.byte $04                             ; $00a4 link
>e10f	04					.byte $04                             ; $00a5 let
>e110	09					.byte $09                             ; $00a6 len
>e111	04					.byte $04                             ; $00a7 next
>e112	04					.byte $04                             ; $00a8 new
>e113	04					.byte $04                             ; $00a9 old
>e114	04					.byte $04                             ; $00aa print
>e115	04					.byte $04                             ; $00ab rem
>e116	04					.byte $04                             ; $00ac run
>e117	09					.byte $09                             ; $00ad rnd
>e118	04					.byte $04                             ; $00ae stop
>e119	04					.byte $04                             ; $00af step
>e11a	04					.byte $04                             ; $00b0 then
>e11b	09					.byte $09                             ; $00b1 top
>e11c	04					.byte $04                             ; $00b2 to
>e11d	00					.byte $00                             ; $00b3 |
>e11e	01					.byte $01                             ; $00b4 ~
=$00					KTYPE_PRECBASE = $00
=$08					KTYPE_COMMAND = $08
=$09					KTYPE_UNARYFN = $09
=$0a					KTYPE_SYNTAX = $0a
=$0080					KW_PLING = $0080
=$0081					KW_DQUOTE = $0081
=$0082					KW_HASH = $0082
=$0083					KW_DOLLAR = $0083
=$0084					KW_PERCENT = $0084
=$0085					KW_AMPERSAND = $0085
=$0086					KW_SQUOTE = $0086
=$0087					KW_LPAREN = $0087
=$0088					KW_RPAREN = $0088
=$0089					KW_STAR = $0089
=$008a					KW_PLUS = $008a
=$008b					KW_MINUS = $008b
=$008c					KW_FSLASH = $008c
=$008d					KW_COLON = $008d
=$008e					KW_SEMICOLON = $008e
=$008f					KW_LESSEQUAL = $008f
=$0090					KW_LESSGREATER = $0090
=$0091					KW_LESS = $0091
=$0092					KW_EQUAL = $0092
=$0093					KW_GREATEREQUAL = $0093
=$0094					KW_GREATER = $0094
=$0095					KW_QUESTION = $0095
=$0096					KW_HAT = $0096
=$0097					KW_ASSERT = $0097
=$0098					KW_ABS = $0098
=$0099					KW_CLEAR = $0099
=$009a					KW_CH = $009a
=$009b					KW_DO = $009b
=$009c					KW_END = $009c
=$009d					KW_FOR = $009d
=$009e					KW_GOSUB = $009e
=$009f					KW_GOTO = $009f
=$00a0					KW_INPUT = $00a0
=$00a1					KW_IF = $00a1
=$00a2					KW_LIST = $00a2
=$00a3					KW_LOOP = $00a3
=$00a4					KW_LINK = $00a4
=$00a5					KW_LET = $00a5
=$00a6					KW_LEN = $00a6
=$00a7					KW_NEXT = $00a7
=$00a8					KW_NEW = $00a8
=$00a9					KW_OLD = $00a9
=$00aa					KW_PRINT = $00aa
=$00ab					KW_REM = $00ab
=$00ac					KW_RUN = $00ac
=$00ad					KW_RND = $00ad
=$00ae					KW_STOP = $00ae
=$00af					KW_STEP = $00af
=$00b0					KW_THEN = $00b0
=$00b1					KW_TOP = $00b1
=$00b2					KW_TO = $00b2
=$00b3					KW_BAR = $00b3
=$00b4					KW_TILDE = $00b4

;******  Return to file: basic.asm


;******  Processing file: general/support.asm

.e11f					SyntaxError:
.e11f	20 2f e1	jsr $e12f			jsr 	ReportError
>e122	53 59 4e 54 41 58 20 45				.text	"SYNTAX ERROR",0
>e12a	52 52 4f 52 00
.e12f					ReportError:
.e12f	fa		plx				plx
.e130	7a		ply				ply
.e131	e8		inx				inx
.e132	d0 01		bne $e135			bne 	_REPrint
.e134	c8		iny				iny
.e135					_REPrint:
.e135	20 67 e4	jsr $e467			jsr 	SIOPrintString
.e138	a5 21		lda $21				lda 	zCurrentLine+1 				; running from tokeniser buffer
.e13a	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.e13c	f0 25		beq $e163			beq 	_RENoLineNumber
.e13e	a9 20		lda #$20			lda 	#" "
.e140	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.e143	a9 40		lda #$40			lda 	#"@"
.e145	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.e148	a0 01		ldy #$01			ldy 	#1
.e14a	a2 00		ldx #$00			ldx 	#0
.e14c	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e14e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e151	c8		iny				iny
.e152	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e154	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e157	c8		iny				iny
.e158	a9 00		lda #$00			lda 	#0
.e15a	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e15d	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e160	20 80 ed	jsr $ed80			jsr 	CPRPrintInteger
.e163					_RENoLineNumber:
.e163	a9 0d		lda #$0d			lda 	#13
.e165	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.e168	4c 5e ee	jmp $ee5e			jmp 	WarmStart
.e16b					CheckNextCharacter:
.e16b	8d 98 20	sta $2098			sta 	Temp1 						; save character to check
.e16e					_CNCLoop:
.e16e	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next
.e170	f0 0b		beq $e17d			beq 	_CNCFail 					; end of line, so no character
.e172	c8		iny				iny
.e173	c9 20		cmp #$20			cmp 	#' ' 						; skip spaces
.e175	f0 f7		beq $e16e			beq 	_CNCLoop
.e177	cd 98 20	cmp $2098			cmp 	Temp1 						; fail if not what was wanted
.e17a	d0 01		bne $e17d			bne 	_CNCFail
.e17c	60		rts				rts
.e17d					_CNCFail:
.e17d	20 2f e1	jsr $e12f			jsr 	ReportError
>e180	4d 49 53 53 49 4e 47 20				.text 	"MISSING TOKEN",$00
>e188	54 4f 4b 45 4e 00

;******  Return to file: basic.asm


;******  Processing file: general/data.asm

=$e18e							currentPosData = *
>0020					zCurrentLine: 	.word 	?					; address of current line (offset word)
>0022					zBasicStack:	.word 	? 					; stack for BASIC.
>0024					zLowMemory:		.word	?					; next free space after program (arrays,vars etc.)
>0026					zTemp1:			.word 	?					; temporary vars
>0028					zTemp2:			.word 	?
>002a					zTargetAddr: 	.dword 	? 					; address of LHS of assignment, list pointer.
>2000					FixedVariables:	.fill 	27*4 				; address of 26 x 4 byte fixed variables @A-Z
>206c					Control 		.byte 	? 					; 0 = normal, 1 = tokenise, 2 = run program.
>206d					InputLine:		.fill 	EXTWidth+1 			; screen input buffer, cannot cross page.
>2096					HighMemory:		.word 	?					; highest memory location available (2 bytes)
>2098					Temp1:			.dword	?					; 4 byte temporary stores.
>209c					SignCount:		.byte 	? 					; count of signs in divide.
>209d					StringBufferPos:.byte 	? 					; next free slot in string buffer
>209e					RandomSeed 		.word 	? 					; Random Number
>20a0					xCursor 		.byte 	? 					; cursor position
>20a1					yCursor 		.byte 	?
>20a2									.align	256
.2100					TokeniseBuffer:
>2100									.fill 	256
.2200					StringBuffer:
>2200									.fill 	256
.2300					BasicProgram:

;******  Return to file: basic.asm


;******  Processing file: general/evaluate.asm

.e18e					EvaluateSNError:
.e18e	4c 1f e1	jmp $e11f			jmp 	SyntaxError
.e191					EvaluateMissingQuote:
.e191	20 2f e1	jsr $e12f			jsr 	ReportError
>e194	4d 49 53 53 49 4e 47 20				.text 	"MISSING QUOTE",$00
>e19c	51 55 4f 54 45 00
.e1a2					EvaluateStringFull:
.e1a2	20 2f e1	jsr $e12f			jsr 	ReportError
>e1a5	53 54 52 49 4e 47 20 42				.text 	"STRING BUFFER FULL",$00
>e1ad	55 46 46 45 52 20 46 55 4c 4c 00
.e1b8					EvaluateBadHex:
.e1b8	20 2f e1	jsr $e12f			jsr 	ReportError
>e1bb	42 41 44 20 48 45 58 00				.text 	"BAD HEX",$00
.e1c3					EvaluateAtomCurrentLevel:
.e1c3	a9 07		lda #$07			lda 	#7
.e1c5	80 04		bra $e1cb			bra 	EvaluateAtPrecedenceLevel
.e1c7					EvaluateBase:
.e1c7	a2 00		ldx #$00			ldx 	#0 							; reset the stack
.e1c9					EvaluateBaseCurrentLevel:
.e1c9	a9 00		lda #$00			lda 	#0 							; current precedence is zero
.e1cb					EvaluateAtPrecedenceLevel:
.e1cb	48		pha				pha 								; save precedence level
.e1cc	a9 00		lda #$00			lda 	#0 							; zero the result.
.e1ce	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e1d1	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e1d4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e1d7	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e1da					_EVALSkipSpace1:
.e1da	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token, skipping over spaces.
.e1dc	f0 b0		beq $e18e			beq 	EvaluateSNError 			; end of line, without token.
.e1de	c8		iny				iny
.e1df	c9 20		cmp #$20			cmp 	#32
.e1e1	f0 f7		beq $e1da			beq 	_EVALSkipSpace1
.e1e3	88		dey				dey 								; points at the token.
.e1e4	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; is it opening quote ?
.e1e6	f0 14		beq $e1fc			beq 	_EVALString  				; if so load in a constant string
.e1e8	c9 82		cmp #$82			cmp 	#KW_HASH 					; is it a hash, e.g. hexadecimal.
.e1ea	f0 36		beq $e222			beq 	_EVALHexadecimal
.e1ec	c9 30		cmp #$30			cmp 	#'0'						; is it in range 0-9
.e1ee	90 04		bcc $e1f4			bcc		_EVALGoKeywordVariable 		; yes, it's a keyword or variable.
.e1f0	c9 3a		cmp #$3a			cmp 	#'9'+1
.e1f2	90 03		bcc $e1f7			bcc 	_EVALDecimal
.e1f4					_EVALGoKeywordVariable:
.e1f4	4c 79 e2	jmp $e279			jmp 	_EVALKeywordVariable
.e1f7					_EVALDecimal:
.e1f7	20 d6 e2	jsr $e2d6			jsr 	EVALGetDecConstant 			; get decimal constant
.e1fa	80 34		bra $e230			bra 	_EVALGotAtom 				; got atom.
.e1fc					_EVALString:
.e1fc	da		phx				phx 								; save X on stack
.e1fd	a9 22		lda #$22			lda 	#StringBuffer >> 8 			; set the address in the eval stack
.e1ff	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e202	ad 9d 20	lda $209d			lda 	StringBufferPos 			; X = Buffer Position.
.e205	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; that's the address of the new string
.e208	aa		tax				tax 								; put in X to build the string.
.e209	c8		iny				iny 								; skip over opening quote character
.e20a					_EVALStringCopy:
.e20a	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character.
.e20c	c8		iny				iny
.e20d	f0 82		beq $e191			beq		EvaluateMissingQuote 		; if zero, then there was no closing quote.
.e20f	9d 00 22	sta $2200,x			sta 	StringBuffer,x 				; copy into the buffer
.e212	e8		inx				inx 								; and bump that pointer.
.e213	f0 8d		beq $e1a2			beq 	EvaluateStringFull 			; buffer is full.
.e215	49 81		eor #$81			eor 	#KW_DQUOTE					; keep going if not closing quote.
.e217	d0 f1		bne $e20a			bne 	_EVALStringCopy
.e219	8e 9d 20	stx $209d			stx 	StringBufferPos 			; this is the new next free slot.
.e21c	9d ff 21	sta $21ff,x			sta 	StringBuffer-1,x 			; write the zero (EOS) hence EOR to end string.
.e21f	fa		plx				plx 								; restore X
.e220	80 0e		bra $e230			bra 	_EVALGotAtom 				; got the atom.
.e222					_EVALHexaDecimal
.e222	c8		iny				iny 								; skip over the '#'
.e223	5a		phy				phy 								; save Y
.e224	20 42 e3	jsr $e342			jsr 	EVALGetHexConstant 			; load in hexadecimal constant
.e227	8c 98 20	sty $2098			sty 	Temp1 						; has Y changed ?
.e22a	68		pla				pla
.e22b	cd 98 20	cmp $2098			cmp 	Temp1
.e22e	f0 88		beq $e1b8			beq 	EvaluateBadHex 				; if not, error.
.e230					_EVALGotAtom:
.e230					_EVALGetOperator:
.e230	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token skip spaces.
.e232	c8		iny				iny 								; this should be binary operator
.e233	c9 20		cmp #$20			cmp 	#$20
.e235	f0 f9		beq $e230			beq 	_EVALGetOperator
.e237	88		dey				dey
.e238	09 00		ora #$00			ora 	#0 							; to be a binary token must be -ve
.e23a	10 3b		bpl $e277			bpl 	_EVALExitPullA 				; if +ve then exit now.
.e23c	da		phx				phx 								; save X
.e23d	aa		tax				tax 								; token in X
.e23e	bd 6a e0	lda $e06a,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e241	8d 98 20	sta $2098			sta 	Temp1 						; save precedence in Temp1
.e244	fa		plx				plx 								; restore X
.e245	c9 08		cmp #$08			cmp 	#8 							; if type >= 8, e.g. not binary, then exit.
.e247	b0 2e		bcs $e277			bcs 	_EVALExitPullA
.e249	68		pla				pla 								; get and save precedence level.
.e24a	48		pha				pha
.e24b	cd 98 20	cmp $2098			cmp 	Temp1 						; compare operator precedence - keyword precedence level.
.e24e	f0 02		beq $e252			beq 	_EVALDoCalc					; equal, do it.
.e250	b0 25		bcs $e277			bcs 	_EVALExitPullA				; too high, then exit.
.e252					_EVALDoCalc:
.e252	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token, save on stack and skip it.
.e254	c8		iny				iny
.e255	48		pha				pha
.e256	da		phx				phx
.e257	e8		inx				inx 								; work out right hand side.
.e258	e8		inx				inx
.e259	e8		inx				inx
.e25a	e8		inx				inx
.e25b	ad 98 20	lda $2098			lda 	Temp1 						; get current operator precedence level.
.e25e	1a		inc a				inc 	a 							; so work it out at the next level.
.e25f	20 cb e1	jsr $e1cb			jsr 	EvaluateAtPrecedenceLevel 	; work out the RHS.
.e262	fa		plx				plx 								; fix X back.
.e263	68		pla				pla 								; get keyword
.e264					_EVALExecuteA:
.e264	0a		asl a				asl 	a 							; shift left, drop bit 7
.e265	8d 99 20	sta $2099			sta 	Temp1+1						; save in Temp1.1
.e268	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.e26a	8d 9a 20	sta $209a			sta 	Temp1+2 					; set at Temp1.2
.e26d	a9 6c		lda #$6c			lda 	#$6C 						; make JMP (xxxx)
.e26f	8d 98 20	sta $2098			sta 	Temp1+0
.e272	20 98 20	jsr $2098			jsr 	Temp1 						; call that routine.
.e275	80 b9		bra $e230			bra 	_EVALGotAtom 				; and loop back again.
.e277					_EVALExitPullA:
.e277	68		pla				pla 								; restore precedence.
.e278	60		rts				rts
.e279					_EVALKeywordVariable:
.e279	09 00		ora #$00			ora 	#0 							; check bit 7
.e27b	10 0f		bpl $e28c			bpl 	_EVALNotUnaryFunction 		; must be set for unary function
.e27d	da		phx				phx
.e27e	aa		tax				tax
.e27f	bd 6a e0	lda $e06a,x			lda 	TokenTypeInformation-128,x 	; get the type info for it
.e282	fa		plx				plx
.e283	c9 09		cmp #$09			cmp 	#KTYPE_UNARYFN 				; is it a unary function
.e285	d0 05		bne $e28c			bne 	_EVALNotUnaryFunction
.e287	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get the token back
.e289	c8		iny				iny 								; consume it
.e28a	80 d8		bra $e264			bra 	_EVALExecuteA 				; execute TOS.
.e28c					_EVALNotUnaryFunction:
.e28c	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.e28e	10 3d		bpl $e2cd			bpl 	_EVALCheckVariable 			; if ASCII check variable
.e290	c9 8b		cmp #$8b			cmp 	#KW_MINUS 					; check negation
.e292	f0 0f		beq $e2a3			beq 	_EVALUnaryNegation
.e294	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; check left bracket.
.e296	d0 14		bne $e2ac			bne		_EVALCheckUnaryOperator
.e298	c8		iny				iny 								; skip left bracket.
.e299	20 c9 e1	jsr $e1c9			jsr 	EvaluateBaseCurrentLevel 	; calculate what's in the bracket.
.e29c	a9 88		lda #$88			lda 	#KW_RPAREN 					; check right bracket.
.e29e	20 6b e1	jsr $e16b			jsr 	CheckNextCharacter 			; check next character, after spaces.
.e2a1	80 8d		bra $e230			bra 	_EVALGotAtom
.e2a3					_EVALUnaryNegation:
.e2a3	c8		iny				iny 								; skip over the - sign.
.e2a4	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; calculate what's being negatived (...)
.e2a7	20 db e8	jsr $e8db			jsr 	BFUNC_NegateAlways 			; negate it.
.e2aa	80 84		bra $e230			bra 	_EVALGotAtom
.e2ac					_EVALCheckUnaryOperator:
.e2ac	48		pha				pha 								; save indirection operator.
.e2ad	c8		iny				iny 								; skip over the operator
.e2ae	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; calculate the address.
.e2b1	68		pla				pla 								; restore the operator
.e2b2	c9 83		cmp #$83			cmp 	#KW_DOLLAR					; $ is for visual typing, it does nothing
.e2b4	f0 0e		beq $e2c4			beq 	_EVALGoGotAtom
.e2b6	c9 95		cmp #$95			cmp 	#KW_QUESTION				; byte indirection
.e2b8	f0 07		beq $e2c1			beq 	_EVALByteRead
.e2ba	c9 80		cmp #$80			cmp 	#KW_PLING					; word indirection
.e2bc	f0 09		beq $e2c7			beq 	_EVALWordRead
.e2be	4c 1f e1	jmp $e11f			jmp 	SyntaxError 				; give up.
.e2c1					_EVALByteRead:
.e2c1	20 81 e3	jsr $e381			jsr 	EVALReadByteIndirect
.e2c4					_EVALGoGotAtom:
.e2c4	4c 30 e2	jmp $e230			jmp 	_EVALGotAtom
.e2c7					_EVALWordRead:
.e2c7	20 aa e3	jsr $e3aa			jsr 	EVALReadWordIndirect
.e2ca	4c 30 e2	jmp $e230			jmp 	_EVALGotAtom
.e2cd					_EVALCheckVariable:
.e2cd	20 da e3	jsr $e3da			jsr 	VARReference 				; get variable reference to ZTemp1
.e2d0	20 be e3	jsr $e3be			jsr 	EVALReadWordIndirectZTemp	; read that address into current stack level.
.e2d3	4c 30 e2	jmp $e230			jmp 	_EVALGotAtom 				; and go round.
.e2d6					EVALGetDecConstant:
.e2d6	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e2d8	c9 30		cmp #$30			cmp 	#'0'						; check in range 0-9.
.e2da	90 04		bcc $e2e0			bcc 	_EVGDExit
.e2dc	c9 3a		cmp #$3a			cmp 	#'9'+1
.e2de	90 01		bcc $e2e1			bcc 	_EVGDValue 					; if so has legal value
.e2e0					_EVGDExit:
.e2e0	60		rts				rts
.e2e1					_EVGDValue:
.e2e1	48		pha				pha 								; save value, Y on stack
.e2e2	5a		phy				phy
.e2e3	a0 03		ldy #$03			ldy 	#3 							; 3 shifts.
.e2e5	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; push x1 value on stack.
.e2e8	48		pha				pha
.e2e9	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e2ec	48		pha				pha
.e2ed	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e2f0	48		pha				pha
.e2f1	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e2f4	48		pha				pha
.e2f5					_EVGDLoop:
.e2f5	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; rotate left once.
.e2f8	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e2fb	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e2fe	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e301	c0 02		cpy #$02			cpy 	#2 							; if done it twice now
.e303	d0 1d		bne $e322			bne 	_EVGDNoAdd
.e305	18		clc				clc 								; then it will be x 4, adding +1 => x 5
.e306	68		pla				pla
.e307	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e30a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e30d	68		pla				pla
.e30e	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e311	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e314	68		pla				pla
.e315	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e318	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e31b	68		pla				pla
.e31c	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e31f	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e322					_EVGDNoAdd:
.e322	88		dey				dey
.e323	d0 d0		bne $e2f5			bne 	_EVGDLoop
.e325	7a		ply				ply 								; restore YA
.e326	68		pla				pla
.e327	c8		iny				iny 								; next character
.e328	29 0f		and #$0f			and 	#15 						; force into range and put in.
.e32a	18		clc				clc
.e32b	7d 00 04	adc $0400,x			adc 	evalStack+0,x 				; add digit in
.e32e	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e331	90 a3		bcc $e2d6			bcc 	EVALGetDecConstant 			; propogate constant through
.e333	fe 01 04	inc $0401,x			inc 	evalStack+1,x
.e336	d0 9e		bne $e2d6			bne 	EVALGetDecConstant
.e338	fe 02 04	inc $0402,x			inc 	evalStack+2,x
.e33b	d0 99		bne $e2d6			bne 	EVALGetDecConstant
.e33d	fe 03 04	inc $0403,x			inc 	evalStack+3,x
.e340	80 94		bra $e2d6			bra 	EVALGetDecConstant 			; go back and try again.
.e342					EVALGetHexConstant:
.e342	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next
.e344	20 76 e3	jsr $e376			jsr 	EVALToUpper 				; make upper case
.e347	38		sec				sec
.e348	e9 30		sbc #$30			sbc 	#"0" 						; range 0-9
.e34a	90 0a		bcc $e356			bcc 	_EVGHExit 					; exit if CC
.e34c	c9 0a		cmp #$0a			cmp 	#9+1 						; if < 9 have a legal value.
.e34e	90 07		bcc $e357			bcc 	_EVGHValue
.e350	e9 07		sbc #$07			sbc 	#7 							; now in range 10-15 if okay.
.e352	c9 10		cmp #$10			cmp 	#15+1
.e354	90 01		bcc $e357			bcc 	_EVGHValue
.e356					_EVGHExit:
.e356	60		rts				rts
.e357					_EVGHValue:
.e357	5a		phy				phy 								; save Y and new digit.
.e358	48		pha				pha
.e359	a0 04		ldy #$04			ldy 	#4 							; rotate left 4
.e35b					_EVGHRotate:
.e35b	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e35e	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e361	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e364	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e367	88		dey				dey
.e368	d0 f1		bne $e35b			bne 	_EVGHRotate
.e36a	68		pla				pla 								; restore digit and X
.e36b	7a		ply				ply
.e36c	c8		iny				iny 								; next character
.e36d	18		clc				clc
.e36e	1d 00 04	ora $0400,x			ora 	evalStack+0,x 				; add digit in
.e371	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e374	80 cc		bra $e342			bra 	EVALGetHexConstant 			; go back and try again.
.e376					EVALToUpper:
.e376	c9 61		cmp #$61			cmp 	#'a'
.e378	90 06		bcc $e380			bcc 	_EVTUExit
.e37a	c9 7b		cmp #$7b			cmp 	#'z'+1
.e37c	b0 02		bcs $e380			bcs 	_EVTUExit
.e37e	49 20		eor #$20			eor 	#32
.e380					_EVTUExit:
.e380	60		rts				rts
.e381					EVALReadByteIndirect:
.e381	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e384	85 26		sta $26				sta 	zTemp1
.e386	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e389	85 27		sta $27				sta 	zTemp1+1
.e38b	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e38e	85 28		sta $28				sta 	zTemp1+2
.e390	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e393	85 29		sta $29				sta 	zTemp1+3
.e395	5a		phy				phy
.e396	a0 00		ldy #$00			ldy 	#0 							; read byte
.e398	b1 26		lda ($26),y			lda 	(zTemp1),y
.e39a	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e39d	7a		ply				ply
.e39e	a9 00		lda #$00			lda 	#0 							; zero upper three bytes
.e3a0	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3a3	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3a6	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3a9	60		rts				rts
.e3aa					EVALReadWordIndirect:
.e3aa	bd 00 04	lda $0400,x			lda 	evalStack+0,x 	 			; copy address over.
.e3ad	85 26		sta $26				sta 	zTemp1
.e3af	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e3b2	85 27		sta $27				sta 	zTemp1+1
.e3b4	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e3b7	85 28		sta $28				sta 	zTemp1+2
.e3b9	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e3bc	85 29		sta $29				sta 	zTemp1+3
.e3be					EVALReadWordIndirectZTemp:
.e3be	5a		phy				phy
.e3bf	a0 00		ldy #$00			ldy 	#0 							; read word
.e3c1	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3c3	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e3c6	c8		iny				iny
.e3c7	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3c9	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e3cc	c8		iny				iny
.e3cd	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3cf	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e3d2	c8		iny				iny
.e3d3	b1 26		lda ($26),y			lda 	(zTemp1),y
.e3d5	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e3d8	7a		ply				ply
.e3d9	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: general/variable.asm

.e3da					VARReference:
.e3da	38		sec				sec 								; check range @-Z there
.e3db	c9 40		cmp #$40			cmp 	#'@'
.e3dd	90 04		bcc $e3e3			bcc 	_VARRError
.e3df	c9 5b		cmp #$5b			cmp 	#'Z'+1 						; there are 27 variables @ and A-Z
.e3e1	90 03		bcc $e3e6			bcc 	_VARROkay
.e3e3					_VARRError:
.e3e3	4c 1f e1	jmp $e11f			jmp		SyntaxError
.e3e6					_VARROkay:
.e3e6	c8		iny				iny 								; consume the variable.
.e3e7	d1 20		cmp ($20),y			cmp 	(zCurrentLine),y 			; is it @@ AA BB CC ?
.e3e9	f0 1b		beq $e406			beq 	_VARArrayAccess 			; array access AA0 AA1 etc.
.e3eb	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get that second character
.e3ed	88		dey				dey 								; point back to the first character
.e3ee	c9 87		cmp #$87			cmp 	#KW_LPAREN 					; if ( then it is A(x) format.
.e3f0	f0 14		beq $e406			beq 	_VARArrayAccess
.e3f2	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; reget variable.
.e3f4	c8		iny				iny
.e3f5	29 1f		and #$1f			and		#31 						; mask out
.e3f7	0a		asl a				asl 	a 							; x 4
.e3f8	0a		asl a				asl 	a
.e3f9	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e3fb	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e3fd	85 27		sta $27				sta 	zTemp1+1
.e3ff	a9 00		lda #$00			lda 	#0 							; clear upper bytes
.e401	85 28		sta $28				sta 	zTemp1+2
.e403	85 29		sta $29				sta 	zTemp1+3 					; return with address set.
.e405	60		rts				rts
.e406					_VARArrayAccess:
.e406	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get variable
.e408	c8		iny				iny
.e409	29 1f		and #$1f			and 	#31 						; mask it off
.e40b	48		pha				pha 								; save on the stack.
.e40c	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; calculate the index.
.e40f	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; multiply by four.
.e412	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e415	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e418	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e41b	1e 00 04	asl $0400,x			asl 	evalStack+0,x
.e41e	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e421	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e424	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e427	68		pla				pla 								; put address in zTemp1
.e428	0a		asl a				asl 	a 							; x 4
.e429	0a		asl a				asl 	a
.e42a	85 26		sta $26				sta 	zTemp1+0 					; rely on variables being page aligned.
.e42c	a9 20		lda #$20			lda 	#FixedVariables >> 8
.e42e	85 27		sta $27				sta 	zTemp1+1
.e430	5a		phy				phy
.e431	a0 00		ldy #$00			ldy 	#0 							; calculate	evalStack+0,3 + (zTemp)
.e433	b1 26		lda ($26),y			lda 	(zTemp1),y
.e435	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.e438	48		pha				pha 								; save first result as we need the indirection.
.e439	c8		iny				iny 								; 2nd byte
.e43a	b1 26		lda ($26),y			lda 	(zTemp1),y
.e43c	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.e43f	85 27		sta $27				sta 	zTemp1+1
.e441	68		pla				pla 								; save the low byte.
.e442	85 26		sta $26				sta 	zTemp1+0
.e444	a9 00		lda #$00			lda 	#0
.e446	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.e449	85 28		sta $28				sta 	zTemp1+2
.e44b	a9 00		lda #$00			lda 	#0
.e44d	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.e450	85 29		sta $29				sta 	zTemp1+3
.e452	7a		ply				ply 								; restore Y, address setup
.e453	60		rts				rts
.e454	80 fe		bra $e454	x1:		bra 	x1

;******  Return to file: basic.asm


;******  Processing file: general/screenio.asm

.e456					SIOInitialise:
.e456	20 82 a0	jsr $a082			jsr 	EXTReset 					; reset video
.e459					SIOClearScreen:
.e459	20 38 a0	jsr $a038			jsr 	EXTClearScreen 				; clear screen
.e45c					SIOHomeCursor:
.e45c	48		pha				pha 								; home cursor
.e45d	a9 00		lda #$00			lda 	#0
.e45f	8d a0 20	sta $20a0			sta 	xCursor
.e462	8d a1 20	sta $20a1			sta 	yCursor
.e465	68		pla				pla
.e466	60		rts				rts
.e467					SIOPrintString:
.e467	48		pha				pha 								; save registers
.e468	da		phx				phx
.e469	5a		phy				phy
.e46a	86 28		stx $28				stx 	zTemp2 						; set up indirect pointer
.e46c	84 29		sty $29				sty 	zTemp2+1
.e46e	a0 00		ldy #$00			ldy 	#0
.e470					_SIOPSLoop:
.e470	b1 28		lda ($28),y			lda 	(zTemp2),y 					; read next, exit if 0
.e472	f0 1c		beq $e490			beq 	_SIOPSExit
.e474	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter 			; print and bump
.e477	c8		iny				iny
.e478	d0 f6		bne $e470			bne 	_SIOPSLoop
.e47a	20 2f e1	jsr $e12f			jsr 	ReportError
>e47d	42 41 44 20 53 54 52 49				.text 	"BAD STRING PRINTED",$00
>e485	4e 47 20 50 52 49 4e 54 45 44 00
.e490					_SIOPSExit:
.e490	7a		ply				ply 								; restore and exit.
.e491	fa		plx				plx
.e492	68		pla				pla
.e493	60		rts				rts
.e494					SIOPrintCharacter:
.e494	48		pha				pha 								; save AXY
.e495	da		phx				phx
.e496	5a		phy				phy
.e497	c9 0d		cmp #$0d			cmp 	#13 						; CR ?
.e499	f0 12		beq $e4ad			beq 	_SIOPReturn
.e49b	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor 				; load cursor position in.
.e49e	29 3f		and #$3f			and 	#$3F 						; PETSCII conversion
.e4a0	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen 				; write character out.
.e4a3	ee a0 20	inc $20a0			inc 	xCursor 					; move right
.e4a6	ad a0 20	lda $20a0			lda 	xCursor 					; reached the RHS
.e4a9	c9 28		cmp #$28			cmp 	#EXTWidth
.e4ab	90 15		bcc $e4c2			bcc 	_SIOPExit
.e4ad					_SIOPReturn:
.e4ad	a9 00		lda #$00			lda 	#0 							; zero x
.e4af	8d a0 20	sta $20a0			sta 	xCursor
.e4b2	ee a1 20	inc $20a1			inc 	yCursor 					; go down
.e4b5	ad a1 20	lda $20a1			lda 	yCursor
.e4b8	c9 19		cmp #$19			cmp 	#EXTHeight 					; off the bottom ?
.e4ba	90 06		bcc $e4c2			bcc 	_SIOPExit
.e4bc	20 50 a0	jsr $a050			jsr 	EXTScrollDisplay 			; scroll display up
.e4bf	ce a1 20	dec $20a1			dec 	yCursor 					; cursor on bottom line.
.e4c2					_SIOPExit:
.e4c2	7a		ply				ply 								; restore and exit.
.e4c3	fa		plx				plx
.e4c4	68		pla				pla
.e4c5	60		rts				rts
.e4c6					SIOGetKey:
.e4c6	20 0c a0	jsr $a00c			jsr 	EXTReadKeyPort 				; wait for a key
.e4c9	f0 fb		beq $e4c6			beq 	SIOGetKey
.e4cb	20 76 e3	jsr $e376			jsr 	EVALToUpper 				; capitalise it.
.e4ce	4c 12 a0	jmp $a012			jmp 	EXTRemoveKeyPressed 		; remove from the queue.
.e4d1					SIOReadLine:
.e4d1	48		pha				pha 								; save registers
.e4d2	da		phx				phx
.e4d3	5a		phy				phy
.e4d4					_SIORLoop:
.e4d4	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor 				; cursor in XY
.e4d7	20 1e a0	jsr $a01e			jsr 	EXTReadScreen 				; read the display.
.e4da	48		pha				pha 								; save on stack.
.e4db	a9 66		lda #$66			lda 	#102 						; write cursor out
.e4dd	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e4e0	20 c6 e4	jsr $e4c6			jsr 	SIOGetKey
.e4e3	aa		tax				tax 								; save in X
.e4e4	68		pla				pla 								; old character
.e4e5	da		phx				phx 								; save key pressed
.e4e6	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor 				; cursor in XY
.e4e9	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e4ec	68		pla				pla
.e4ed	c9 01		cmp #$01			cmp 	#"A"-64 					; control characters
.e4ef	f0 29		beq $e51a			beq 	_SIOCursorLeft
.e4f1	c9 13		cmp #$13			cmp 	#"S"-64
.e4f3	f0 49		beq $e53e			beq 	_SIOCursorDown
.e4f5	c9 04		cmp #$04			cmp 	#"D"-64
.e4f7	f0 2d		beq $e526			beq 	_SIOCursorRight
.e4f9	c9 17		cmp #$17			cmp 	#"W"-64
.e4fb	f0 35		beq $e532			beq 	_SIOCursorUp
.e4fd	c9 1a		cmp #$1a			cmp 	#"Z"-64
.e4ff	f0 49		beq $e54a			beq 	_SIOClearScreen
.e501	c9 08		cmp #$08			cmp 	#"H"-64
.e503	f0 4a		beq $e54f			beq 	_SIOBackspace
.e505	c9 0d		cmp #$0d			cmp 	#13 						; CR
.e507	f0 0e		beq $e517			beq 	_SIOGoReturn
.e509	c9 20		cmp #$20			cmp 	#32 						; any control
.e50b	90 c7		bcc $e4d4			bcc 	_SIORLoop
.e50d	48		pha				pha
.e50e	20 8f e5	jsr $e58f			jsr 	_SIOInsert 					; insert a space for new character
.e511	68		pla				pla
.e512	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter 			; print character in A
.e515	80 bd		bra $e4d4			bra 	_SIORLoop
.e517					_SIOGoReturn:
.e517	4c ba e5	jmp $e5ba			jmp 	_SIOReturn
.e51a					_SIOCursorLeft:
.e51a	ce a0 20	dec $20a0			dec 	xCursor
.e51d	10 b5		bpl $e4d4			bpl 	_SIORLoop
.e51f	a9 27		lda #$27			lda 	#EXTWidth-1
.e521					_SIOWXLoop:
.e521	8d a0 20	sta $20a0			sta 	xCursor
.e524	80 ae		bra $e4d4			bra 	_SIORLoop
.e526					_SIOCursorRight:
.e526	ee a0 20	inc $20a0			inc 	xCursor
.e529	ad a0 20	lda $20a0			lda 	xCursor
.e52c	49 28		eor #$28			eor 	#EXTWidth
.e52e	d0 a4		bne $e4d4			bne 	_SIORLoop
.e530	80 ef		bra $e521			bra 	_SIOWXLoop
.e532					_SIOCursorUp:
.e532	ce a1 20	dec $20a1			dec 	yCursor
.e535	10 9d		bpl $e4d4			bpl 	_SIORLoop
.e537	a9 18		lda #$18			lda 	#EXTHeight-1
.e539					_SIOWYLoop:
.e539	8d a1 20	sta $20a1			sta 	yCursor
.e53c	80 96		bra $e4d4			bra 	_SIORLoop
.e53e					_SIOCursorDown:
.e53e	ee a1 20	inc $20a1			inc 	yCursor
.e541	ad a1 20	lda $20a1			lda 	yCursor
.e544	49 19		eor #$19			eor 	#EXTHeight
.e546	d0 8c		bne $e4d4			bne 	_SIORLoop
.e548	80 ef		bra $e539			bra 	_SIOWYLoop
.e54a					_SIOClearScreen:
.e54a	20 59 e4	jsr $e459			jsr 	SIOClearScreen
.e54d	80 85		bra $e4d4			bra 	_SIORLoop
.e54f					_SIOBackspace:
.e54f	ad a0 20	lda $20a0			lda 	xCursor 					; backspace possible ?
.e552	f0 80		beq $e4d4			beq 	_SIORLoop 					; start of line, no.
.e554	48		pha				pha 								; save position.
.e555	c9 27		cmp #$27			cmp 	#EXTWidth-1 				; not required
.e557	f0 1c		beq $e575			beq 	_SIONoShift
.e559					_SIOShift2:
.e559	ee a0 20	inc $20a0			inc 	xCursor 					; copy character backward
.e55c	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e55f	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e562	ce a0 20	dec $20a0			dec 	xCursor
.e565	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e568	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e56b	ee a0 20	inc $20a0			inc 	xCursor
.e56e	ad a0 20	lda $20a0			lda 	xCursor
.e571	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e573	d0 e4		bne $e559			bne 	_SIOShift2
.e575					_SIONoShift:
.e575	a9 27		lda #$27			lda 	#EXTWidth-1 				; space on far end.
.e577	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e57a	a9 20		lda #$20			lda 	#32
.e57c	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e57f	68		pla				pla 								; restore cursor, back one.
.e580	3a		dec a				dec 	a
.e581	8d a0 20	sta $20a0			sta 	xCursor
.e584	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor 				; overwrite
.e587	a9 20		lda #$20			lda 	#32
.e589	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e58c	4c d4 e4	jmp $e4d4			jmp	 	_SIORLoop
.e58f					_SIOInsert:
.e58f	ad a0 20	lda $20a0			lda 	xCursor 					; at far right, nothing to do.
.e592	c9 27		cmp #$27			cmp 	#EXTWidth-1
.e594	f0 23		beq $e5b9			beq 	_SIOIExit
.e596	85 28		sta $28				sta 	zTemp2 						; save in temporary workspace.
.e598	a9 27		lda #$27			lda 	#EXTWidth-1 				; cursor at far right.
.e59a	8d a0 20	sta $20a0			sta 	xCursor
.e59d					_SIOShift:
.e59d	ce a0 20	dec $20a0			dec 	xCursor 					; copy character forward
.e5a0	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e5a3	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5a6	ee a0 20	inc $20a0			inc 	xCursor
.e5a9	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e5ac	20 2c a0	jsr $a02c			jsr 	EXTWriteScreen
.e5af	ce a0 20	dec $20a0			dec 	xCursor
.e5b2	ad a0 20	lda $20a0			lda 	xCursor						; until shifted line to this point.
.e5b5	c5 28		cmp $28				cmp 	zTemp2
.e5b7	d0 e4		bne $e59d			bne 	_SIOShift
.e5b9					_SIOIExit:
.e5b9	60		rts				rts
.e5ba					_SIOReturn:
.e5ba	a9 00		lda #$00			lda 	#0 							; copy line in from screen.
.e5bc	8d a0 20	sta $20a0			sta 	xCursor
.e5bf					_SIOCopy:
.e5bf	20 f4 e5	jsr $e5f4			jsr 	SIOLoadCursor
.e5c2	20 1e a0	jsr $a01e			jsr 	EXTReadScreen
.e5c5	49 20		eor #$20			eor 	#$20
.e5c7	18		clc				clc
.e5c8	69 20		adc #$20			adc 	#$20
.e5ca	ae a0 20	ldx $20a0			ldx 	xCursor
.e5cd	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e5d0	ee a0 20	inc $20a0			inc 	xCursor
.e5d3	ad a0 20	lda $20a0			lda 	xCursor
.e5d6	c9 28		cmp #$28			cmp 	#EXTWidth
.e5d8	d0 e5		bne $e5bf			bne 	_SIOCopy
.e5da	aa		tax				tax 								; X contains width
.e5db					_SIOStrip:
.e5db	ca		dex				dex									; back one
.e5dc	30 07		bmi $e5e5			bmi		_SIOFound 					; if -ve gone too far
.e5de	bd 6d 20	lda $206d,x			lda 	InputLine,x 				; is there a space here
.e5e1	c9 20		cmp #$20			cmp 	#' '
.e5e3	f0 f6		beq $e5db			beq 	_SIOStrip
.e5e5					_SIOFound:
.e5e5	e8		inx				inx
.e5e6	a9 00		lda #$00			lda 	#0 							; make ASCIIZ
.e5e8	9d 6d 20	sta $206d,x			sta 	InputLine,x
.e5eb	a9 0d		lda #$0d			lda 	#13 						; print a CR and exit
.e5ed	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.e5f0	7a		ply				ply
.e5f1	fa		plx				plx
.e5f2	68		pla				pla
.e5f3	60		rts				rts
.e5f4					SIOLoadCursor:
.e5f4	48		pha				pha
.e5f5	ad a1 20	lda $20a1			lda 	yCursor  					; Y Position
.e5f8	0a		asl a				asl 	a 							; x 2 	(80)
.e5f9	0a		asl a				asl 	a 							; x 2 	(160)
.e5fa	6d a1 20	adc $20a1			adc 	yCursor 					; x 5 	(200) (CC)
.e5fd	85 26		sta $26				sta 	zTemp1
.e5ff	a9 00		lda #$00			lda 	#0
.e601	85 27		sta $27				sta 	zTemp1+1
.e603	06 26		asl $26				asl 	zTemp1						; x 10
.e605	26 27		rol $27				rol 	zTemp1+1
.e607	06 26		asl $26				asl 	zTemp1						; x 20
.e609	26 27		rol $27				rol 	zTemp1+1
.e60b	06 26		asl $26				asl 	zTemp1						; x 40
.e60d	26 27		rol $27				rol 	zTemp1+1 					; (CC)
.e60f	a5 26		lda $26				lda 	zTemp1 						; add X
.e611	6d a0 20	adc $20a0			adc 	xCursor
.e614	aa		tax				tax
.e615	a5 27		lda $27				lda 	zTemp1+1
.e617	69 00		adc #$00			adc 	#0
.e619	a8		tay				tay
.e61a	68		pla				pla 								; restore and exit
.e61b	60		rts				rts
.e61c					SIOPrintHex:
.e61c	48		pha				pha
.e61d	48		pha				pha
.e61e	a9 20		lda #$20			lda 	#32
.e620	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.e623	68		pla				pla
.e624	48		pha				pha
.e625	4a		lsr a				lsr 	a
.e626	4a		lsr a				lsr 	a
.e627	4a		lsr a				lsr 	a
.e628	4a		lsr a				lsr 	a
.e629	20 32 e6	jsr $e632			jsr 	_SIOPHex
.e62c	68		pla				pla
.e62d	20 32 e6	jsr $e632			jsr 	_SIOPHex
.e630	68		pla				pla
.e631	60		rts				rts
.e632					_SIOPHex:
.e632	29 0f		and #$0f			and 	#15
.e634	c9 0a		cmp #$0a			cmp 	#10
.e636	90 02		bcc $e63a			bcc 	_SIOPHex2
.e638	69 06		adc #$06			adc 	#6
.e63a					_SIOPHex2:
.e63a	69 30		adc #$30			adc 	#48
.e63c	4c 94 e4	jmp $e494			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: general/tokeniser.asm

.e63f					TokeniseString:
.e63f	a0 00		ldy #$00			ldy 	#0							; source
.e641	a2 00		ldx #$00			ldx 	#0 							; target
.e643					_TokLoop:
.e643	b1 26		lda ($26),y			lda 	(zTemp1),y 					; get first
.e645	f0 5d		beq $e6a4			beq 	_TokExit 					; End, exit.
.e647	c9 20		cmp #$20			cmp 	#32 						; if space, copy it
.e649	f0 35		beq $e680			beq 	_TokCopy1
.e64b	c9 22		cmp #$22			cmp 	#'"' 						; if string, copy that in.
.e64d	f0 3a		beq $e689			beq 	_TokCopyString
.e64f	c9 30		cmp #$30			cmp 	#"0" 						; punctuation, search for it.
.e651	90 22		bcc $e675			bcc 	_TokPunctuation
.e653	c9 3a		cmp #$3a			cmp 	#"9"+1 						; digits are just copied over.
.e655	90 29		bcc $e680			bcc 	_TokCopy1
.e657	c9 41		cmp #$41			cmp 	#"A"						; more punctuation
.e659	90 1a		bcc $e675			bcc 	_TokPunctuation
.e65b	c9 5b		cmp #$5b			cmp 	#"Z"+1 						; and more punctuation
.e65d	b0 16		bcs $e675			bcs 	_TokPunctuation
.e65f					_TokWord:
.e65f	20 aa e6	jsr $e6aa			jsr 	TokeniseSearch 				; search for tokenised word.
.e662	b0 16		bcs $e67a			bcs 	_TokFound 					; if successful, copy it out.
.e664					_TokSkip:
.e664	b1 26		lda ($26),y			lda 	(zTemp1),y 					; copy all A-Z as can't start token in mid word.
.e666	c9 41		cmp #$41			cmp 	#"A"
.e668	90 d9		bcc $e643			bcc 	_TokLoop
.e66a	c9 5b		cmp #$5b			cmp 	#"Z"+1
.e66c	b0 d5		bcs $e643			bcs 	_TokLoop
.e66e	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e671	e8		inx				inx
.e672	c8		iny				iny
.e673	80 ef		bra $e664			bra 	_TokSkip
.e675					_TokPunctuation:
.e675	20 aa e6	jsr $e6aa			jsr 	TokeniseSearch 				; find it.
.e678	90 06		bcc $e680			bcc 	_TokCopy1 					; if found, just copy 1 character
.e67a					_TokFound:
.e67a	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; save in tokenise buffer.
.e67d	e8		inx				inx 								; advance target ; source is already advanced.
.e67e	80 c3		bra $e643			bra 	_TokLoop 					; do the next character.
.e680					_TokCopy1:
.e680	b1 26		lda ($26),y			lda 	(zTemp1),y
.e682	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e685	e8		inx				inx
.e686	c8		iny				iny
.e687	80 ba		bra $e643			bra 	_TokLoop
.e689					_TokCopyString:
.e689	a9 81		lda #$81			lda 	#KW_DQUOTE 					; output double quote token
.e68b	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e68e	e8		inx				inx 								; skip buffer and first quote.
.e68f	c8		iny				iny
.e690					_TokCSLoop:
.e690	b1 26		lda ($26),y			lda 	(zTemp1),y 					; get next character
.e692	f0 10		beq $e6a4			beq 	_TokExit 					; if EOL, then you have a mismatch, but we exit.
.e694	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x 			; write to buffer
.e697	e8		inx				inx 								; advance both.
.e698	c8		iny				iny
.e699	c9 22		cmp #$22			cmp 	#'"'						; keep going till other quote found.
.e69b	d0 f3		bne $e690			bne 	_TokCSLoop
.e69d	a9 81		lda #$81			lda 	#KW_DQUOTE 					; add the trailing quote token, overwriting the
.e69f	9d ff 20	sta $20ff,x			sta 	TokeniseBuffer-1,x 			; " character that's just been copied
.e6a2	80 9f		bra $e643			bra 	_TokLoop
.e6a4					_TokExit:
.e6a4	a9 00		lda #$00			lda 	#0 							; mark the end of the tokenise buffer.
.e6a6	9d 00 21	sta $2100,x			sta 	TokeniseBuffer,x
.e6a9	60		rts				rts
.e6aa					TokeniseSearch:
.e6aa	48		pha				pha 								; save AXY
.e6ab	da		phx				phx
.e6ac	5a		phy				phy
.e6ad	a9 80		lda #$80			lda 	#128 						; zTemp2 keeps track of the token #
.e6af	85 28		sta $28				sta 	zTemp2
.e6b1	a2 00		ldx #$00			ldx 	#0 							; index into TokenText table.
.e6b3	bd 6a e0	lda $e06a,x	_TSNext:lda 	TokenText,x 				; get the first token character
.e6b6	29 7f		and #$7f			and 	#$7F 						; bit 7 marks the end.
.e6b8	d1 26		cmp ($26),y			cmp 	(zTemp1),y 					; do the characters match.
.e6ba	f0 13		beq $e6cf			beq 	_TSTryFullMatch 			; if so, try the full match.
.e6bc					_TSGotoNext:
.e6bc	bd 6a e0	lda $e06a,x			lda 	TokenText,x 				; read it
.e6bf	e8		inx				inx 								; bump index
.e6c0	0a		asl a				asl 	a 							; shift into C
.e6c1	90 f9		bcc $e6bc			bcc 	_TSGotoNext 				; keep going until read the end character
.e6c3	e6 28		inc $28				inc 	zTemp2 						; bump the current token pointer.
.e6c5	bd 6a e0	lda $e06a,x			lda 	TokenText,x 				; look at the first character of the next token
.e6c8	d0 e9		bne $e6b3			bne 	_TSNext 					; if non-zero, go to the next.
.e6ca					_TSFail:
.e6ca	7a		ply				ply 								; fail.
.e6cb	fa		plx				plx
.e6cc	68		pla				pla
.e6cd	18		clc				clc 				 				; return with carry clear.
.e6ce	60		rts				rts
.e6cf					_TSTryFullMatch:
.e6cf	da		phx				phx									; save X and Y.
.e6d0	5a		phy				phy
.e6d1					_TSFullMatch:
.e6d1	bd 6a e0	lda $e06a,x			lda 	TokenText,x 				; compare the 7 bits.
.e6d4	29 7f		and #$7f			and 	#$7F
.e6d6	d1 26		cmp ($26),y			cmp 	(zTemp1),y
.e6d8	d0 15		bne $e6ef			bne 	_TSFullFail 				; different, this one doesn't match.
.e6da	bd 6a e0	lda $e06a,x			lda 	TokenText,x
.e6dd	e8		inx				inx 								; advance to next character
.e6de	c8		iny				iny
.e6df	0a		asl a				asl 	a 							; bit 7 of token text in C
.e6e0	90 ef		bcc $e6d1			bcc 	_TSFullMatch
.e6e2	84 29		sty $29				sty 	zTemp2+1 					; save the Y after last
.e6e4	68		pla				pla 								; so we don't restore Y
.e6e5	68		pla				pla 								; or X from the full test.
.e6e6	7a		ply				ply 								; restore original Y and X and A
.e6e7	fa		plx				plx
.e6e8	68		pla				pla
.e6e9	a5 28		lda $28				lda 	zTemp2 						; and return token ID in A
.e6eb	a4 29		ldy $29				ldy 	zTemp2+1 					; Y after the tokenised text.
.e6ed	38		sec				sec 								; with carry set.
.e6ee	60		rts				rts
.e6ef					_TSFullFail:
.e6ef	7a		ply				ply 								; restore Y and X
.e6f0	fa		plx				plx
.e6f1	80 c9		bra $e6bc			bra 	_TSGotoNext 				; and go to the next token to test.
.e6f3					TokeniseTest:
.e6f3	a9 ff		lda #$ff			lda 	#TTString & $FF
.e6f5	85 26		sta $26				sta 	zTemp1
.e6f7	a9 e6		lda #$e6			lda 	#TTString >> 8
.e6f9	85 27		sta $27				sta 	zTemp1+1
.e6fb	20 3f e6	jsr $e63f			jsr 	TokeniseString
.e6fe	ea		nop				nop
.e6ff					TTString:
>e6ff	20 41 42 43 44 20 34 31				.text 	' ABCD 41$"LENA"5LENA',0 			; 4 1 $[T] "LENA" 5 LEN[T] A
>e707	24 22 4c 45 4e 41 22 35 4c 45 4e 41 00

;******  Return to file: basic.asm


;******  Processing file: binary/arithmetic.asm

.e714					BFUNC_Add:
.e714	18		clc				clc
.e715	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e718	7d 04 04	adc $0404,x			adc 	evalStack+4,x
.e71b	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e71e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e721	7d 05 04	adc $0405,x			adc 	evalStack+5,x
.e724	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e727	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e72a	7d 06 04	adc $0406,x			adc 	evalStack+6,x
.e72d	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e730	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e733	7d 07 04	adc $0407,x			adc 	evalStack+7,x
.e736	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e739	60		rts				rts
.e73a					BFUNC_Subtract:
.e73a	38		sec				sec
.e73b	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e73e	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e741	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e744	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e747	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e74a	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e74d	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e750	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e753	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e756	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e759	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e75c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e75f	60		rts				rts
.e760					BFUNC_String:
.e760	20 14 e7	jsr $e714			jsr 	BFUNC_Add
.e763	60		rts				rts
.e764					BFUNC_ByteInd:
.e764	20 14 e7	jsr $e714			jsr 	BFUNC_Add
.e767	20 81 e3	jsr $e381			jsr 	EVALReadByteIndirect
.e76a	60		rts				rts
.e76b					BFUNC_WordInd:
.e76b	20 14 e7	jsr $e714			jsr 	BFUNC_Add
.e76e	20 aa e3	jsr $e3aa			jsr 	EVALReadWordIndirect
.e771	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/binary.asm

.e772					BFUNC_And:
.e772	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e775	3d 04 04	and $0404,x			and 	evalStack+4,x
.e778	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e77b	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e77e	3d 05 04	and $0405,x			and 	evalStack+5,x
.e781	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e784	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e787	3d 06 04	and $0406,x			and 	evalStack+6,x
.e78a	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e78d	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e790	3d 07 04	and $0407,x			and 	evalStack+7,x
.e793	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e796	60		rts				rts
.e797					BFUNC_Or:
.e797	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e79a	1d 04 04	ora $0404,x			ora 	evalStack+4,x
.e79d	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e7a0	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e7a3	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e7a6	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e7a9	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e7ac	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e7af	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e7b2	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e7b5	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e7b8	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e7bb	60		rts				rts
.e7bc					BFUNC_Xor:
.e7bc	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.e7bf	5d 04 04	eor $0404,x			eor 	evalStack+4,x
.e7c2	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e7c5	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e7c8	5d 05 04	eor $0405,x			eor 	evalStack+5,x
.e7cb	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e7ce	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e7d1	5d 06 04	eor $0406,x			eor 	evalStack+6,x
.e7d4	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e7d7	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e7da	5d 07 04	eor $0407,x			eor 	evalStack+7,x
.e7dd	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e7e0	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/multiply.asm

.e7e1					BFUNC_Multiply:
.e7e1	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy +0 to +8
.e7e4	9d 08 04	sta $0408,x			sta 	evalStack+8,x
.e7e7	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e7ea	9d 09 04	sta $0409,x			sta 	evalStack+9,x
.e7ed	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.e7f0	9d 0a 04	sta $040a,x			sta 	evalStack+10,x
.e7f3	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e7f6	9d 0b 04	sta $040b,x			sta 	evalStack+11,x
.e7f9	a9 00		lda #$00			lda 	#0
.e7fb	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; zero +0
.e7fe	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e801	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e804	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e807					_BFMMultiply:
.e807	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; get LSBit of 8-11
.e80a	29 01		and #$01			and 	#1
.e80c	f0 03		beq $e811			beq 	_BFMNoAdd
.e80e	20 14 e7	jsr $e714			jsr 	BFunc_Add 					; if bit set, add 4 to 0.
.e811					_BFMNoAdd:
.e811	1e 04 04	asl $0404,x			asl 	evalStack+4,x 				; shift +4 left
.e814	3e 05 04	rol $0405,x			rol 	evalStack+5,x
.e817	3e 06 04	rol $0406,x			rol 	evalStack+6,x
.e81a	3e 07 04	rol $0407,x			rol 	evalStack+7,x
.e81d	5e 0b 04	lsr $040b,x			lsr 	evalStack+11,x 				; shift +8 right
.e820	7e 0a 04	ror $040a,x			ror 	evalStack+10,x
.e823	7e 09 04	ror $0409,x			ror 	evalStack+9,x
.e826	7e 08 04	ror $0408,x			ror 	evalStack+8,x
.e829	bd 08 04	lda $0408,x			lda 	evalStack+8,x 				; continue if +8 is nonzero
.e82c	1d 09 04	ora $0409,x			ora 	evalStack+9,x
.e82f	1d 0a 04	ora $040a,x			ora 	evalStack+10,x
.e832	1d 0b 04	ora $040b,x			ora 	evalStack+11,x
.e835	d0 d0		bne $e807			bne 	_BFMMultiply
.e837	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/divide.asm

.e838					BFUNC_Divide:
.e838	bd 04 04	lda $0404,x			lda 	evalStack+4,x 				; check for /0
.e83b	1d 05 04	ora $0405,x			ora 	evalStack+5,x
.e83e	1d 06 04	ora $0406,x			ora 	evalStack+6,x
.e841	1d 07 04	ora $0407,x			ora 	evalStack+7,x
.e844	d0 14		bne $e85a			bne 	_BFDOkay
.e846	20 2f e1	jsr $e12f			jsr 	ReportError
>e849	44 49 56 49 53 49 4f 4e				.text 	"DIVISION BY ZERO",$00
>e851	20 42 59 20 5a 45 52 4f 00
.e85a					_BFDOkay:
.e85a	a9 00		lda #$00			lda 	#0 							; Temp1 is 'A' (and holds the remainder)
.e85c	8d 98 20	sta $2098			sta 	Temp1 						; Q/Dividend/Left in +0
.e85f	8d 99 20	sta $2099			sta 	Temp1+1 					; M/Divisor/Right in +4
.e862	8d 9a 20	sta $209a			sta 	Temp1+2
.e865	8d 9b 20	sta $209b			sta 	Temp1+3
.e868	8d 9c 20	sta $209c			sta 	SignCount 					; Count of signs.
.e86b	20 d6 e8	jsr $e8d6			jsr 	BFUNC_Negate 				; negate (and bump sign count)
.e86e	da		phx				phx
.e86f	e8		inx				inx
.e870	e8		inx				inx
.e871	e8		inx				inx
.e872	e8		inx				inx
.e873	20 d6 e8	jsr $e8d6			jsr 	BFUNC_Negate
.e876	fa		plx				plx
.e877	5a		phy				phy 								; Y is the counter
.e878	a0 20		ldy #$20			ldy 	#32 						; 32 iterations of the loop.
.e87a					_BFDLoop:
.e87a	1e 00 04	asl $0400,x			asl 	evalStack+0,x 				; shift AQ left.
.e87d	3e 01 04	rol $0401,x			rol 	evalStack+1,x
.e880	3e 02 04	rol $0402,x			rol 	evalStack+2,x
.e883	3e 03 04	rol $0403,x			rol 	evalStack+3,x
.e886	2e 98 20	rol $2098			rol 	Temp1
.e889	2e 99 20	rol $2099			rol 	Temp1+1
.e88c	2e 9a 20	rol $209a			rol 	Temp1+2
.e88f	2e 9b 20	rol $209b			rol 	Temp1+3
.e892	38		sec				sec
.e893	ad 98 20	lda $2098			lda 	Temp1+0 					; Calculate A-M on stack.
.e896	fd 04 04	sbc $0404,x			sbc 	evalStack+4,x
.e899	48		pha				pha
.e89a	ad 99 20	lda $2099			lda 	Temp1+1
.e89d	fd 05 04	sbc $0405,x			sbc 	evalStack+5,x
.e8a0	48		pha				pha
.e8a1	ad 9a 20	lda $209a			lda 	Temp1+2
.e8a4	fd 06 04	sbc $0406,x			sbc 	evalStack+6,x
.e8a7	48		pha				pha
.e8a8	ad 9b 20	lda $209b			lda 	Temp1+3
.e8ab	fd 07 04	sbc $0407,x			sbc 	evalStack+7,x
.e8ae	90 19		bcc $e8c9			bcc 	_BFDNoAdd
.e8b0	8d 9b 20	sta $209b			sta 	Temp1+3 					; update A
.e8b3	68		pla				pla
.e8b4	8d 9a 20	sta $209a			sta 	Temp1+2
.e8b7	68		pla				pla
.e8b8	8d 99 20	sta $2099			sta 	Temp1+1
.e8bb	68		pla				pla
.e8bc	8d 98 20	sta $2098			sta 	Temp1+0
.e8bf	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; set Q bit 1.
.e8c2	09 01		ora #$01			ora 	#1
.e8c4	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8c7	80 03		bra $e8cc			bra 	_BFDNext
.e8c9					_BFDNoAdd:
.e8c9	68		pla				pla 								; Throw away the intermediate calculations
.e8ca	68		pla				pla
.e8cb	68		pla				pla
.e8cc					_BFDNext:
.e8cc	88		dey				dey
.e8cd	d0 ab		bne $e87a			bne 	_BFDLoop
.e8cf	7a		ply				ply 								; restore Y and exit
.e8d0	4e 9c 20	lsr $209c			lsr 	SignCount 					; if sign count odd,
.e8d3	b0 06		bcs $e8db			bcs		BFUNC_NegateAlways 			; negate the result
.e8d5	60		rts				rts
.e8d6					BFUNC_Negate:
.e8d6	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.e8d9	10 24		bpl $e8ff			bpl 	BFNExit
.e8db					BFUNC_NegateAlways:
.e8db	38		sec				sec
.e8dc	a9 00		lda #$00			lda 	#0
.e8de	fd 00 04	sbc $0400,x			sbc 	evalStack+0,x
.e8e1	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e8e4	a9 00		lda #$00			lda 	#0
.e8e6	fd 01 04	sbc $0401,x			sbc 	evalStack+1,x
.e8e9	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e8ec	a9 00		lda #$00			lda 	#0
.e8ee	fd 02 04	sbc $0402,x			sbc 	evalStack+2,x
.e8f1	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e8f4	a9 00		lda #$00			lda 	#0
.e8f6	fd 03 04	sbc $0403,x			sbc 	evalStack+3,x
.e8f9	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e8fc	ee 9c 20	inc $209c			inc 	SignCount
.e8ff					BFNExit:
.e8ff	60		rts				rts
.e900					BFUNC_Modulus:
.e900	20 38 e8	jsr $e838			jsr 	BFUNC_Divide 				; start with division.
.e903	ad 98 20	lda $2098			lda 	Temp1+0 					; copy remainder
.e906	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e909	ad 99 20	lda $2099			lda 	Temp1+1
.e90c	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e90f	ad 9a 20	lda $209a			lda 	Temp1+2
.e912	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e915	ad 9b 20	lda $209b			lda 	Temp1+3
.e918	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e91b	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: binary/compare.asm

.e91c					BFUNC_Equals:
.e91c	18		clc				clc
.e91d	80 01		bra $e920			bra 	BFUNC_EqualCheck
.e91f					BFUNC_NotEquals:
.e91f	38		sec				sec
.e920					BFUNC_EqualCheck:
.e920	08		php				php									; save invert flag
.e921	ad 00 04	lda $0400			lda 	evalStack+0 				; check equality
.e924	cd 04 04	cmp $0404			cmp 	evalStack+4
.e927	d0 1c		bne $e945			bne 	COMP_Fail
.e929	ad 01 04	lda $0401			lda 	evalStack+1
.e92c	cd 05 04	cmp $0405			cmp 	evalStack+5
.e92f	d0 14		bne $e945			bne 	COMP_Fail
.e931	ad 02 04	lda $0402			lda 	evalStack+2
.e934	cd 06 04	cmp $0406			cmp 	evalStack+6
.e937	d0 0c		bne $e945			bne 	COMP_Fail
.e939	ad 03 04	lda $0403			lda 	evalStack+3
.e93c	cd 07 04	cmp $0407			cmp 	evalStack+7
.e93f	d0 04		bne $e945			bne 	COMP_Fail
.e941					COMP_Succeed:
.e941	a9 ff		lda #$ff			lda 	#$FF
.e943	80 02		bra $e947			bra 	COMP_SetResult
.e945					COMP_Fail:
.e945	a9 00		lda #$00			lda 	#0 							; here return 0
.e947					COMP_SetResult:
.e947	28		plp				plp 								; but if CS
.e948	90 02		bcc $e94c			bcc 	COMP_Accept
.e94a	49 ff		eor #$ff			eor 	#$FF 						; invert that
.e94c					COMP_Accept:
.e94c	9d 00 04	sta $0400,x			sta 	evalStack+0,x 				; write to result.
.e94f	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e952	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e955	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e958	60		rts				rts
.e959					BFUNC_Less:
.e959	18		clc				clc
.e95a	80 01		bra $e95d			bra 	BFUNC_LessCheck
.e95c					BFUNC_GreaterEqual:
.e95c	38		sec				sec
.e95d					BFUNC_LessCheck:
.e95d	08		php				php
.e95e	38		sec				sec
.e95f	ad 00 04	lda $0400			lda 	evalStack+0 				; compare using direct subtraction
.e962	ed 04 04	sbc $0404			sbc 	evalStack+4
.e965	ad 01 04	lda $0401			lda 	evalStack+1
.e968	ed 05 04	sbc $0405			sbc 	evalStack+5
.e96b	ad 02 04	lda $0402			lda 	evalStack+2
.e96e	ed 06 04	sbc $0406			sbc 	evalStack+6
.e971	ad 03 04	lda $0403			lda 	evalStack+3
.e974	ed 07 04	sbc $0407			sbc 	evalStack+7
.e977	30 c8		bmi $e941			bmi 	COMP_Succeed
.e979	80 ca		bra $e945			bra 	COMP_Fail
.e97b					BFUNC_Greater:
.e97b	18		clc				clc
.e97c	80 01		bra $e97f			bra 	BFUNC_GreaterCheck
.e97e					BFUNC_LessEqual:
.e97e	38		sec				sec
.e97f					BFUNC_GreaterCheck:
.e97f	08		php				php
.e980	38		sec				sec
.e981	ad 04 04	lda $0404			lda 	evalStack+4 				; compare using direct subtraction
.e984	ed 00 04	sbc $0400			sbc 	evalStack+0
.e987	ad 05 04	lda $0405			lda 	evalStack+5
.e98a	ed 01 04	sbc $0401			sbc 	evalStack+1
.e98d	ad 06 04	lda $0406			lda 	evalStack+6
.e990	ed 02 04	sbc $0402			sbc 	evalStack+2
.e993	ad 07 04	lda $0407			lda 	evalStack+7
.e996	ed 03 04	sbc $0403			sbc 	evalStack+3
.e999	30 a6		bmi $e941			bmi 	COMP_Succeed
.e99b	80 a8		bra $e945			bra 	COMP_Fail

;******  Return to file: basic.asm


;******  Processing file: binary/scompare.asm

.e99d					BFUNC_StringCompare:
.e99d	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get address into temporaries.
.e9a0	85 26		sta $26				sta 	zTemp1
.e9a2	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e9a5	85 27		sta $27				sta 	zTemp1+1
.e9a7	bd 04 04	lda $0404,x			lda 	evalStack+4,x
.e9aa	85 28		sta $28				sta 	zTemp2
.e9ac	bd 05 04	lda $0405,x			lda 	evalStack+5,x
.e9af	85 29		sta $29				sta 	zTemp2+1
.e9b1	5a		phy				phy
.e9b2	a0 00		ldy #$00			ldy 	#0
.e9b4					_BFSCLoop:
.e9b4	b1 26		lda ($26),y			lda 	(zTemp1),y 					; comparison
.e9b6	38		sec				sec
.e9b7	d1 28		cmp ($28),y			cmp 	(zTemp2),y
.e9b9	d0 15		bne $e9d0			bne		_BFSCDifferent 				; return different result.
.e9bb	c8		iny				iny
.e9bc	c9 00		cmp #$00			cmp 	#0							; until both EOS.
.e9be	d0 f4		bne $e9b4			bne 	_BFSCLoop
.e9c0	7a		ply				ply
.e9c1	a9 00		lda #$00			lda 	#0
.e9c3					_BFSCSetAll:
.e9c3	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.e9c6	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.e9c9	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.e9cc	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.e9cf	60		rts				rts
.e9d0					_BFSCDifferent:
.e9d0	7a		ply				ply
.e9d1	a9 ff		lda #$ff			lda 	#255 						; if CC set all as <
.e9d3	90 ee		bcc $e9c3			bcc 	_BFSCSetAll
.e9d5	a9 00		lda #$00			lda 	#0 							; set all zero
.e9d7	20 c3 e9	jsr $e9c3			jsr 	_BFSCSetAll
.e9da	fe 00 04	inc $0400,x			inc 	evalStack+0,x 				; and make it one.
.e9dd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: unary/unary.asm

.e9de					UNARY_Len:
.e9de	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.e9e1	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.e9e4	85 26		sta $26				sta 	zTemp1
.e9e6	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.e9e9	85 27		sta $27				sta 	zTemp1+1
.e9eb	5a		phy				phy
.e9ec	a0 00		ldy #$00			ldy 	#0 							; now figure out its length.
.e9ee					_ULGetLength:
.e9ee	b1 26		lda ($26),y			lda 	(zTemp1),y 					; read character
.e9f0	f0 1d		beq $ea0f			beq 	_ULFoundEOL 				; found end of line.
.e9f2	c8		iny				iny
.e9f3	d0 f9		bne $e9ee			bne 	_ULGetLength 				; scan 256 only.
.e9f5	20 2f e1	jsr $e12f			jsr 	ReportError
>e9f8	43 41 4e 4e 4f 54 20 46				.text 	"CANNOT FIND STRING END",$00
>ea00	49 4e 44 20 53 54 52 49 4e 47 20 45 4e 44 00
.ea0f					_ULFoundEOL:
.ea0f	98		tya				tya 								; length in A, restore Y
.ea10	7a		ply				ply
.ea11					UNARY_ReturnByte:
.ea11	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea14	a9 00		lda #$00			lda 	#0 							; clear the rests
.ea16	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea19	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea1c	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea1f	60		rts				rts
.ea20					UNARY_Ch:
.ea20	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.ea23	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; copy string address to zTemp1
.ea26	85 26		sta $26				sta 	zTemp1
.ea28	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ea2b	85 27		sta $27				sta 	zTemp1+1
.ea2d	5a		phy				phy
.ea2e	a0 00		ldy #$00			ldy 	#0 							; now get first character
.ea30	b1 26		lda ($26),y			lda 	(zTemp1),y
.ea32	7a		ply				ply
.ea33	80 dc		bra $ea11			bra 	UNARY_ReturnByte 			; return that byte.
.ea35					UNARY_Abs:
.ea35	ea		nop				nop
.ea36	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel 	; get the string to measure the length of.
.ea39	20 d6 e8	jsr $e8d6			jsr 	BFUNC_Negate 				; there's an ABS routine in divide
.ea3c	60		rts				rts
.ea3d					UNARY_Top:
.ea3d	ad 96 20	lda $2096			lda 	highMemory
.ea40	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea43	ad 97 20	lda $2097			lda 	highMemory+1
.ea46	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea49	a9 00		lda #$00			lda 	#0
.ea4b	9d 02 04	sta $0402,x			sta 	evalStack+2,x
.ea4e	9d 03 04	sta $0403,x			sta 	evalStack+3,x
.ea51	60		rts				rts
.ea52					UNARY_Rnd:
.ea52	20 5d ea	jsr $ea5d			jsr 	Random16 					; call 16 bit RNG twice
.ea55	e8		inx				inx
.ea56	e8		inx				inx
.ea57	20 5d ea	jsr $ea5d			jsr 	Random16
.ea5a	ca		dex				dex
.ea5b	ca		dex				dex
.ea5c	60		rts				rts
.ea5d					Random16:
.ea5d	ad 9e 20	lda $209e			lda 	RandomSeed 					; initialise if nonzero
.ea60	0d 9f 20	ora $209f			ora 	RandomSeed+1
.ea63	d0 0d		bne $ea72			bne 	_R16_NoInit
.ea65	ee 9e 20	inc $209e			inc 	RandomSeed 					; by setting low to 1
.ea68	5a		phy				phy
.ea69	a0 14		ldy #$14			ldy 	#20 						; call it 20 times to get it started
.ea6b					_R16_Setup:
.ea6b	20 5d ea	jsr $ea5d			jsr 	Random16
.ea6e	88		dey				dey
.ea6f	d0 fa		bne $ea6b			bne 	_R16_Setup
.ea71	7a		ply				ply
.ea72					_R16_NoInit:
.ea72	4e 9f 20	lsr $209f			lsr 	RandomSeed+1				; shift seed right
.ea75	6e 9e 20	ror $209e			ror 	RandomSeed
.ea78	90 08		bcc $ea82			bcc 	_R16_NoXor
.ea7a	ad 9f 20	lda $209f			lda 	RandomSeed+1				; xor MSB with $B4 if bit set.
.ea7d	49 b4		eor #$b4			eor 	#$B4 						; like the Wikipedia one.
.ea7f	8d 9f 20	sta $209f			sta 	RandomSeed+1
.ea82					_R16_NoXor:
.ea82	ad 9e 20	lda $209e			lda 	RandomSeed					; copy result to evaluate stack.
.ea85	9d 00 04	sta $0400,x			sta 	evalStack+0,x
.ea88	ad 9f 20	lda $209f			lda 	RandomSeed+1
.ea8b	9d 01 04	sta $0401,x			sta 	evalStack+1,x
.ea8e	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/execute.asm

.ea8f					COMMAND_Run:
.ea8f	20 4c eb	jsr $eb4c			jsr 	COMMAND_Clear 				; clear everything for a new run.
.ea92	a2 00		ldx #$00			ldx 	#BasicProgram & 255 		; start from here
.ea94	a0 23		ldy #$23			ldy 	#BasicProgram >> 8
.ea96	86 20		stx $20				stx 	zCurrentLine 				; set current line.
.ea98	84 21		sty $21				sty 	zCurrentLine+1
.ea9a					CRUNNewLine:
.ea9a	a0 00		ldy #$00			ldy 	#0 							; look at the offset, end of program
.ea9c	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ea9e	f0 60		beq $eb00			beq 	COMMAND_End 				; if zero, off end of program so stop.
.eaa0	a0 03		ldy #$03			ldy 	#3 							; offset to first token.
.eaa2					CRUNNextInstruction:
.eaa2	a9 00		lda #$00			lda 	#0 							; reset the string buffer position
.eaa4	8d 9d 20	sta $209d			sta 	StringBufferPos
.eaa7	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next token
.eaa9	f0 0b		beq $eab6			beq 	CRUNNextLine 				; if zero, then end of line.
.eaab					CRUNNotEndOfLine:
.eaab	c9 20		cmp #$20			cmp 	#' '
.eaad	f0 04		beq $eab3			beq 	CRUNSkipLoop
.eaaf	c9 8d		cmp #$8d			cmp 	#KW_Colon 					; check for a colon first.
.eab1	d0 1b		bne $eace			bne 	CRUNExecuteOne 				; if not that, execute the token.
.eab3					CRUNSkipLoop:
.eab3	c8		iny				iny		 							; if colon, skip it and loop round.
.eab4	80 ec		bra $eaa2			bra 	CRUNNextInstruction
.eab6					CRUNNextLine:
.eab6	a5 21		lda $21				lda 	zCurrentLine+1 				; running from input
.eab8	c9 21		cmp #$21			cmp 	#TokeniseBuffer>>8
.eaba	f0 0f		beq $eacb			beq		CRUNWarmStart
.eabc	a0 00		ldy #$00			ldy 	#0 							; add offset from line to line pointer
.eabe	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.eac0	18		clc				clc
.eac1	65 20		adc $20				adc 	zCurrentLine
.eac3	85 20		sta $20				sta 	zCurrentLine
.eac5	90 d3		bcc $ea9a			bcc 	CRUNNewLine
.eac7	e6 21		inc $21				inc 	zCurrentLine+1
.eac9	80 cf		bra $ea9a			bra 	CRUNNewLine
.eacb					CRUNWarmStart:
.eacb	4c 5e ee	jmp $ee5e			jmp 	WarmStart
.eace					CRUNExecuteOne:
.eace	09 00		ora #$00			ora 	#0 							; if it is a character might be a variable.
.ead0	10 21		bpl $eaf3			bpl		_CRUNX1TryLet
.ead2	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; likewise if ! something ? something $ something
.ead4	f0 1d		beq $eaf3			beq 	_CRUNX1TryLet
.ead6	c9 80		cmp #$80			cmp 	#KW_PLING
.ead8	f0 19		beq $eaf3			beq 	_CRUNX1TryLet
.eada	c9 95		cmp #$95			cmp 	#KW_QUESTION
.eadc	f0 15		beq $eaf3			beq 	_CRUNX1TryLet
.eade	c8		iny				iny 								; skip over loaded token
.eadf	0a		asl a				asl 	a 							; double lower keyword byte, clears bit 7.
.eae0	8d 99 20	sta $2099			sta 	Temp1+1 					; this is the low byte into the KVT
.eae3	8a		txa				txa
.eae4	a9 e0		lda #$e0			lda 	#KeywordVectorTable >> 8 	; set high byte of KVT
.eae6	8d 9a 20	sta $209a			sta 	Temp1+2
.eae9	a9 6c		lda #$6c			lda 	#$6C 						; make it jump indirect
.eaeb	8d 98 20	sta $2098			sta 	Temp1+0
.eaee	20 98 20	jsr $2098			jsr 	Temp1 						; call instruction
.eaf1	80 af		bra $eaa2			bra 	CRUNNextInstruction 		; do next instruction.
.eaf3					_CRUNX1TryLet:
.eaf3	20 b6 eb	jsr $ebb6			jsr 	COMMAND_Let 				; try doing a LET if not a keyword.
.eaf6	80 aa		bra $eaa2			bra 	CRUNNextInstruction
.eaf8					COMMAND_Stop:
.eaf8	20 2f e1	jsr $e12f			jsr 	ReportError
>eafb	53 54 4f 50 00					.text 	"STOP",$00
.eb00					COMMAND_End:
.eb00	ad 4d 23	lda $234d			lda 	StartBehaviour 				; running program
.eb03	c9 52		cmp #$52			cmp 	#"R"
.eb05	d0 01		bne $eb08			bne 	_CEWarmStart
>eb07	02						.byte 	2
.eb08					_CEWarmStart:
.eb08	4c 5e ee	jmp $ee5e			jmp 	WarmStart

;******  Return to file: basic.asm


;******  Processing file: commands/miscellany.asm

.eb0b					COMMAND_Assert:
.eb0b	20 c7 e1	jsr $e1c7			jsr 	EvaluateBase 				; evaluate the expression
.eb0e	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; check non zero
.eb11	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.eb14	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.eb17	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.eb1a	d0 12		bne $eb2e			bne 	_CMDAExit
.eb1c	ea		nop				nop
.eb1d	20 2f e1	jsr $e12f			jsr 	ReportError
>eb20	41 53 53 45 52 54 20 46				.text 	"ASSERT FAILED",$00
>eb28	41 49 4c 45 44 00
.eb2e					_CMDAExit:
.eb2e	60		rts				rts
.eb2f					COMMAND_Rem:
.eb2f	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get next character token.
.eb31	f0 05		beq $eb38			beq 	_CREMExit 					; End of line, then exit.
.eb33	c8		iny				iny 								; something to skip
.eb34	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; if not a colon
.eb36	d0 f7		bne $eb2f			bne 	COMMAND_Rem 				; keep searching
.eb38					_CREMExit:
.eb38	60		rts				rts
.eb39					COMMAND_New:
.eb39	a9 00		lda #$00			lda 	#0 							; erase the actual program.
.eb3b	8d 00 23	sta $2300			sta 	BasicProgram 				; by zeroing the initial offset.
.eb3e	20 4c eb	jsr $eb4c			jsr 	COMMAND_Clear 				; clear non fixed variable, reset stack and low mem pointer
.eb41	a9 00		lda #$00			lda 	#endMemory & $FF 			; reset high memory pointer.
.eb43	8d 96 20	sta $2096			sta 	HighMemory
.eb46	a9 80		lda #$80			lda 	#endMemory >> 8
.eb48	8d 97 20	sta $2097			sta 	HighMemory+1
.eb4b	60		rts				rts
.eb4c					COMMAND_Clear:
.eb4c	a2 00		ldx #$00			ldx 	#0	 						; clear variables @A-Z
.eb4e					_CCClearVar:
.eb4e	a9 00		lda #$00			lda 	#$00
.eb50	9d 00 20	sta $2000,x			sta 	FixedVariables,x
.eb53	e8		inx				inx
.eb54	e0 6c		cpx #$6c			cpx 	#27*4
.eb56	10 f6		bpl $eb4e			bpl 	_CCClearVar
.eb58	a9 00		lda #$00			lda 	#basicStack & $FF 			; reset BASIC stack
.eb5a	85 22		sta $22				sta 	zBasicStack
.eb5c	a9 02		lda #$02			lda 	#basicStack >> 8
.eb5e	85 23		sta $23				sta 	zBasicStack+1
.eb60	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; now find where the program ends.
.eb62	85 24		sta $24				sta 	zLowMemory
.eb64	a9 23		lda #$23			lda 	#BasicProgram >> 8
.eb66	85 25		sta $25				sta 	zLowMemory+1
.eb68					_CCFindEnd:
.eb68	a0 00		ldy #$00			ldy 	#0 							; look at next offset
.eb6a	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; if zero, reached the end.
.eb6c	f0 0b		beq $eb79			beq 	_CCFoundEnd
.eb6e	18		clc				clc 								; go to next line.
.eb6f	65 24		adc $24				adc 	zLowMemory
.eb71	85 24		sta $24				sta 	zLowMemory
.eb73	90 f3		bcc $eb68			bcc 	_CCFindEnd
.eb75	e6 25		inc $25				inc 	zLowMemory+1
.eb77	80 ef		bra $eb68			bra 	_CCFindEnd
.eb79					_CCFoundEnd:
.eb79	e6 24		inc $24				inc 	zLowMemory 					; variables etc. start after end of program.
.eb7b	d0 02		bne $eb7f			bne 	_CCNoCarry 					; skip over zero end offset.
.eb7d	e6 25		inc $25				inc 	zLowMemory+1
.eb7f					_CCNoCarry:
.eb7f	60		rts				rts
.eb80					COMMAND_Old:
.eb80	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; point zLowMemory to the first line.
.eb82	85 24		sta $24				sta 	zLowMemory
.eb84	a9 23		lda #$23			lda 	#BasicProgram >> 8
.eb86	85 25		sta $25				sta 	zLowMemory+1
.eb88	a0 03		ldy #$03			ldy 	#3 							; look for the $00 end of line marker.
.eb8a					_COScan:
.eb8a	b1 24		lda ($24),y			lda 	(zLowMemory),y 				; look at next byte pair
.eb8c	c8		iny				iny
.eb8d	f0 0d		beq $eb9c			beq 	_COFail 					; can't find marker, corrupted maybe ?
.eb8f	c9 00		cmp #$00			cmp 	#0 							; until $00 found.
.eb91	d0 f7		bne $eb8a			bne 	_COScan
.eb93	98		tya				tya 								; Y is the new offset to the next instruction
.eb94	a0 00		ldy #$00			ldy 	#0 							; overwrite the old one
.eb96	91 24		sta ($24),y			sta 	(zLowMemory),y
.eb98	20 4c eb	jsr $eb4c			jsr 	COMMAND_Clear 				; reset variables, stacks and pointers.
.eb9b	60		rts				rts
.eb9c					_COFail:
.eb9c	20 2f e1	jsr $e12f			jsr 	ReportError
>eb9f	43 41 4e 4e 4f 54 20 52				.text 	"CANNOT RECOVER PROGRAM",$00
>eba7	45 43 4f 56 45 52 20 50 52 4f 47 52 41 4d 00

;******  Return to file: basic.asm


;******  Processing file: commands/let.asm

.ebb6					COMMAND_Let:
.ebb6	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; get first token not space
.ebb8	f0 58		beq $ec12			beq 	_CLESyntax
.ebba	c8		iny				iny
.ebbb	c9 20		cmp #$20			cmp 	#32
.ebbd	f0 f7		beq $ebb6			beq 	COMMAND_Let
.ebbf	88		dey				dey
.ebc0	c9 95		cmp #$95			cmp 	#KW_QUESTION				; check for first being indirect.
.ebc2	f0 51		beq $ec15			beq 	_CLEIndirect 				; e.g. !x = 42
.ebc4	c9 80		cmp #$80			cmp 	#KW_PLING
.ebc6	f0 4d		beq $ec15			beq 	_CLEIndirect
.ebc8	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ebca	f0 49		beq $ec15			beq 	_CLEIndirect
.ebcc	a2 00		ldx #$00			ldx 	#0 							; clear evaluation stack.
.ebce	20 da e3	jsr $e3da			jsr 	VARReference 				; get a variable reference.
.ebd1	a5 26		lda $26				lda 	zTemp1 						; copy into target addr
.ebd3	85 2a		sta $2a				sta 	zTargetAddr
.ebd5	a5 27		lda $27				lda 	zTemp1+1
.ebd7	85 2b		sta $2b				sta 	zTargetAddr+1
.ebd9	a5 28		lda $28				lda 	zTemp1+2
.ebdb	85 2c		sta $2c				sta 	zTargetAddr+2
.ebdd	a5 29		lda $29				lda 	zTemp1+3
.ebdf	85 2d		sta $2d				sta 	zTargetAddr+3
.ebe1					_CLEGetBinLHSOp:
.ebe1	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ebe3	f0 2d		beq $ec12			beq 	_CLESyntax
.ebe5	c8		iny				iny
.ebe6	c9 20		cmp #$20			cmp 	#' '
.ebe8	f0 f7		beq $ebe1			beq 	_CLEGetBinLHSOp
.ebea	88		dey				dey
.ebeb	c9 95		cmp #$95			cmp 	#KW_QUESTION 				; got some sort of reference, check
.ebed	f0 45		beq $ec34			beq 	_CLEBinaryLHTerm  			; if that's a basis for indirection ?
.ebef	c9 80		cmp #$80			cmp 	#KW_PLING
.ebf1	f0 41		beq $ec34			beq 	_CLEBinaryLHTerm
.ebf3	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ebf5	f0 3d		beq $ec34			beq 	_CLEBinaryLHTerm
.ebf7	a9 80		lda #$80			lda 	#KW_PLING 					; we want to do a 32 bit write.
.ebf9					_CLEWriteToAddress:
.ebf9	48		pha				pha 								; save write-type.
.ebfa	a9 92		lda #$92			lda 	#KW_EQUAL 					; check for '=' sign.
.ebfc	20 6b e1	jsr $e16b			jsr 	CheckNextCharacter
.ebff	20 c7 e1	jsr $e1c7			jsr 	EvaluateBase 				; evaluate the RHS.
.ec02	68		pla				pla
.ec03	c9 80		cmp #$80			cmp 	#KW_PLING
.ec05	f0 6e		beq $ec75			beq 	_CLEWordWrite
.ec07	c9 95		cmp #$95			cmp 	#KW_QUESTION
.ec09	f0 60		beq $ec6b			beq 	_CLEByteWrite
.ec0b	c9 83		cmp #$83			cmp 	#KW_DOLLAR
.ec0d					_ErrorInternal:
.ec0d	d0 fe		bne $ec0d			bne 	_ErrorInternal
.ec0f	4c 91 ec	jmp $ec91			jmp 	_CLEStringWrite
.ec12					_CLESyntax:
.ec12	4c 1f e1	jmp $e11f			jmp 	SyntaxError
.ec15					_CLEIndirect:
.ec15	48		pha				pha 								; save operator on stack
.ec16	c8		iny				iny									; advance over cursor
.ec17	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ec19	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel
.ec1c	bd 00 04	lda $0400,x			lda 	evalStack+0,x				; copy that as the address.
.ec1f	85 2a		sta $2a				sta 	zTargetAddr+0
.ec21	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ec24	85 2b		sta $2b				sta 	zTargetAddr+1
.ec26	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ec29	85 2c		sta $2c				sta 	zTargetAddr+2
.ec2b	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ec2e	85 2d		sta $2d				sta 	zTargetAddr+3
.ec30	68		pla				pla 								; restore operator.
.ec31	4c f9 eb	jmp $ebf9			jmp 	_CLEWriteToAddress
.ec34					_CLEBinaryLHTerm:
.ec34	48		pha				pha 								; save operator on stack
.ec35	c8		iny				iny 								; skip over it.
.ec36	a2 00		ldx #$00			ldx 	#0 							; evaluate the address to indirect through.
.ec38	20 c3 e1	jsr $e1c3			jsr 	EvaluateAtomCurrentLevel
.ec3b	a5 2a		lda $2a				lda 	zTargetAddr 				; copy zTargetAddr to zTemp1. Technically
.ec3d	85 26		sta $26				sta 	zTemp1 						; a four byte address.....
.ec3f	a5 2b		lda $2b				lda 	zTargetAddr+1
.ec41	85 27		sta $27				sta 	zTemp1+1 					; we only worry about 4 byte value
.ec43	5a		phy				phy 								; save Y
.ec44	18		clc				clc 								; add variable evaluated to (zTargetAddr)
.ec45	a0 00		ldy #$00			ldy 	#0
.ec47	b1 26		lda ($26),y			lda 	(zTemp1),y
.ec49	7d 00 04	adc $0400,x			adc 	evalStack+0,x
.ec4c	85 2a		sta $2a				sta 	zTargetAddr+0
.ec4e	c8		iny				iny
.ec4f	b1 26		lda ($26),y			lda 	(zTemp1),y
.ec51	7d 01 04	adc $0401,x			adc 	evalStack+1,x
.ec54	85 2b		sta $2b				sta 	zTargetAddr+1
.ec56	c8		iny				iny
.ec57	b1 26		lda ($26),y			lda 	(zTemp1),y
.ec59	7d 02 04	adc $0402,x			adc 	evalStack+2,x
.ec5c	85 2c		sta $2c				sta 	zTargetAddr+2
.ec5e	c8		iny				iny
.ec5f	b1 26		lda ($26),y			lda 	(zTemp1),y
.ec61	7d 03 04	adc $0403,x			adc 	evalStack+3,x
.ec64	85 2d		sta $2d				sta 	zTargetAddr+3
.ec66	7a		ply				ply 								; restore Y
.ec67	68		pla				pla 								; restore the operator.
.ec68	4c f9 eb	jmp $ebf9			jmp 	_CLEWriteToAddress
.ec6b					_CLEByteWrite:
.ec6b	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; get the byte to write.
.ec6e	5a		phy				phy 								; write the byte preserving Y
.ec6f	a0 00		ldy #$00			ldy 	#0
.ec71	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.ec73	7a		ply				ply
.ec74	60		rts				rts
.ec75					_CLEWordWrite:
.ec75	5a		phy				phy
.ec76	a0 00		ldy #$00			ldy 	#0
.ec78	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ec7b	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.ec7d	c8		iny				iny
.ec7e	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ec81	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.ec83	c8		iny				iny
.ec84	bd 02 04	lda $0402,x			lda 	evalStack+2,x
.ec87	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.ec89	c8		iny				iny
.ec8a	bd 03 04	lda $0403,x			lda 	evalStack+3,x
.ec8d	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.ec8f	7a		ply				ply 								; restore Y
.ec90	60		rts				rts
.ec91					_CLEStringWrite:
.ec91	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; source string -> zTemp1
.ec94	85 26		sta $26				sta 	zTemp1
.ec96	bd 01 04	lda $0401,x			lda 	evalStack+1,x
.ec99	85 27		sta $27				sta 	zTemp1+1
.ec9b	5a		phy				phy
.ec9c	a0 00		ldy #$00			ldy 	#0
.ec9e					_CLEStringCopy:
.ec9e	b1 26		lda ($26),y			lda 	(zTemp1),y
.eca0	91 2a		sta ($2a),y			sta 	(zTargetAddr),y
.eca2	c9 00		cmp #$00			cmp 	#0
.eca4	f0 16		beq $ecbc			beq	 	_CLEStringWritten
.eca6	c8		iny				iny
.eca7	d0 f5		bne $ec9e			bne 	_CLEStringCopy
.eca9	20 2f e1	jsr $e12f			jsr 	ReportError
>ecac	42 41 44 20 53 54 52 49				.text 	"BAD STRING COPY",$00
>ecb4	4e 47 20 43 4f 50 59 00
.ecbc					_CLEStringWritten:
.ecbc	7a		ply				ply
.ecbd	60		rts				rts

;******  Return to file: basic.asm


;******  Processing file: commands/print.asm

.ecbe					COMMAND_Print:
.ecbe	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; look at next character
.ecc0	f0 15		beq $ecd7			beq 	_CPRExitNL 					; zero end of line.
.ecc2	c8		iny				iny
.ecc3	c9 20		cmp #$20			cmp 	#' '
.ecc5	f0 f7		beq $ecbe			beq 	COMMAND_Print
.ecc7	c9 8d		cmp #$8d			cmp 	#KW_COLON 					; colon, end of line
.ecc9	f0 0c		beq $ecd7			beq 	_CPRExitNL
.eccb	c9 8e		cmp #$8e			cmp 	#KW_SEMICOLON 				; semicolon ?
.eccd	d0 0e		bne $ecdd			bne 	_CPRNotSemicolon
.eccf	b1 20		lda ($20),y			lda 	(zCurrentLine),y 			; look at next character, is ; last thing
.ecd1	f0 09		beq $ecdc			beq 	_CPRExit
.ecd3	c9 8d		cmp #$8d			cmp 	#KW_COLON
.ecd5	d0 e7		bne $ecbe			bne 	COMMAND_Print 				; if not, just go back round again
.ecd7					_CPRExitNL:
.ecd7	a9 0d		lda #$0d			lda 	#13
.ecd9	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ecdc					_CPRExit:
.ecdc	60		rts				rts
.ecdd					_CPRNotSemicolon:
.ecdd	c9 86		cmp #$86			cmp 	#KW_SQUOTE 					; single quote
.ecdf	f0 2b		beq $ed0c			beq 	_CPRNewLine 				; new line
.ece1	c9 81		cmp #$81			cmp 	#KW_DQUOTE 					; double quote
.ece3	d0 2e		bne $ed13			bne 	_CPRNotQuote
.ece5					_CPRPrintText:
.ece5	b1 20		lda ($20),y			lda 	(zCurrentLine),y			; get next character
.ece7	f0 0a		beq $ecf3			beq 	_CPRError 					; if zero no closing quote
.ece9	c8		iny				iny
.ecea	c9 81		cmp #$81			cmp 	#KW_DQUOTE					; double quote
.ecec	f0 d0		beq $ecbe			beq 	COMMAND_Print 				; go round again.
.ecee	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter 			; print and do next character
.ecf1	80 f2		bra $ece5			bra 	_CPRPrintText
.ecf3					_CPRError:
.ecf3	20 2f e1	jsr $e12f			jsr 	ReportError
>ecf6	4d 49 53 53 49 4e 47 20				.text 	"MISSING CLOSING QUOTE",$00
>ecfe	43 4c 4f 53 49 4e 47 20 51 55 4f 54 45 00
.ed0c					_CPRNewLine:
.ed0c	a9 0d		lda #$0d			lda 	#13
.ed0e	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ed11	80 ab		bra $ecbe			bra 	COMMAND_Print
.ed13					_CPRNotQuote:
.ed13	c9 83		cmp #$83			cmp 	#KW_DOLLAR 					; not a string ?
.ed15	d0 11		bne $ed28			bne 	_CPRNumber 					; print a number.
.ed17	20 c7 e1	jsr $e1c7			jsr 	EvaluateBase 				; this is the address to print.
.ed1a	5a		phy				phy
.ed1b	bc 01 04	ldy $0401,x			ldy 	evalStack+1,x 				; get the address
.ed1e	bd 00 04	lda $0400,x			lda 	evalStack+0,x
.ed21	aa		tax				tax
.ed22	20 67 e4	jsr $e467			jsr 	SIOPrintString
.ed25	7a		ply				ply
.ed26	80 96		bra $ecbe			bra 	COMMAND_Print
.ed28					_CPRNumber:
.ed28	c9 85		cmp #$85			cmp 	#KW_AMPERSAND
.ed2a	f0 17		beq $ed43			beq 	_CPRHexadecimal
.ed2c	88		dey				dey 								; must be 1st char of expr
.ed2d	20 c7 e1	jsr $e1c7			jsr 	EvaluateBase 				; this is the value to print.
.ed30	bd 03 04	lda $0403,x			lda 	evalStack+3,x 				; is it -ve
.ed33	10 08		bpl $ed3d			bpl 	_CPRIsPositive
.ed35	20 db e8	jsr $e8db			jsr 	BFUNC_NegateAlways 			; negate it
.ed38	a9 2d		lda #$2d			lda 	#"-" 						; print - it.
.ed3a	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ed3d					_CPRIsPositive:
.ed3d	20 80 ed	jsr $ed80			jsr 	CPRPrintInteger 			; Print string at current eval stack, base 10.
.ed40	4c be ec	jmp $ecbe			jmp 	COMMAND_Print
.ed43					_CPRHexadecimal:
.ed43	20 c7 e1	jsr $e1c7			jsr 	EvaluateBase 				; this is the value to print.
.ed46	20 4c ed	jsr $ed4c			jsr 	_CPRPrintRecHex 			; hex version of it.
.ed49	4c be ec	jmp $ecbe			jmp 	COMMAND_Print
.ed4c					_CPRPrintRecHex:
.ed4c	ad 00 04	lda $0400			lda 	evalStack+0 				; get the remainder
.ed4f	29 0f		and #$0f			and 	#15 						; and put on stack
.ed51	48		pha				pha
.ed52	a2 04		ldx #$04			ldx 	#4 							; divide by 16
.ed54					_CPRShiftDiv:
.ed54	4e 03 04	lsr $0403			lsr 	evalStack+3
.ed57	6e 02 04	ror $0402			ror 	evalStack+2
.ed5a	6e 01 04	ror $0401			ror		evalStack+1
.ed5d	6e 00 04	ror $0400			ror		evalStack+0
.ed60	ca		dex				dex
.ed61	d0 f1		bne $ed54			bne 	_CPRShiftDiv
.ed63	ad 00 04	lda $0400			lda 	evalStack+0 				; any more to print
.ed66	0d 01 04	ora $0401			ora 	evalStack+1
.ed69	0d 02 04	ora $0402			ora 	evalStack+2
.ed6c	0d 03 04	ora $0403			ora 	evalStack+3
.ed6f	f0 03		beq $ed74			beq 	_CPRNoHexRec
.ed71	20 4c ed	jsr $ed4c			jsr 	_CPRPrintRecHex
.ed74					_CPRNoHexRec:
.ed74	68		pla				pla 								; original remainder.
.ed75	c9 0a		cmp #$0a			cmp 	#10
.ed77	90 02		bcc $ed7b			bcc		_CPRNH2
.ed79	69 06		adc #$06			adc 	#6
.ed7b	69 30		adc #$30	_CPRNH2:adc 	#48
.ed7d	4c 94 e4	jmp $e494			jmp 	SIOPrintCharacter
.ed80					CPRPrintInteger:
.ed80	48		pha				pha 								; save on stack.
.ed81	da		phx				phx
.ed82	5a		phy				phy
.ed83	20 8a ed	jsr $ed8a			jsr 	_CPRPrintRec 				; recursive print call
.ed86	7a		ply				ply
.ed87	fa		plx				plx
.ed88	68		pla				pla
.ed89	60		rts				rts
.ed8a					_CPRPrintRec:
.ed8a	a9 0a		lda #$0a			lda 	#10 						; save base
.ed8c	9d 04 04	sta $0404,x			sta 	evalStack+4,x 				; put in next slot.
.ed8f	a9 00		lda #$00			lda 	#0 							; clear upper 3 bytes
.ed91	9d 05 04	sta $0405,x			sta 	evalStack+5,x
.ed94	9d 06 04	sta $0406,x			sta 	evalStack+6,x
.ed97	9d 07 04	sta $0407,x			sta 	evalStack+7,x
.ed9a	20 38 e8	jsr $e838			jsr 	BFUNC_Divide 				; divide by 10.
.ed9d	ad 98 20	lda $2098			lda 	Temp1+0		 				; push remainder on stack
.eda0	48		pha				pha
.eda1	bd 00 04	lda $0400,x			lda 	evalStack+0,x 				; is the result #0
.eda4	1d 01 04	ora $0401,x			ora 	evalStack+1,x
.eda7	1d 02 04	ora $0402,x			ora 	evalStack+2,x
.edaa	1d 03 04	ora $0403,x			ora 	evalStack+3,x
.edad	f0 03		beq $edb2			beq 	_CPRNoRecurse
.edaf	20 8a ed	jsr $ed8a			jsr 	_CPRPrintRec 				; recursive print.
.edb2					_CPRNoRecurse:
.edb2	68		pla				pla
.edb3	09 30		ora #$30			ora 	#"0"
.edb5	4c 94 e4	jmp $e494			jmp 	SIOPrintCharacter

;******  Return to file: basic.asm


;******  Processing file: commands/list.asm

.edb8					COMMAND_List:
.edb8	5a		phy				phy
.edb9	a9 00		lda #$00			lda 	#BasicProgram & $FF 		; set target address
.edbb	85 2a		sta $2a				sta 	zTargetAddr
.edbd	a9 23		lda #$23			lda 	#BasicProgram >> 8
.edbf	85 2b		sta $2b				sta 	zTargetAddr+1
.edc1	a9 10		lda #$10			lda 	#16 						; print 16 lines
.edc3	85 2c		sta $2c				sta 	zTargetAddr+2
.edc5					_CLLILoop:
.edc5	20 df ed	jsr $eddf			jsr 	CLIOneLine 					; list one line.
.edc8	a0 00		ldy #$00			ldy 	#0 							; advance pointer to next.
.edca	18		clc				clc
.edcb	b1 2a		lda ($2a),y			lda 	(zTargetAddr),y
.edcd	65 2a		adc $2a				adc 	zTargetAddr
.edcf	85 2a		sta $2a				sta 	zTargetAddr
.edd1	90 02		bcc $edd5			bcc 	_CLLINoCarry
.edd3	e6 2b		inc $2b				inc 	zTargetAddr+1
.edd5					_CLLINoCarry:
.edd5	b1 2a		lda ($2a),y			lda 	(zTargetAddr),y 			; if that offset is zero exit
.edd7	f0 04		beq $eddd			beq 	_CLLIExit
.edd9	c6 2c		dec $2c				dec 	zTargetAddr+2 				; done all of them ?
.eddb	d0 e8		bne $edc5			bne 	_CLLILoop
.eddd					_CLLIExit:
.eddd	7a		ply				ply
.edde	60		rts				rts
.eddf					CLIOneLine:
.eddf	a0 01		ldy #$01			ldy 	#1 							; get line#
.ede1	b1 2a		lda ($2a),y			lda 	(zTargetAddr),y
.ede3	8d 00 04	sta $0400			sta 	evalStack+0
.ede6	c8		iny				iny
.ede7	b1 2a		lda ($2a),y			lda 	(zTargetAddr),y
.ede9	8d 01 04	sta $0401			sta 	evalStack+1
.edec	a9 00		lda #$00			lda 	#0
.edee	aa		tax				tax
.edef	8d 02 04	sta $0402			sta 	evalStack+2
.edf2	8d 03 04	sta $0403			sta 	evalStack+3
.edf5	20 80 ed	jsr $ed80			jsr 	CPRPrintInteger 			; print line#
.edf8	a9 20		lda #$20			lda 	#32
.edfa	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.edfd	a0 03		ldy #$03			ldy 	#3 							; where to start
.edff					_CLIOutput:
.edff	b1 2a		lda ($2a),y			lda 	(zTargetAddr),y
.ee01	c8		iny				iny
.ee02	09 00		ora #$00			ora 	#0
.ee04	f0 0c		beq $ee12			beq 	_CLIExit
.ee06	10 05		bpl $ee0d			bpl		_CLISingle
.ee08	20 18 ee	jsr $ee18			jsr 	CLIPrintToken
.ee0b	80 f2		bra $edff			bra 	_CLIOutput
.ee0d					_CLISingle:
.ee0d	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ee10	80 ed		bra $edff			bra 	_CLIOutput
.ee12					_CLIExit:
.ee12	a9 0d		lda #$0d			lda 	#13 						; new line.
.ee14	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ee17	60		rts				rts
.ee18					CLIPrintToken:
.ee18	5a		phy				phy 								; save Y
.ee19	29 7f		and #$7f			and 	#$7F 						; 7 bit token -> Y
.ee1b	a8		tay				tay
.ee1c	a2 00		ldx #$00			ldx 	#0 							; offset into token text table.
.ee1e					_CLIFind:
.ee1e	88		dey				dey 								; decrement counter
.ee1f	30 09		bmi $ee2a			bmi 	_CLIFoundToken 				; if -ve found the token.
.ee21					_CLISkip:
.ee21	bd 6a e0	lda $e06a,x			lda 	TokenText,x
.ee24	e8		inx				inx
.ee25	0a		asl a				asl		a
.ee26	90 f9		bcc $ee21			bcc 	_CLISkip
.ee28	80 f4		bra $ee1e			bra 	_CLIFind
.ee2a					_CLIFoundToken:
.ee2a	7a		ply				ply
.ee2b					_CLIPrintIt:
.ee2b	bd 6a e0	lda $e06a,x			lda 	TokenText,x
.ee2e	e8		inx				inx
.ee2f	48		pha				pha
.ee30	29 7f		and #$7f			and 	#$7F
.ee32	20 94 e4	jsr $e494			jsr 	SIOPrintCharacter
.ee35	68		pla				pla
.ee36	0a		asl a				asl 	a
.ee37	90 f2		bcc $ee2b			bcc 	_CLIPrintIt
.ee39	60		rts				rts

;******  Return to file: basic.asm

.ee3a					Start:
.ee3a	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.ee3c	9a		txs			txs
.ee3d	20 56 e4	jsr $e456			jsr 	SIOInitialise 				; initialise the I/O system.
.ee40	ad 4d 23	lda $234d			lda 	StartBehaviour 				; what to do ?
.ee43	c9 43		cmp #$43			cmp 	#'C'						; execute from command line
.ee45	f0 14		beq $ee5b			beq		CommandLine
.ee47	c9 52		cmp #$52			cmp 	#'R' 						; run program in memory.
.ee49	f0 07		beq $ee52			beq	 	RunProgram
.ee4b	c9 54		cmp #$54			cmp 	#'T'						; tokenise test
.ee4d	f0 48		beq $ee97			beq 	TokeniseExec
.ee4f	4c 1f e1	jmp $e11f			jmp		SyntaxError
.ee52					RunProgram:
.ee52	20 39 eb	jsr $eb39			jsr 	COMMAND_New 				; do a new
.ee55	20 80 eb	jsr $eb80			jsr 	COMMAND_Old 				; get back the old program as we're deving.
.ee58	4c 8f ea	jmp $ea8f			jmp 	COMMAND_Run
.ee5b					CommandLine:
.ee5b	20 39 eb	jsr $eb39			jsr 	Command_New
.ee5e					WarmStart:
.ee5e	a2 ff		ldx #$ff		ldx 	#$FF 							; reset 6502 stack.
.ee60	9a		txs			txs
.ee61	20 d1 e4	jsr $e4d1			jsr 	SIOReadLine 				; read input line.
.ee64	a9 6d		lda #$6d			lda 	#InputLine & $FF 			; tokenise the line
.ee66	85 26		sta $26				sta 	zTemp1
.ee68	a9 20		lda #$20			lda 	#InputLine >> 8
.ee6a	85 27		sta $27				sta 	zTemp1+1
.ee6c	20 3f e6	jsr $e63f			jsr 	TokeniseString
.ee6f	a9 00		lda #$00			lda 	#TokeniseBuffer & $FF 		; point current line to tokenised input buffer.
.ee71	85 20		sta $20				sta 	zCurrentLine
.ee73	a9 21		lda #$21			lda 	#TokeniseBuffer >> 8
.ee75	85 21		sta $21				sta 	zCurrentLine+1
.ee77	a0 00		ldy #$00			ldy 	#0
.ee79					_WSSkipSpace:
.ee79	b1 20		lda ($20),y			lda 	(zCurrentLine),y
.ee7b	c8		iny				iny
.ee7c	c9 20		cmp #$20			cmp 	#' '
.ee7e	f0 f9		beq $ee79			beq 	_WSSkipSpace
.ee80	88		dey				dey
.ee81	c9 30		cmp #$30			cmp 	#"0" 						; if not a digit
.ee83	90 0f		bcc $ee94			bcc 	_WSExecute
.ee85	c9 3a		cmp #$3a			cmp 	#"9"+1
.ee87	b0 0b		bcs $ee94			bcs 	_WSExecute
.ee89	20 2f e1	jsr $e12f			jsr 	ReportError
>ee8c	4e 4f 20 45 44 49 54 00				.text 	"NO EDIT",$00
.ee94					_WSExecute:
.ee94	4c a2 ea	jmp $eaa2			jmp 	CRUNNextInstruction
.ee97					TokeniseExec:
.ee97	a9 00		lda #$00			lda 	#BasicCode & $FF 			; if so tokenise whatever I've put in the basic code
.ee99	85 26		sta $26				sta 	zTemp1 						; area
.ee9b	a9 23		lda #$23			lda 	#BasicCode >> 8
.ee9d	85 27		sta $27				sta 	zTemp1+1
.ee9f	20 3f e6	jsr $e63f			jsr 	TokeniseString
>eea2	02						.byte 	2
.2300					BasicCode:

;******  Processing file: include/basic_generated.inc

>2300	1c 0a 00 83 82 31 43 30			.byte $1c,$0a,$00,$83,$82,$31,$43,$30,$30,$92,$81,$54,$45,$53,$54,$49,$4e,$47,$21,$81,$8d,$58,$20,$92,$20,$8b,$34,$00,$29,$d2,$00,$aa,$20,$81,$48,$45,$4c,$4c,$4f,$20,$57,$4f,$52,$4c,$44,$21,$81,$86,$86,$81,$42,$59,$45,$2e,$81,$8e,$86,$83,$82,$31,$43,$30,$30,$86,$58,$86,$85,$58,$00,$07,$2c,$01,$a2,$8d,$ae,$00,$00
>2308	30 92 81 54 45 53 54 49 4e 47 21 81 8d 58 20 92
>2318	20 8b 34 00 29 d2 00 aa 20 81 48 45 4c 4c 4f 20
>2328	57 4f 52 4c 44 21 81 86 86 81 42 59 45 2e 81 8e
>2338	86 83 82 31 43 30 30 86 58 86 85 58 00 07 2c 01
>2348	a2 8d ae 00 00
.234d					StartBehaviour:
>234d	52					.text "R"

;******  Return to file: basic.asm


;******  End of listing
